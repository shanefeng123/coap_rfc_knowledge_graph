introduction the use of web services (web apis) on the internet has become ubiquitous in most applications and depends on the fundamental representational state transfer [rest] architecture of the web.
the work on constrained restful environments (core) aims at realizing the rest architecture in a suitable form for the most constrained nodes (e.g., 8-bit microcontrollers with limited ram and rom) and networks (e.g., 6lowpan, [rfc4944]).
constrained networks such as 6lowpan support the fragmentation of ipv6 packets into small link- layer frames; however, this causes significant reduction in packet delivery probability.
one design goal of coap has been to keep message overhead small, thus limiting the need for fragmentation.
one of the main goals of coap is to design a generic web protocol for the special requirements of this constrained environment, especially considering energy, building automation, and other machine-to-machine (m2m) applications.
the goal of coap is not to blindly compress http [rfc2616], but rather to realize a subset of rest common with http but optimized for m2m applications.
although coap could be used for refashioning simple http interfaces into a more compact protocol, more importantly it also offers features for m2m such as built-in discovery, multicast support, and asynchronous message exchanges.
this document specifies the constrained application protocol (coap), which easily translates to http for integration with the existing web while meeting specialized requirements such as multicast support, very low overhead, and simplicity for constrained environments and m2m applications.
features coap has the following main features: o web protocol fulfilling m2m requirements in constrained environments o udp [rfc0768] binding with optional reliability supporting unicast and multicast requests.
o asynchronous message exchanges.
o low header overhead and parsing complexity.
o uri and content-type support.
o simple proxy and caching capabilities.
o a stateless http mapping, allowing proxies to be built providing access to coap resources via http in a uniform way or for http simple interfaces to be realized alternatively over coap.
o security binding to datagram transport layer security (dtls) [rfc6347].
terminology the key words "must", "must not", "required", "shall", "shall not", "should", "should not", "recommended", "not recommended", "may", and "optional" in this document are to be interpreted as described in [rfc2119] when they appear in all caps.
these words may also appear in this document in lowercase, absent their normative meanings.
this specification requires readers to be familiar with all the terms and concepts that are discussed in [rfc2616], including "resource", "representation", "cache", and "fresh".
(having been completed before the updated set of http rfcs, rfc 7230 to rfc 7235, became available, this specification specifically references the predecessor version -- rfc 2616.)
in addition, this specification defines the following terminology: endpoint an entity participating in the coap protocol.
colloquially, an endpoint lives on a "node", although "host" would be more consistent with internet standards usage, and is further identified by transport-layer multiplexing information that can include a udp port number and a security association (section 4.1).
sender the originating endpoint of a message.
when the aspect of identification of the specific sender is in focus, also "source endpoint".
recipient the destination endpoint of a message.
when the aspect of identification of the specific recipient is in focus, also "destination endpoint".
client the originating endpoint of a request; the destination endpoint of a response.
server the destination endpoint of a request; the originating endpoint of a response.
origin server the server on which a given resource resides or is to be created.
intermediary a coap endpoint that acts both as a server and as a client towards an origin server (possibly via further intermediaries).
a common form of an intermediary is a proxy; several classes of such proxies are discussed in this specification.
proxy an intermediary that mainly is concerned with forwarding requests and relaying back responses, possibly performing caching, namespace translation, or protocol translation in the process.
as opposed to intermediaries in the general sense, proxies generally do not implement specific application semantics.
based on the position in the overall structure of the request forwarding, there are two common forms of proxy: forward-proxy and reverse-proxy.
in some cases, a single endpoint might act as an origin server, forward-proxy, or reverse-proxy, switching behavior based on the nature of each request.
forward-proxy an endpoint selected by a client, usually via local configuration rules, to perform requests on behalf of the client, doing any necessary translations.
some translations are minimal, such as for proxy requests for "coap" uris, whereas other requests might require translation to and from entirely different application- layer protocols.
reverse-proxy an endpoint that stands in for one or more other server(s) and satisfies requests on behalf of these, doing any necessary translations.
unlike a forward-proxy, the client may not be aware that it is communicating with a reverse-proxy; a reverse-proxy receives requests as if it were the origin server for the target resource.
coap-to-coap proxy a proxy that maps from a coap request to a coap request, i.e., uses the coap protocol both on the server and the client side.
contrast to cross-proxy.
cross-proxy a cross-protocol proxy, or "cross-proxy" for short, is a proxy that translates between different protocols, such as a coap-to- http proxy or an http-to-coap proxy.
while this specification makes very specific demands of coap-to-coap proxies, there is more variation possible in cross-proxies.
confirmable message some messages require an acknowledgement.
these messages are called "confirmable".
when no packets are lost, each confirmable message elicits exactly one return message of type acknowledgement or type reset.
non-confirmable message some other messages do not require an acknowledgement.
this is particularly true for messages that are repeated regularly for application requirements, such as repeated readings from a sensor.
acknowledgement message an acknowledgement message acknowledges that a specific confirmable message arrived.
by itself, an acknowledgement message does not indicate success or failure of any request encapsulated in the confirmable message, but the acknowledgement message may also carry a piggybacked response (see below).
reset message a reset message indicates that a specific message (confirmable or non-confirmable) was received, but some context is missing to properly process it.
this condition is usually caused when the receiving node has rebooted and has forgotten some state that would be required to interpret the message.
provoking a reset message (e.g., by sending an empty confirmable message) is also useful as an inexpensive check of the liveness of an endpoint ("coap ping").
piggybacked response a piggybacked response is included right in a coap acknowledgement (ack) message that is sent to acknowledge receipt of the request for this response (section 5.2.1).
separate response when a confirmable message carrying a request is acknowledged with an empty message (e.g., because the server doesn't have the answer right away), a separate response is sent in a separate message exchange (section 5.2.2).
empty message a message with a code of 0.00; neither a request nor a response.
an empty message only contains the 4-byte header.
critical option an option that would need to be understood by the endpoint ultimately receiving the message in order to properly process the message (section 5.4.1).
note that the implementation of critical options is, as the name "option" implies, generally optional: unsupported critical options lead to an error response or summary rejection of the message.
elective option an option that is intended to be ignored by an endpoint that does not understand it.
processing the message even without understanding the option is acceptable (section 5.4.1).
unsafe option an option that would need to be understood by a proxy receiving the message in order to safely forward the message (section 5.4.2).
not every critical option is an unsafe option.
safe-to-forward option an option that is intended to be safe for forwarding by a proxy that does not understand it.
forwarding the message even without understanding the option is acceptable (section 5.4.2).
resource discovery the process where a coap client queries a server for its list of hosted resources (i.e., links as defined in section 7).
content-format the combination of an internet media type, potentially with specific parameters given, and a content-coding (which is often the identity content-coding), identified by a numeric identifier defined by the "coap content-formats" registry.
when the focus is less on the numeric identifier than on the combination of these characteristics of a resource representation, this is also called "representation format".
additional terminology for constrained nodes and constrained-node networks can be found in [rfc7228].
in this specification, the term "byte" is used in its now customary sense as a synonym for "octet".
all multi-byte integers in this protocol are interpreted in network byte order.
where arithmetic is used, this specification uses the notation familiar from the programming language c, except that the operator "**" stands for exponentiation.
constrained application protocol the interaction model of coap is similar to the client/server model of http.
however, machine-to-machine interactions typically result in a coap implementation acting in both client and server roles.
a coap request is equivalent to that of http and is sent by a client to request an action (using a method code) on a resource (identified by a uri) on a server.
the server then sends a response with a response code; this response may include a resource representation.
unlike http, coap deals with these interchanges asynchronously over a datagram-oriented transport such as udp.
this is done logically using a layer of messages that supports optional reliability (with exponential back-off).
coap defines four types of messages: confirmable, non-confirmable, acknowledgement, reset.
method codes and response codes included in some of these messages make them carry requests or responses.
the basic exchanges of the four types of messages are somewhat orthogonal to the request/response interactions; requests can be carried in confirmable and non- confirmable messages, and responses can be carried in these as well as piggybacked in acknowledgement messages.
one could think of coap logically as using a two-layer approach, a coap messaging layer used to deal with udp and the asynchronous nature of the interactions, and the request/response interactions using method and response codes (see figure 1).
coap is however a single protocol, with messaging and request/response as just features of the coap header.
messaging model the coap messaging model is based on the exchange of messages over udp between endpoints.
coap uses a short fixed-length binary header (4 bytes) that may be followed by compact binary options and a payload.
this message format is shared by requests and responses.
the coap message format is specified in section 3.
each message contains a message id used to detect duplicates and for optional reliability.
(the message id is compact; its 16-bit size enables up to about 250 messages per second from one endpoint to another with default protocol parameters.)
reliability is provided by marking a message as confirmable (con).
a confirmable message is retransmitted using a default timeout and exponential back-off between retransmissions, until the recipient sends an acknowledgement message (ack) with the same message id (in this example, 0x7d34) from the corresponding endpoint; see figure 2.
when a recipient is not at all able to process a confirmable message (i.e., not even able to provide a suitable error response), it replies with a reset message (rst) instead of an acknowledgement (ack).
these are not acknowledged, but still have a message id for duplicate detection (in this example, 0x01a0); see figure 3.
when a recipient is not able to process a non-confirmable message, it may reply with a reset message (rst).
as coap runs over udp, it also supports the use of multicast ip destination addresses, enabling multicast coap requests.
section 8 discusses the proper use of coap messages with multicast addresses and precautions for avoiding response congestion.
several security modes are defined for coap in section 9 ranging from no security to certificate-based security.
this document specifies a binding to dtls for securing the protocol; the use of ipsec with coap is discussed in [ipsec-coap].
request/response model coap request and response semantics are carried in coap messages, which include either a method code or response code, respectively.
optional (or default) request and response information, such as the uri and payload media type are carried as coap options.
a token is used to match responses to requests independently from the underlying messages (section 5.3).
(note that the token is a concept separate from the message id.)
a request is carried in a confirmable (con) or non-confirmable (non) message, and, if immediately available, the response to a request carried in a confirmable message is carried in the resulting acknowledgement (ack) message.
this is called a piggybacked response, detailed in section 5.2.1.
(there is no need for separately acknowledging a piggybacked response, as the client will retransmit the request if the acknowledgement message carrying the piggybacked response is lost.)
two examples for a basic get request with piggybacked response are shown in figure 4, one successful, one resulting in a 4.04 (not found) response.
when the response is ready, the server sends it in a new confirmable message (which then in turn needs to be acknowledged by the client).
this is called a "separate response", as illustrated in figure 5 and described in more detail in section 5.2.2.
if a request is sent in a non-confirmable message, then the response is sent using a new non-confirmable message, although the server may instead send a confirmable message.
this type of exchange is illustrated in figure 6.
(note that the detailed semantics of coap methods are "almost, but not entirely unlike" [hhgttg] those of http methods: intuition taken from http experience generally does apply well, but there are enough differences that make it worthwhile to actually read the present specification.)
methods beyond the basic four can be added to coap in separate specifications.
new methods do not necessarily have to use requests and responses in pairs.
even for existing methods, a single request may yield multiple responses, e.g., for a multicast request (section 8) or with the observe option [observe].
uri support in a server is simplified as the client already parses the uri and splits it into host, port, path, and query components, making use of default values for efficiency.
response codes relate to a small subset of http status codes with a few coap-specific codes added, as defined in section 5.9.
intermediaries and caching the protocol supports the caching of responses in order to efficiently fulfill requests.
simple caching is enabled using freshness and validity information carried with coap responses.
a cache could be located in an endpoint or an intermediary.
caching functionality is specified in section 5.6.
proxying is useful in constrained networks for several reasons, including to limit network traffic, to improve performance, to access resources of sleeping devices, and for security reasons.
the proxying of requests on behalf of another coap endpoint is supported in the protocol.
when using a proxy, the uri of the resource to request is included in the request, while the destination ip address is set to the address of the proxy.
see section 5.7 for more information on proxy functionality.
as coap was designed according to the rest architecture [rest], and thus exhibits functionality similar to that of the http protocol, it is quite straightforward to map from coap to http and from http to coap.
such a mapping may be used to realize an http rest interface using coap or to convert between http and coap.
this conversion can be carried out by a cross-protocol proxy ("cross-proxy"), which converts the method or response code, media type, and options to the corresponding http feature.
section 10 provides more detail about http mapping.
resource discovery resource discovery is important for machine-to-machine interactions and is supported using the core link format [rfc6690] as discussed in section 7.
message format coap is based on the exchange of compact messages that, by default, are transported over udp (i.e., each coap message occupies the data section of one udp datagram).
coap may also be used over datagram transport layer security (dtls) (see section 9.1).
it could also be used over other transports such as sms, tcp, or sctp, the specification of which is out of this document's scope.
(udp-lite [rfc3828] and udp zero checksum [rfc6936] are not supported by coap.)
coap messages are encoded in a simple binary format.
the message format starts with a fixed-size 4-byte header.
this is followed by a variable-length token value, which can be between 0 and 8 bytes long.
following the token value comes a sequence of zero or more coap options in type-length-value (tlv) format, optionally followed by a payload that takes up the rest of the datagram.
indicates the coap version number.
implementations of this specification must set this field to 1 (01 binary).
other values are reserved for future versions.
messages with unknown version numbers must be silently ignored.
type (t): 2-bit unsigned integer.
indicates if this message is of type confirmable (0), non-confirmable (1), acknowledgement (2), or reset (3).
the semantics of these message types are defined in section 4.
token length (tkl): 4-bit unsigned integer.
indicates the length of the variable-length token field (0-8 bytes).
lengths 9-15 are reserved, must not be sent, and must be processed as a message format error.
code: 8-bit unsigned integer, split into a 3-bit class (most significant bits) and a 5-bit detail (least significant bits), documented as "c.dd" where "c" is a digit from 0 to 7 for the 3-bit subfield and "dd" are two digits from 00 to 31 for the 5-bit subfield.
the class can indicate a request (0), a success response (2), a client error response (4), or a server error response (5).
(all other class values are reserved.)
as a special case, code 0.00 indicates an empty message.
in case of a request, the code field indicates the request method; in case of a response, a response code.
possible values are maintained in the coap code registries (section 12.1).
the semantics of requests and responses are defined in section 5.
message id: 16-bit unsigned integer in network byte order.
used to detect message duplication and to match messages of type acknowledgement/reset to messages of type confirmable/non- confirmable.
the rules for generating a message id and matching messages are defined in section 4.
the header is followed by the token value, which may be 0 to 8 bytes, as given by the token length field.
the token value is used to correlate requests and responses.
the rules for generating a token and correlating requests and responses are defined in section 5.3.1.
header and token are followed by zero or more options (section 3.1).
an option can be followed by the end of the message, by another option, or by the payload marker and the payload.
following the header, token, and options, if any, comes the optional payload.
if present and of non-zero length, it is prefixed by a fixed, one-byte payload marker (0xff), which indicates the end of options and the start of the payload.
the payload data extends from after the marker to the end of the udp datagram, i.e., the payload length is calculated from the datagram size.
the absence of the payload marker denotes a zero-length payload.
the presence of a marker followed by a zero-length payload must be processed as a message format error.
implementation note: the byte value 0xff may also occur within an option length or value, so simple byte-wise scanning for 0xff is not a viable technique for finding the payload marker.
the byte 0xff has the meaning of a payload marker only where the beginning of another option could occur.
option format coap defines a number of options that can be included in a message.
each option instance in a message specifies the option number of the defined coap option, the length of the option value, and the option value itself.
instead of specifying the option number directly, the instances must appear in order of their option numbers and a delta encoding is used between them: the option number for each instance is calculated as the sum of its delta and the option number of the preceding instance in the message.
for the first instance in a message, a preceding option instance with option number zero is assumed.
multiple instances of the same option can be included by using a delta of zero.
option numbers are maintained in the "coap option numbers" registry (section 12.2).
see section 5.4 for the semantics of the options defined in this document.
a value between 0 and 12 indicates the option delta.
three values are reserved for special constructs: 13: an 8-bit unsigned integer follows the initial byte and indicates the option delta minus 13.
14: a 16-bit unsigned integer in network byte order follows the initial byte and indicates the option delta minus 269.
15: reserved for the payload marker.
if the field is set to this value but the entire byte is not the payload marker, this must be processed as a message format error.
the resulting option delta is used as the difference between the option number of this option and that of the previous option (or zero for the first option).
in other words, the option number is calculated by simply summing the option delta values of this and all previous options before it.
option length: 4-bit unsigned integer.
a value between 0 and 12 indicates the length of the option value, in bytes.
three values are reserved for special constructs: 13: an 8-bit unsigned integer precedes the option value and indicates the option length minus 13.
14: a 16-bit unsigned integer in network byte order precedes the option value and indicates the option length minus 269.
15: reserved for future use.
if the field is set to this value, it must be processed as a message format error.
value: a sequence of exactly option length bytes.
the length and format of the option value depend on the respective option, which may define variable-length values.
see section 3.2 for the formats used in this document; options defined in other documents may make use of other option value formats.
option value formats the options defined in this document make use of the following option value formats.
empty: a zero-length sequence of bytes.
opaque: an opaque sequence of bytes.
uint: a non-negative integer that is represented in network byte order using the number of bytes given by the option length field.
an option definition may specify a range of permissible numbers of bytes; if it has a choice, a sender should represent the integer with as few bytes as possible, i.e., without leading zero bytes.
for example, the number 0 is represented with an empty option value (a zero-length sequence of bytes) and the number 1 by a single byte with the numerical value of 1 (bit combination 00000001 in most significant bit first notation).
a recipient must be prepared to process values with leading zero bytes.
implementation note: the exceptional behavior permitted for the sender is intended for highly constrained, templated implementations (e.g., hardware implementations) that use fixed-size options in the templates.
string: a unicode string that is encoded using utf-8 [rfc3629] in net-unicode form [rfc5198].
note that here, and in all other places where utf-8 encoding is used in the coap protocol, the intention is that the encoded strings can be directly used and compared as opaque byte strings by coap protocol implementations.
there is no expectation and no need to perform normalization within a coap implementation (except where unicode strings that are not known to be normalized are imported from sources outside the coap protocol).
note also that ascii strings (that do not make use of special control characters) are always valid utf-8 net-unicode strings.
message transmission coap messages are exchanged asynchronously between coap endpoints.
they are used to transport coap requests and responses, the semantics of which are defined in section 5.
as coap is bound to unreliable transports such as udp, coap messages may arrive out of order, appear duplicated, or go missing without notice.
for this reason, coap implements a lightweight reliability mechanism, without trying to re-create the full feature set of a transport like tcp.
it has the following features: o simple stop-and-wait retransmission reliability with exponential back-off for confirmable messages.
o duplicate detection for both confirmable and non-confirmable messages.
messages and endpoints a coap endpoint is the source or destination of a coap message.
the specific definition of an endpoint depends on the transport being used for coap.
for the transports defined in this specification, the endpoint is identified depending on the security mode used (see section 9): with no security, the endpoint is solely identified by an ip address and a udp port number.
with other security modes, the endpoint is identified as defined by the security mode.
there are different types of messages.
the type of a message is specified by the type field of the coap header.
separate from the message type, a message may carry a request, a response, or be empty.
this is signaled by the request/response code field in the coap header and is relevant to the request/response model.
possible values for the field are maintained in the coap code registries (section 12.1).
an empty message has the code field set to 0.00.
the token length field must be set to 0 and bytes of data must not be present after the message id field.
if there are any bytes, they must be processed as a message format error.
messages transmitted reliably the reliable transmission of a message is initiated by marking the message as confirmable in the coap header.
a confirmable message always carries either a request or response, unless it is used only to elicit a reset message, in which case it is empty.
a recipient must either (a) acknowledge a confirmable message with an acknowledgement message or (b) reject the message if the recipient lacks context to process the message properly, including situations where the message is empty, uses a code with a reserved class (1, 6, or 7), or has a message format error.
rejecting a confirmable message is effected by sending a matching reset message and otherwise ignoring it.
the acknowledgement message must echo the message id of the confirmable message and must carry a response or be empty (see sections 5.2.1 and 5.2.2).
the reset message must echo the message id of the confirmable message and must be empty.
rejecting an acknowledgement or reset message (including the case where the acknowledgement carries a request or a code with a reserved class, or the reset message is not empty) is effected by silently ignoring it.
more generally, recipients of acknowledgement and reset messages must not respond with either acknowledgement or reset messages.
the sender retransmits the confirmable message at exponentially increasing intervals, until it receives an acknowledgement (or reset message) or runs out of attempts.
retransmission is controlled by two things that a coap endpoint must keep track of for each confirmable message it sends while waiting for an acknowledgement (or reset): a timeout and a retransmission counter.
for a new confirmable message, the initial timeout is set to a random duration (often not an integral number of seconds) between ack_timeout and (ack_timeout * ack_random_factor) (see section 4.8), and the retransmission counter is set to 0.
when the timeout is triggered and the retransmission counter is less than max_retransmit, the message is retransmitted, the retransmission counter is incremented, and the timeout is doubled.
if the retransmission counter reaches max_retransmit on a timeout, or if the endpoint receives a reset message, then the attempt to transmit the message is canceled and the application process informed of failure.
on the other hand, if the endpoint receives an acknowledgement in time, transmission is considered successful.
this specification makes no strong requirements on the accuracy of the clocks used to implement the above binary exponential back-off algorithm.
in particular, an endpoint may be late for a specific retransmission due to its sleep schedule and may catch up on the next one.
however, the minimum spacing before another retransmission is ack_timeout, and the entire sequence of (re-)transmissions must stay in the envelope of max_transmit_span (see section 4.8.2), even if that means a sender may miss an opportunity to transmit.
a coap endpoint that sent a confirmable message may give up in attempting to obtain an ack even before the max_retransmit counter value is reached.
for example, the application has canceled the request as it no longer needs a response, or there is some other indication that the con message did arrive.
in particular, a coap request message may have elicited a separate response, in which case it is clear to the requester that only the ack was lost and a retransmission of the request would serve no purpose.
however, a responder must not in turn rely on this cross-layer behavior from a requester, i.e., it must retain the state to create the ack for the request, if needed, even if a confirmable response was already acknowledged by the requester.
another reason for giving up retransmission may be the receipt of icmp errors.
if it is desired to take account of icmp errors, to mitigate potential spoofing attacks, implementations should take care to check the information about the original datagram in the icmp message, including port numbers and coap header information such as message type and code, message id, and token; if this is not possible due to limitations of the udp service api, icmp errors should be ignored.
packet too big errors [rfc4443] ("fragmentation needed and df set" for ipv4 [rfc0792]) cannot properly occur and should be ignored if the implementation note in section 4.6 is followed; otherwise, they should feed into a path mtu discovery algorithm [rfc4821].
source quench and time exceeded icmp messages should be ignored.
host, network, port, or protocol unreachable errors or parameter problem errors may, after appropriate vetting, be used to inform the application of a failure in sending.
messages transmitted without reliability some messages do not require an acknowledgement.
this is particularly true for messages that are repeated regularly for application requirements, such as repeated readings from a sensor where eventual success is sufficient.
as a more lightweight alternative, a message can be transmitted less reliably by marking the message as non-confirmable.
a non- confirmable message always carries either a request or response and must not be empty.
a non-confirmable message must not be acknowledged by the recipient.
a recipient must reject the message if it lacks context to process the message properly, including the case where the message is empty, uses a code with a reserved class (1, 6, or 7), or has a message format error.
rejecting a non- confirmable message may involve sending a matching reset message, and apart from the reset message the rejected message must be silently ignored.
at the coap level, there is no way for the sender to detect if a non- confirmable message was received or not.
a sender may choose to transmit multiple copies of a non-confirmable message within max_transmit_span (limited by the provisions of section 4.7, in particular, by probing_rate if no response is received), or the network may duplicate the message in transit.
to enable the receiver to act only once on the message, non-confirmable messages specify a message id as well.
(this message id is drawn from the same number space as the message ids for confirmable messages.)
summarizing sections 4.2 and 4.3, the four message types can be used as in table 1.
"*" means that the combination is not used in normal operation but only to elicit a reset message ("coap ping").
message correlation an acknowledgement or reset message is related to a confirmable message or non-confirmable message by means of a message id along with additional address information of the corresponding endpoint.
the message id is a 16-bit unsigned integer that is generated by the sender of a confirmable or non-confirmable message and included in the coap header.
the message id must be echoed in the acknowledgement or reset message by the recipient.
the same message id must not be reused (in communicating with the same endpoint) within the exchange_lifetime (section 4.8.2).
implementation note: several implementation strategies can be employed for generating message ids.
in the simplest case, a coap endpoint generates message ids by keeping a single message id variable, which is changed each time a new confirmable or non- confirmable message is sent, regardless of the destination address or port.
endpoints dealing with large numbers of transactions could keep multiple message id variables, for example, per prefix or destination address.
(note that some receiving endpoints may not be able to distinguish unicast and multicast packets addressed to it, so endpoints generating message ids need to make sure these do not overlap.)
it is strongly recommended that the initial value of the variable (e.g., on startup) be randomized, in order to make successful off-path attacks on the protocol less likely.
for an acknowledgement or reset message to match a confirmable or non-confirmable message, the message id and source endpoint of the acknowledgement or reset message must match the message id and destination endpoint of the confirmable or non-confirmable message.
message deduplication a recipient might receive the same confirmable message (as indicated by the message id and source endpoint) multiple times within the exchange_lifetime (section 4.8.2), for example, when its acknowledgement went missing or didn't reach the original sender before the first timeout.
the recipient should acknowledge each duplicate copy of a confirmable message using the same acknowledgement or reset message but should process any request or response in the message only once.
this rule may be relaxed in case the confirmable message transports a request that is idempotent (see section 5.1) or can be handled in an idempotent fashion.
examples for relaxed message deduplication: o a server might relax the requirement to answer all retransmissions of an idempotent request with the same response (section 4.2), so that it does not have to maintain state for message ids.
for example, an implementation might want to process duplicate transmissions of a get, put, or delete request as separate requests if the effort incurred by duplicate processing is less expensive than keeping track of previous responses would be.
o a constrained server might even want to relax this requirement for certain non-idempotent requests if the application semantics make this trade-off favorable.
for example, if the result of a post request is just the creation of some short-lived state at the server, it may be less expensive to incur this effort multiple times for a request than keeping track of whether a previous transmission of the same request already was processed.
a recipient might receive the same non-confirmable message (as indicated by the message id and source endpoint) multiple times within non_lifetime (section 4.8.2).
as a general rule that may be relaxed based on the specific semantics of a message, the recipient should silently ignore any duplicated non-confirmable message and should process any request or response in the message only once.
message size while specific link layers make it beneficial to keep coap messages small enough to fit into their link-layer packets (see section 1), this is a matter of implementation quality.
the coap specification itself provides only an upper bound to the message size.
messages larger than an ip packet result in undesirable packet fragmentation.
a coap message, appropriately encapsulated, should fit within a single ip packet (i.e., avoid ip fragmentation) and (by fitting into one udp payload) obviously needs to fit within a single ip datagram.
if the path mtu is not known for a destination, an ip mtu of 1280 bytes should be assumed; if nothing is known about the size of the headers, good upper bounds are 1152 bytes for the message size and 1024 bytes for the payload size.
implementation note: coap's choice of message size parameters works well with ipv6 and with most of today's ipv4 paths.
(however, with ipv4, it is harder to absolutely ensure that there is no ip fragmentation.
if ipv4 support on unusual networks is a consideration, implementations may want to limit themselves to more conservative ipv4 datagram sizes such as 576 bytes; per [rfc0791], the absolute minimum value of the ip mtu for ipv4 is as low as 68 bytes, which would leave only 40 bytes minus security overhead for a udp payload.
implementations extremely focused on this problem set might also set the ipv4 df bit and perform some form of path mtu discovery [rfc4821]; this should generally be unnecessary in realistic use cases for coap, however.)
a more important kind of fragmentation in many constrained networks is that on the adaptation layer (e.g., 6lowpan l2 packets are limited to 127 bytes including various overheads); this may motivate implementations to be frugal in their packet sizes and to move to block-wise transfers [block] when approaching three-digit message sizes.
message sizes are also of considerable importance to implementations on constrained nodes.
many implementations will need to allocate a buffer for incoming messages.
if an implementation is too constrained to allow for allocating the above-mentioned upper bound, it could apply the following implementation strategy for messages not using dtls security: implementations receiving a datagram into a buffer that is too small are usually able to determine if the trailing portion of a datagram was discarded and to retrieve the initial portion.
so, at least the coap header and options, if not all of the payload, are likely to fit within the buffer.
a server can thus fully interpret a request and return a 4.13 (request entity too large; see section 5.9.2.9) response code if the payload was truncated.
a client sending an idempotent request and receiving a response larger than would fit in the buffer can repeat the request with a suitable value for the block option [block].
congestion control basic congestion control for coap is provided by the exponential back-off mechanism in section 4.2.
in order not to cause congestion, clients (including proxies) must strictly limit the number of simultaneous outstanding interactions that they maintain to a given server (including proxies) to nstart.
an outstanding interaction is either a con for which an ack has not yet been received but is still expected (message layer) or a request for which neither a response nor an acknowledgment message has yet been received but is still expected (which may both occur at the same time, counting as one outstanding interaction).
the default value of nstart for this specification is 1.
further congestion control optimizations and considerations are expected in the future, may for example provide automatic initialization of the coap transmission parameters defined in section 4.8, and thus may allow a value for nstart greater than one.
after exchange_lifetime, a client stops expecting a response to a confirmable request for which no acknowledgment message was received.
the specific algorithm by which a client stops to "expect" a response to a confirmable request that was acknowledged, or to a non- confirmable request, is not defined.
unless this is modified by additional congestion control optimizations, it must be chosen in such a way that an endpoint does not exceed an average data rate of probing_rate in sending to another endpoint that does not respond.
note: coap places the onus of congestion control mostly on the clients.
however, clients may malfunction or actually be attackers, e.g., to perform amplification attacks (section 11.3).
to limit the damage (to the network and to its own energy resources), a server should implement some rate limiting for its response transmission based on reasonable assumptions about application requirements.
this is most helpful if the rate limit can be made effective for the misbehaving endpoints, only.
changing the parameters the values for ack_timeout, ack_random_factor, max_retransmit, nstart, default_leisure (section 8.2), and probing_rate may be configured to values specific to the application environment (including dynamically adjusted values); however, the configuration method is out of scope of this document.
it is recommended that an application environment use consistent values for these parameters; the specific effects of operating with inconsistent values in an application environment are outside the scope of the present specification.
the transmission parameters have been chosen to achieve a behavior in the presence of congestion that is safe in the internet.
if a configuration desires to use different values, the onus is on the configuration to ensure these congestion control properties are not violated.
in particular, a decrease of ack_timeout below 1 second would violate the guidelines of [rfc5405].
([rto-consider] provides some additional background.)
coap was designed to enable implementations that do not maintain round-trip-time (rtt) measurements.
however, where it is desired to decrease the ack_timeout significantly or increase nstart, this can only be done safely when maintaining such measurements.
configurations must not decrease ack_timeout or increase nstart without using mechanisms that ensure congestion control safety, either defined in the configuration or in future standards documents.
ack_random_factor must not be decreased below 1.0, and it should have a value that is sufficiently different from 1.0 to provide some protection from synchronization effects.
max_retransmit can be freely adjusted, but a value that is too small will reduce the probability that a confirmable message is actually received, while a larger value than given here will require further adjustments in the time values (see section 4.8.2).
if the choice of transmission parameters leads to an increase of derived time values (see section 4.8.2), the configuration mechanism must ensure the adjusted value is also available to all the endpoints with which these adjusted values are to be used to communicate.
time values derived from transmission parameters the combination of ack_timeout, ack_random_factor, and max_retransmit influences the timing of retransmissions, which in turn influences how long certain information items need to be kept by an implementation.
to be able to unambiguously reference these derived time values, we give them names as follows: o max_transmit_span is the maximum time from the first transmission of a confirmable message to its last retransmission.
for the default transmission parameters, the value is (2+4+8+16)*1.5 = 45 seconds, or more generally: ack_timeout * ((2 ** max_retransmit) - 1) * ack_random_factor o max_transmit_wait is the maximum time from the first transmission of a confirmable message to the time when the sender gives up on receiving an acknowledgement or reset.
for the default transmission parameters, the value is (2+4+8+16+32)*1.5 = 93 seconds, or more generally: ack_timeout * ((2 ** (max_retransmit + 1)) - 1) * ack_random_factor in addition, some assumptions need to be made on the characteristics of the network and the nodes.
o max_latency is the maximum time a datagram is expected to take from the start of its transmission to the completion of its reception.
this constant is related to the msl (maximum segment lifetime) of [rfc0793], which is "arbitrarily defined to be 2 minutes" ([rfc0793] glossary, page 81).
note that this is not necessarily smaller than max_transmit_wait, as max_latency is not intended to describe a situation when the protocol works well, but the worst-case situation against which the protocol has to guard.
we, also arbitrarily, define max_latency to be 100 seconds.
apart from being reasonably realistic for the bulk of configurations as well as close to the historic choice for tcp, this value also allows message id lifetime timers to be represented in 8 bits (when measured in seconds).
in these calculations, there is no assumption that the direction of the transmission is irrelevant (i.e., that the network is symmetric); there is just the assumption that the same value can reasonably be used as a maximum value for both directions.
if that is not the case, the following calculations become only slightly more complex.
o processing_delay is the time a node takes to turn around a confirmable message into an acknowledgement.
we assume the node will attempt to send an ack before having the sender time out, so as a conservative assumption we set it equal to ack_timeout.
o max_rtt is the maximum round-trip time, or: (2 * max_latency) + processing_delay from these values, we can derive the following values relevant to the protocol operation: o exchange_lifetime is the time from starting to send a confirmable message to the time when an acknowledgement is no longer expected, i.e., message-layer information about the message exchange can be purged.
exchange_lifetime includes a max_transmit_span, a max_latency forward, processing_delay, and a max_latency for the way back.
note that there is no need to consider max_transmit_wait if the configuration is chosen such that the last waiting period (ack_timeout * (2 ** max_retransmit) or the difference between max_transmit_span and max_transmit_wait) is less than max_latency -- which is a likely choice, as max_latency is a worst-case value unlikely to be met in the real world.
in this case, exchange_lifetime simplifies to: max_transmit_span + (2 * max_latency) + processing_delay or 247 seconds with the default transmission parameters.
o non_lifetime is the time from sending a non-confirmable message to the time its message id can be safely reused.
if multiple transmission of a non message is not used, its value is max_latency, or 100 seconds.
however, a coap sender might send a non message multiple times, in particular for multicast applications.
while the period of reuse is not bounded by the specification, an expectation of reliable detection of duplication at the receiver is on the timescales of max_transmit_span.
therefore, for this purpose, it is safer to use the value: max_transmit_span + max_latency or 145 seconds with the default transmission parameters; however, an implementation that just wants to use a single timeout value for retiring message ids can safely use the larger value for exchange_lifetime.
table 3 lists the derived parameters introduced in this subsection with their default values.
request/response semantics coap operates under a similar request/response model as http: a coap endpoint in the role of a "client" sends one or more coap requests to a "server", which services the requests by sending coap responses.
unlike http, requests and responses are not sent over a previously established connection but are exchanged asynchronously over coap messages.
requests a coap request consists of the method to be applied to the resource, the identifier of the resource, a payload and internet media type (if any), and optional metadata about the request.
coap supports the basic methods of get, post, put, and delete, which are easily mapped to http.
they have the same properties of safe (only retrieval) and idempotent (you can invoke it multiple times with the same effects) as http (see sectionÂ 9.1 of [rfc2616]).
the get method is safe; therefore, it must not take any other action on a resource other than retrieval.
the get, put, and delete methods must be performed in such a way that they are idempotent.
post is not idempotent, because its effect is determined by the origin server and dependent on the target resource; it usually results in a new resource being created or the target resource being updated.
a request is initiated by setting the code field in the coap header of a confirmable or a non-confirmable message to a method code and including request information.
the methods used in requests are described in detail in section 5.8.
responses after receiving and interpreting a request, a server responds with a coap response that is matched to the request by means of a client- generated token (section 5.3); note that this is different from the message id that matches a confirmable message to its acknowledgement.
a response is identified by the code field in the coap header being set to a response code.
similar to the http status code, the coap response code indicates the result of the attempt to understand and satisfy the request.
these codes are fully defined in section 5.9.
the response code numbers to be set in the code field of the coap header are maintained in the coap response code registry (section 12.1.2).
the lower five bits do not have any categorization role; they give additional detail to the overall class (figure 9).
as a human-readable notation for specifications and protocol diagnostics, coap code numbers including the response code are documented in the format "c.dd", where "c" is the class in decimal, and "dd" is the detail as a two-digit decimal.
for example, "forbidden" is written as 4.03 -- indicating an 8-bit code value of hexadecimal 0x83 (4*0x20+3) or decimal 131 (4*32+3).
there are 3 classes of response codes: 2 - success: the request was successfully received, understood, and accepted.
4 - client error: the request contains bad syntax or cannot be fulfilled.
5 - server error: the server failed to fulfill an apparently valid request.
the response codes are designed to be extensible: response codes in the client error or server error class that are unrecognized by an endpoint are treated as being equivalent to the generic response code of that class (4.00 and 5.00, respectively).
however, there is no generic response code indicating success, so a response code in the success class that is unrecognized by an endpoint can only be used to determine that the request was successful without any further details.
the possible response codes are described in detail in section 5.9.
responses can be sent in multiple ways, which are defined in the following subsections.
piggybacked in the most basic case, the response is carried directly in the acknowledgement message that acknowledges the request (which requires that the request was carried in a confirmable message).
this is called a "piggybacked response".
the response is returned in the acknowledgement message, independent of whether the response indicates success or failure.
in effect, the response is piggybacked on the acknowledgement message, and no separate message is required to return the response.
implementation note: the protocol leaves the decision whether to piggyback a response or not (i.e., send a separate response) to the server.
the client must be prepared to receive either.
on the quality-of-implementation level, there is a strong expectation that servers will implement code to piggyback whenever possible -- saving resources in the network and both at the client and at the server.
separate it may not be possible to return a piggybacked response in all cases.
for example, a server might need longer to obtain the representation of the resource requested than it can wait to send back the acknowledgement message, without risking the client repeatedly retransmitting the request message (see also the discussion of processing_delay in section 4.8.2).
the response to a request carried in a non-confirmable message is always sent separately (as there is no acknowledgement message).
one way to implement this in a server is to initiate the attempt to obtain the resource representation and, while that is in progress, time out an acknowledgement timer.
a server may also immediately send an acknowledgement if it knows in advance that there will be no piggybacked response.
in both cases, the acknowledgement effectively is a promise that the request will be acted upon later.
when the server finally has obtained the resource representation, it sends the response.
when it is desired that this message is not lost, it is sent as a confirmable message from the server to the client and answered by the client with an acknowledgement, echoing the new message id chosen by the server.
(it may also be sent as a non-confirmable message; see section 5.2.3.)
when the server chooses to use a separate response, it sends the acknowledgement to the confirmable request as an empty message.
once the server sends back an empty acknowledgement, it must not send back the response in another acknowledgement, even if the client retransmits another identical request.
if a retransmitted request is received (perhaps because the original acknowledgement was delayed), another empty acknowledgement is sent, and any response must be sent as a separate response.
if the server then sends a confirmable response, the client's acknowledgement to that response must also be an empty message (one that carries neither a request nor a response).
the server must stop retransmitting its response on any matching acknowledgement (silently ignoring any response code or payload) or reset message.
implementation notes: note that, as the underlying datagram transport may not be sequence-preserving, the confirmable message carrying the response may actually arrive before or after the acknowledgement message for the request; for the purposes of terminating the retransmission sequence, this also serves as an acknowledgement.
note also that, while the coap protocol itself does not make any specific demands here, there is an expectation that the response will come within a time frame that is reasonable from an application point of view.
as there is no underlying transport protocol that could be instructed to run a keep-alive mechanism, the requester may want to set up a timeout that is unrelated to coap's retransmission timers in case the server is destroyed or otherwise unable to send the response.
non-confirmable if the request message is non-confirmable, then the response should be returned in a non-confirmable message as well.
however, an endpoint must be prepared to receive a non-confirmable response (preceded or followed by an empty acknowledgement message) in reply to a confirmable request, or a confirmable response in reply to a non-confirmable request.
request/response matching regardless of how a response is sent, it is matched to the request by means of a token that is included by the client in the request, along with additional address information of the corresponding endpoint.
token the token is used to match a response with a request.
the token value is a sequence of 0 to 8 bytes.
(note that every message carries a token, even if it is of zero length.)
every request carries a client-generated token that the server must echo (without modification) in any resulting response.
a token is intended for use as a client-local identifier for differentiating between concurrent requests (see section 5.3); it could have been called a "request id".
the client should generate tokens in such a way that tokens currently in use for a given source/destination endpoint pair are unique.
(note that a client implementation can use the same token for any request if it uses a different endpoint each time, e.g., a different source port number.)
an empty token value is appropriate e.g., when no other tokens are in use to a destination, or when requests are made serially per destination and receive piggybacked responses.
there are, however, multiple possible implementation strategies to fulfill this.
a client sending a request without using transport layer security (section 9) should use a nontrivial, randomized token to guard against spoofing of responses (section 11.4).
this protective use of tokens is the reason they are allowed to be up to 8 bytes in size.
the actual size of the random component to be used for the token depends on the security requirements of the client and the level of threat posed by spoofing of responses.
a client that is connected to the general internet should use at least 32 bits of randomness, keeping in mind that not being directly connected to the internet is not necessarily sufficient protection against spoofing.
(note that the message id adds little in protection as it is usually sequentially assigned, i.e., guessable, and can be circumvented by spoofing a separate response.)
clients that want to optimize the token length may further want to detect the level of ongoing attacks (e.g., by tallying recent token mismatches in incoming messages) and adjust the token length upwards appropriately.
[rfc4086] discusses randomness requirements for security.
an endpoint receiving a token it did not generate must treat the token as opaque and make no assumptions about its content or structure.
request/response matching rules the exact rules for matching a response to a request are as follows: 1.
the source endpoint of the response must be the same as the destination endpoint of the original request.
in a piggybacked response, the message id of the confirmable request and the acknowledgement must match, and the tokens of the response and original request must match.
in a separate response, just the tokens of the response and original request must match.
in case a message carrying a response is unexpected (the client is not waiting for a response from the identified endpoint, at the endpoint addressed, and/or with the given token), the response is rejected (sections 4.2 and 4.3).
implementation note: a client that receives a response in a con message may want to clean up the message state right after sending the ack.
if that ack is lost and the server retransmits the con, the client may no longer have any state to which to correlate this response, making the retransmission an unexpected message; the client will likely send a reset message so it does not receive any more retransmissions.
this behavior is normal and not an indication of an error.
(clients that are not aggressively optimized in their state memory usage will still have message state that will identify the second con as a retransmission.
clients that actually expect more messages from the server [observe] will have to keep state in any case.)
options both requests and responses may include a list of one or more options.
for example, the uri in a request is transported in several options, and metadata that would be carried in an http header in http is supplied as options as well.
coap defines a single set of options that are used in both requests and responses: o content-format o etag o location-path o location-query o max-age o proxy-uri o proxy-scheme o uri-host o uri-path o uri-port o uri-query o accept o if-match o if-none-match o size1 the semantics of these options along with their properties are defined in detail in section 5.10.
not all options are defined for use with all methods and response codes.
the possible options for methods and response codes are defined in sections 5.8 and 5.9, respectively.
in case an option is not defined for a method or response code, it must not be included by a sender and must be treated like an unrecognized option by a recipient.
critical/elective options fall into one of two classes: "critical" or "elective".
the difference between these is how an option unrecognized by an endpoint is handled: o upon reception, unrecognized options of class "elective" must be silently ignored.
o unrecognized options of class "critical" that occur in a confirmable request must cause the return of a 4.02 (bad option) response.
this response should include a diagnostic payload describing the unrecognized option(s) (see section 5.5.2).
o unrecognized options of class "critical" that occur in a confirmable response, or piggybacked in an acknowledgement, must cause the response to be rejected (section 4.2).
o unrecognized options of class "critical" that occur in a non- confirmable message must cause the message to be rejected (section 4.3).
note that, whether critical or elective, an option is never "mandatory" (it is always optional): these rules are defined in order to enable implementations to stop processing options they do not understand or implement.
critical/elective rules apply to non-proxying endpoints.
a proxy processes options based on unsafe/safe-to-forward classes as defined in section 5.7.
proxy unsafe or safe-to-forward and nocachekey in addition to an option being marked as critical or elective, options are also classified based on how a proxy is to deal with the option if it does not recognize it.
for this purpose, an option can either be considered unsafe to forward (unsafe is set) or safe-to- forward (unsafe is clear).
in addition, for an option that is marked safe-to-forward, the option number indicates whether or not it is intended to be part of the cache-key (section 5.6) in a request.
if some of the nocachekey bits are 0, it is; if all nocachekey bits are 1, it is not (see section 5.4.6).
note: the cache-key indication is relevant only for proxies that do not implement the given option as a request option and instead rely on the unsafe/safe-to-forward indication only.
for example, for etag, actually using the request option as a part of the cache-key is grossly inefficient, but it is the best thing one can do if etag is not implemented by a proxy, as the response is going to differ based on the presence of the request option.
a more useful proxy that does implement the etag request option is not using etag as a part of the cache-key.
nocachekey is indicated in three bits so that only one out of eight codepoints is qualified as nocachekey, leaving seven out of eight codepoints for what appears to be the more likely case.
proxy behavior with regard to these classes is defined in section 5.7.
length option values are defined to have a specific length, often in the form of an upper and lower bound.
if the length of an option value in a request is outside the defined range, that option must be treated like an unrecognized option (see section 5.4.1).
default values options may be defined to have a default value.
if the value of an option is intended to be this default value, the option should not be included in the message.
if the option is not present, the default value must be assumed.
where a critical option has a default value, this is chosen in such a way that the absence of the option in a message can be processed properly both by implementations unaware of the critical option and by implementations that interpret this absence as the presence of the default value for the option.
repeatable options the definition of some options specifies that those options are repeatable.
an option that is repeatable may be included one or more times in a message.
an option that is not repeatable must not be included more than once in a message.
if a message includes an option with more occurrences than the option is defined for, each supernumerary option occurrence that appears subsequently in the message must be treated like an unrecognized option (see section 5.4.1).
option numbers an option is identified by an option number, which also provides some additional semantics information, e.g., odd numbers indicate a critical option, while even numbers indicate an elective option.
note that this is not just a convention, it is a feature of the protocol: whether an option is elective or critical is entirely determined by whether its option number is even or odd.
more generally speaking, an option number is constructed with a bit mask to indicate if an option is critical or elective, unsafe or safe-to-forward, and, in the case of safe-to-forward, to provide a cache-key indication as shown by the following figure.
in the following text, the bit mask is expressed as a single byte that is applied to the least significant byte of the option number in unsigned integer representation.
when bit 7 (the least significant bit) is 1, an option is critical (and likewise elective when 0).
when bit 6 is 1, an option is unsafe (and likewise safe-to-forward when 0).
when bit 6 is 0, i.e., the option is not unsafe, it is not a cache-key (nocachekey) if and only if bits 3-5 are all set to 1; all other bit combinations mean that it indeed is a cache-key.
these classes of options are explained in the next sections.
an endpoint may use an equivalent of the c code in figure 11 to derive the characteristics of an option number "onum".
payloads and representations both requests and responses may include a payload, depending on the method or response code, respectively.
if a method or response code is not defined to have a payload, then a sender must not include one, and a recipient must ignore it.
representation the payload of requests or of responses indicating success is typically a representation of a resource ("resource representation") or the result of the requested action ("action result").
its format is specified by the internet media type and content coding given by the content-format option.
in the absence of this option, no default value is assumed, and the format will need to be inferred by the application (e.g., from the application context).
payload "sniffing" should only be attempted if no content type is given.
implementation note: on a quality-of-implementation level, there is a strong expectation that a content-format indication will be provided with resource representations whenever possible.
this is not a "should" level requirement solely because it is not a protocol requirement, and it also would be difficult to outline exactly in what cases this expectation can be violated.
for responses indicating a client or server error, the payload is considered a representation of the result of the requested action only if a content-format option is given.
in the absence of this option, the payload is a diagnostic payload (section 5.5.2).
diagnostic payload if no content-format option is given, the payload of responses indicating a client or server error is a brief human-readable diagnostic message, explaining the error situation.
this diagnostic message must be encoded using utf-8 [rfc3629], more specifically using net-unicode form [rfc5198].
the message is similar to the reason-phrase on an http status line.
it is not intended for end users but for software engineers that during debugging need to interpret it in the context of the present, english-language specification; therefore, no mechanism for language tagging is needed or provided.
in contrast to what is usual in http, the payload should be empty if there is no additional information beyond the response code.
selected representation not all responses carry a payload that provides a representation of the resource addressed by the request.
it is, however, sometimes useful to be able to refer to such a representation in relation to a response, independent of whether it actually was enclosed.
we use the term "selected representation" to refer to the current representation of a target resource that would have been selected in a successful response if the corresponding request had used the method get and excluded any conditional request options (section 5.10.8).
certain response options provide metadata about the selected representation, which might differ from the representation included in the message for responses to some state-changing methods.
of the response options defined in this specification, only the etag response option (section 5.10.6) is defined as metadata about the selected representation.
content negotiation a server may be able to supply a representation for a resource in one of multiple representation formats.
without further information from the client, it will provide the representation in the format it prefers.
by using the accept option (section 5.10.4) in a request, the client can indicate which content-format it prefers to receive.
caching coap endpoints may cache responses in order to reduce the response time and network bandwidth consumption on future, equivalent requests.
the goal of caching in coap is to reuse a prior response message to satisfy a current request.
in some cases, a stored response can be reused without the need for a network request, reducing latency and network round-trips; a "freshness" mechanism is used for this purpose (see section 5.6.1).
even when a new request is required, it is often possible to reuse the payload of a prior response to satisfy the request, thereby reducing network bandwidth usage; a "validation" mechanism is used for this purpose (see section 5.6.2).
unlike http, the cacheability of coap responses does not depend on the request method, but it depends on the response code.
the cacheability of each response code is defined along the response code definitions in section 5.9.
response codes that indicate success and are unrecognized by an endpoint must not be cached.
for a presented request, a coap endpoint must not use a stored response, unless: o the presented request method and that used to obtain the stored response match, o all options match between those in the presented request and those of the request used to obtain the stored response (which includes the request uri), except that there is no need for a match of any request options marked as nocachekey (section 5.4) or recognized by the cache and fully interpreted with respect to its specified cache behavior (such as the etag request option described in section 5.10.6; see also section 5.4.2), and o the stored response is either fresh or successfully validated as defined below.
the set of request options that is used for matching the cache entry is also collectively referred to as the "cache-key".
for uri schemes other than coap and coaps, matching of those options that constitute the request uri may be performed under rules specific to the uri scheme.
freshness model when a response is "fresh" in the cache, it can be used to satisfy subsequent requests without contacting the origin server, thereby improving efficiency.
the mechanism for determining freshness is for an origin server to provide an explicit expiration time in the future, using the max-age option (see section 5.10.5).
the max-age option indicates that the response is to be considered not fresh after its age is greater than the specified number of seconds.
the max-age option defaults to a value of 60.
thus, if it is not present in a cacheable response, then the response is considered not fresh after its age is greater than 60 seconds.
if an origin server wishes to prevent caching, it must explicitly include a max-age option with a value of zero seconds.
if a client has a fresh stored response and makes a new request matching the request for that stored response, the new response invalidates the old response.
validation model when an endpoint has one or more stored responses for a get request, but cannot use any of them (e.g., because they are not fresh), it can use the etag option (section 5.10.6) in the get request to give the origin server an opportunity both to select a stored response to be used, and to update its freshness.
this process is known as "validating" or "revalidating" the stored response.
when sending such a request, the endpoint should add an etag option specifying the entity-tag of each stored response that is applicable.
a 2.03 (valid) response indicates the stored response identified by the entity-tag given in the response's etag option can be reused after updating it as described in section 5.9.1.3.
any other response code indicates that none of the stored responses nominated in the request is suitable.
instead, the response should be used to satisfy the request and may replace the stored response.
proxying a proxy is a coap endpoint that can be tasked by coap clients to perform requests on their behalf.
this may be useful, for example, when the request could otherwise not be made, or to service the response from a cache in order to reduce response time and network bandwidth or energy consumption.
in an overall architecture for a constrained restful environment, proxies can serve quite different purposes.
proxies can be explicitly selected by clients, a role that we term "forward-proxy".
proxies can also be inserted to stand in for origin servers, a role that we term "reverse-proxy".
orthogonal to this distinction, a proxy can map from a coap request to a coap request (coap-to-coap proxy) or translate from or to a different protocol ("cross-proxy").
full definitions of these terms are provided in section 1.2.
notes: the terminology in this specification has been selected to be culturally compatible with the terminology used in the wider web application environments, without necessarily matching it in every detail (which may not even be relevant to constrained restful environments).
not too much semantics should be ascribed to the components of the terms (such as "forward", "reverse", or "cross").
http proxies, besides acting as http proxies, often offer a transport-protocol proxying function ("connect") to enable end-to- end transport layer security through the proxy.
no such function is defined for coap-to-coap proxies in this specification, as forwarding of udp packets is unlikely to be of much value in constrained restful environments.
see also section 10.2.7 for the cross-proxy case.
when a client uses a proxy to make a request that will use a secure uri scheme (e.g., "coaps" or "https"), the request towards the proxy should be sent using dtls except where equivalent lower-layer security is used for the leg between the client and the proxy.
proxy operation a proxy generally needs a way to determine potential request parameters for a request it places to a destination, based on the request it received from its client.
this way is fully specified for a forward-proxy but may depend on the specific configuration for a reverse-proxy.
in particular, the client of a reverse-proxy generally does not indicate a locator for the destination, necessitating some form of namespace translation in the reverse- proxy.
however, some aspects of the operation of proxies are common to all its forms.
if a proxy does not employ a cache, then it simply forwards the translated request to the determined destination.
otherwise, if it does employ a cache but does not have a stored response that matches the translated request and is considered fresh, then it needs to refresh its cache according to section 5.6.
for options in the request that the proxy recognizes, it knows whether the option is intended to act as part of the key used in looking up the cached value or not.
for example, since requests for different uri-path values address different resources, uri-path values are always part of the cache-key, while, e.g., token values are never part of the cache-key.
for options that the proxy does not recognize but that are marked safe-to-forward in the option number, the option also indicates whether it is to be included in the cache-key (nocachekey is not all set) or not (nocachekey is all set).
(options that are unrecognized and marked unsafe lead to 4.02 bad option.)
if the request to the destination times out, then a 5.04 (gateway timeout) response must be returned.
if the request to the destination returns a response that cannot be processed by the proxy (e.g, due to unrecognized critical options or message format errors), then a 5.02 (bad gateway) response must be returned.
otherwise, the proxy returns the response to the client.
if a response is generated out of a cache, the generated (or implied) max-age option must not extend the max-age originally set by the server, considering the time the resource representation spent in the cache.
for example, the max-age option could be adjusted by the proxy for each response using the formula: proxy-max-age = original-max-age - cache-age for example, if a request is made to a proxied resource that was refreshed 20 seconds ago and had an original max-age of 60 seconds, then that resource's proxied max-age is now 40 seconds.
considering potential network delays on the way from the origin server, a proxy should be conservative in the max-age values offered.
all options present in a proxy request must be processed at the proxy.
unsafe options in a request that are not recognized by the proxy must lead to a 4.02 (bad option) response being returned by the proxy.
a coap-to-coap proxy must forward to the origin server all safe-to-forward options that it does not recognize.
similarly, unsafe options in a response that are not recognized by the coap-to- coap proxy server must lead to a 5.02 (bad gateway) response.
again, safe-to-forward options that are not recognized must be forwarded.
additional considerations for cross-protocol proxying between coap and http are discussed in section 10.
forward-proxies coap distinguishes between requests made (as if) to an origin server and requests made through a forward-proxy.
coap requests to a forward-proxy are made as normal confirmable or non-confirmable requests to the forward-proxy endpoint, but they specify the request uri in a different way: the request uri in a proxy request is specified as a string in the proxy-uri option (see section 5.10.2), while the request uri in a request to an origin server is split into the uri-host, uri-port, uri-path, and uri-query options (see section 5.10.1).
alternatively, the uri in a proxy request can be assembled from a proxy-scheme option and the split options mentioned.
when a proxy request is made to an endpoint and the endpoint is unwilling or unable to act as proxy for the request uri, it must return a 5.05 (proxying not supported) response.
if the authority (host and port) is recognized as identifying the proxy endpoint itself (see section 5.10.2), then the request must be treated as a local (non-proxied) request.
unless a proxy is configured to forward the proxy request to another proxy, it must translate the request as follows: the scheme of the request uri defines the outgoing protocol and its details (e.g., coap is used over udp for the "coap" scheme and over dtls for the "coaps" scheme.)
for a coap-to-coap proxy, the origin server's ip address and port are determined by the authority component of the request uri, and the request uri is decoded and split into the uri-host, uri- port, uri-path and uri-query options.
this consumes the proxy-uri or proxy-scheme option, which is therefore not forwarded to the origin server.
reverse-proxies reverse-proxies do not make use of the proxy-uri or proxy-scheme options but need to determine the destination (next hop) of a request from information in the request and information in their configuration.
for example, a reverse-proxy might offer various resources as if they were its own resources, after having learned of their existence through resource discovery.
the reverse-proxy is free to build a namespace for the uris that identify these resources.
a reverse-proxy may also build a namespace that gives the client more control over where the request goes, e.g., by embedding host identifiers and port numbers into the uri path of the resources offered.
in processing the response, a reverse-proxy has to be careful that etag option values from different sources are not mixed up on one resource offered to its clients.
in many cases, the etag can be forwarded unchanged.
if the mapping from a resource offered by the reverse-proxy to resources offered by its various origin servers is not unique, the reverse-proxy may need to generate a new etag, making sure the semantics of this option are properly preserved.
method definitions in this section, each method is defined along with its behavior.
a request with an unrecognized or unsupported method code must generate a 4.05 (method not allowed) piggybacked response.
get the get method retrieves a representation for the information that currently corresponds to the resource identified by the request uri.
if the request includes an accept option, that indicates the preferred content-format of a response.
if the request includes an etag option, the get method requests that etag be validated and that the representation be transferred only if validation failed.
upon success, a 2.05 (content) or 2.03 (valid) response code should be present in the response.
the get method is safe and idempotent.
post the post method requests that the representation enclosed in the request be processed.
the actual function performed by the post method is determined by the origin server and dependent on the target resource.
it usually results in a new resource being created or the target resource being updated.
if a resource has been created on the server, the response returned by the server should have a 2.01 (created) response code and should include the uri of the new resource in a sequence of one or more location-path and/or location-query options (section 5.10.7).
if the post succeeds but does not result in a new resource being created on the server, the response should have a 2.04 (changed) response code.
if the post succeeds and results in the target resource being deleted, the response should have a 2.02 (deleted) response code.
post is neither safe nor idempotent.
put the put method requests that the resource identified by the request uri be updated or created with the enclosed representation.
the representation format is specified by the media type and content coding given in the content-format option, if provided.
if a resource exists at the request uri, the enclosed representation should be considered a modified version of that resource, and a 2.04 (changed) response code should be returned.
if no resource exists, then the server may create a new resource with that uri, resulting in a 2.01 (created) response code.
if the resource could not be created or modified, then an appropriate error response code should be sent.
further restrictions to a put can be made by including the if-match (see section 5.10.8.1) or if-none-match (see section 5.10.8.2) options in the request.
put is not safe but is idempotent.
delete the delete method requests that the resource identified by the request uri be deleted.
a 2.02 (deleted) response code should be used on success or in case the resource did not exist before the request.
delete is not safe but is idempotent.
response code definitions each response code is described below, including any options required in the response.
where appropriate, some of the codes will be specified in regards to related response codes in http [rfc2616]; this does not mean that any such relationship modifies the http mapping specified in section 10.
success 2.xx this class of response code indicates that the clients request was successfully received, understood, and accepted.
2.01 created like http 201 "created", but only used in response to post and put requests.
the payload returned with the response, if any, is a representation of the action result.
if the response includes one or more location-path and/or location- query options, the values of these options specify the location at which the resource was created.
otherwise, the resource was created at the request uri.
a cache receiving this response must mark any stored response for the created resource as not fresh.
this response is not cacheable.
2.02 deleted this response code is like http 204 "no content" but only used in response to requests that cause the resource to cease being available, such as delete and, in certain circumstances, post.
the payload returned with the response, if any, is a representation of the action result.
this response is not cacheable.
however, a cache must mark any stored response for the deleted resource as not fresh.
2.03 valid this response code is related to http 304 "not modified" but only used to indicate that the response identified by the entity-tag identified by the included etag option is valid.
accordingly, the response must include an etag option and must not include a payload.
when a cache that recognizes and processes the etag response option receives a 2.03 (valid) response, it must update the stored response with the value of the max-age option included in the response (explicitly, or implicitly as a default value; see also section 5.6.2).
for each type of safe-to-forward option present in the response, the (possibly empty) set of options of this type that are present in the stored response must be replaced with the set of options of this type in the response received.
(unsafe options may trigger similar option-specific processing as defined by the option.)
2.04 changed this response code is like http 204 "no content" but only used in response to post and put requests.
the payload returned with the response, if any, is a representation of the action result.
this response is not cacheable.
however, a cache must mark any stored response for the changed resource as not fresh.
2.05 content this response code is like http 200 "ok" but only used in response to get requests.
the payload returned with the response is a representation of the target resource.
this response is cacheable: caches can use the max-age option to determine freshness (see section 5.6.1) and (if present) the etag option for validation (see section 5.6.2).
client error 4.xx this class of response code is intended for cases in which the client seems to have erred.
these response codes are applicable to any request method.
the server should include a diagnostic payload under the conditions detailed in section 5.5.2.
responses of this class are cacheable: caches can use the max-age option to determine freshness (see section 5.6.1).
they cannot be validated.
4.00 bad request this response code is like http 400 "bad request".
4.01 unauthorized the client is not authorized to perform the requested action.
the client should not repeat the request without first improving its authentication status to the server.
which specific mechanism can be used for this is outside this document's scope; see also section 9.
4.02 bad option the request could not be understood by the server due to one or more unrecognized or malformed options.
the client should not repeat the request without modification.
4.03 forbidden this response code is like http 403 "forbidden".
4.04 not found this response code is like http 404 "not found".
4.05 method not allowed this response code is like http 405 "method not allowed" but with no parallel to the "allow" header field.
4.06 not acceptable this response code is like http 406 "not acceptable", but with no response entity.
4.12 precondition failed this response code is like http 412 "precondition failed".
4.13 request entity too large this response code is like http 413 "request entity too large".
the response should include a size1 option (section 5.10.9) to indicate the maximum size of request entity the server is able and willing to handle, unless the server is not in a position to make this information available.
4.15 unsupported content-format this response code is like http 415 "unsupported media type".
server error 5.xx this class of response code indicates cases in which the server is aware that it has erred or is incapable of performing the request.
these response codes are applicable to any request method.
the server should include a diagnostic payload under the conditions detailed in section 5.5.2.
responses of this class are cacheable: caches can use the max-age option to determine freshness (see section 5.6.1).
they cannot be validated.
5.00 internal server error this response code is like http 500 "internal server error".
5.01 not implemented this response code is like http 501 "not implemented".
5.02 bad gateway this response code is like http 502 "bad gateway".
5.03 service unavailable this response code is like http 503 "service unavailable" but uses the max-age option in place of the "retry-after" header field to indicate the number of seconds after which to retry.
5.04 gateway timeout this response code is like http 504 "gateway timeout".
5.05 proxying not supported the server is unable or unwilling to act as a forward-proxy for the uri specified in the proxy-uri option or using proxy-scheme (see section 5.10.2).
option definitions the individual coap options are summarized in table 4 and explained in the subsections of this section.
in this table, the c, u, and n columns indicate the properties critical, unsafe, and nocachekey, respectively.
since nocachekey only has a meaning for options that are safe-to-forward (not marked unsafe), the column is filled with a dash for unsafe options.
uri-host, uri-port, uri-path, and uri-query the uri-host, uri-port, uri-path, and uri-query options are used to specify the target resource of a request to a coap origin server.
the options encode the different components of the request uri in a way that no percent-encoding is visible in the option values and that the full uri can be reconstructed at any involved endpoint.
the syntax of coap uris is defined in section 6.
the steps for parsing uris into options is defined in section 6.4.
these steps result in zero or more uri-host, uri-port, uri-path, and uri-query options being included in a request, where each option holds the following values: o the uri-host option specifies the internet host of the resource being requested, o the uri-port option specifies the transport-layer port number of the resource, o each uri-path option specifies one segment of the absolute path to the resource, and o each uri-query option specifies one argument parameterizing the resource.
note: fragments ([rfc3986], sectionÂ 3.5) are not part of the request uri and thus will not be transmitted in a coap request.
the default value of the uri-host option is the ip literal representing the destination ip address of the request message.
likewise, the default value of the uri-port option is the destination udp port.
the default values for the uri-host and uri-port options are sufficient for requests to most servers.
explicit uri-host and uri-port options are typically used when an endpoint hosts multiple virtual servers.
the uri-path and uri-query option can contain any character sequence.
no percent-encoding is performed.
the value of a uri-path option must not be "."
or ".." (as the request uri must be resolved before parsing it into options).
the steps for constructing the request uri from the options are defined in section 6.5.
note that an implementation does not necessarily have to construct the uri; it can simply look up the target resource by examining the individual options.
examples can be found in appendix b.
proxy-uri and proxy-scheme the proxy-uri option is used to make a request to a forward-proxy (see section 5.7).
the forward-proxy is requested to forward the request or service it from a valid cache and return the response.
the option value is an absolute-uri ([rfc3986], sectionÂ 4.3).
note that the forward-proxy may forward the request on to another proxy or directly to the server specified by the absolute-uri.
in order to avoid request loops, a proxy must be able to recognize all of its server names, including any aliases, local variations, and the numeric ip addresses.
an endpoint receiving a request with a proxy-uri option that is unable or unwilling to act as a forward-proxy for the request must cause the return of a 5.05 (proxying not supported) response.
the proxy-uri option must take precedence over any of the uri-host, uri-port, uri-path or uri-query options (each of which must not be included in a request containing the proxy-uri option).
as a special case to simplify many proxy clients, the absolute-uri can be constructed from the uri-* options.
when a proxy-scheme option is present, the absolute-uri is constructed as follows: a coap uri is constructed from the uri-* options as defined in section 6.5.
in the resulting uri, the initial scheme up to, but not including, the following colon is then replaced by the content of the proxy- scheme option.
note that this case is only applicable if the components of the desired uri other than the scheme component actually can be expressed using uri-* options; for example, to represent a uri with a userinfo component in the authority, only proxy-uri can be used.
content-format the content-format option indicates the representation format of the message payload.
the representation format is given as a numeric content-format identifier that is defined in the "coap content- formats" registry (section 12.3).
in the absence of the option, no default value is assumed, i.e., the representation format of any representation message payload is indeterminate (section 5.5).
accept the coap accept option can be used to indicate which content-format is acceptable to the client.
the representation format is given as a numeric content-format identifier that is defined in the "coap content-formats" registry (section 12.3).
if no accept option is given, the client does not express a preference (thus no default value is assumed).
the client prefers the representation returned by the server to be in the content-format indicated.
the server returns the preferred content-format if available.
if the preferred content- format cannot be returned, then a 4.06 "not acceptable" must be sent as a response, unless another error code takes precedence for this response.
max-age the max-age option indicates the maximum time a response may be cached before it is considered not fresh (see section 5.6.1).
the option value is an integer number of seconds between 0 and 2**32-1 inclusive (about 136.1 years).
a default value of 60 seconds is assumed in the absence of the option in a response.
the value is intended to be current at the time of transmission.
servers that provide resources with strict tolerances on the value of max-age should update the value before each retransmission.
(see also section 5.7.1.)
etag an entity-tag is intended for use as a resource-local identifier for differentiating between representations of the same resource that vary over time.
it is generated by the server providing the resource, which may generate it in any number of ways including a version, checksum, hash, or time.
an endpoint receiving an entity- tag must treat it as opaque and make no assumptions about its content or structure.
(endpoints that generate an entity-tag are encouraged to use the most compact representation possible, in particular in regards to clients and intermediaries that may want to store multiple etag values.)
etag as a response option the etag option in a response provides the current value (i.e., after the request was processed) of the entity-tag for the "tagged representation".
if no location-* options are present, the tagged representation is the selected representation (section 5.5.3) of the target resource.
if one or more location-* options are present and thus a location uri is indicated (section 5.10.7), the tagged representation is the representation that would be retrieved by a get request to the location uri.
an etag response option can be included with any response for which there is a tagged representation (e.g., it would not be meaningful in a 4.04 or 4.00 response).
the etag option must not occur more than once in a response.
there is no default value for the etag option; if it is not present in a response, the server makes no statement about the entity-tag for the tagged representation.
etag as a request option in a get request, an endpoint that has one or more representations previously obtained from the resource, and has obtained etag response options with these, can specify an instance of the etag option for one or more of these stored responses.
a server can issue a 2.03 valid response (section 5.9.1.3) in place of a 2.05 content response if one of the etags given is the entity- tag for the current representation, i.e., is valid; the 2.03 valid response then echoes this specific etag in a response option.
in effect, a client can determine if any of the stored representations is current (see section 5.6.2) without needing to transfer them again.
the etag option may occur zero, one, or multiple times in a request.
location-path and location-query the location-path and location-query options together indicate a relative uri that consists either of an absolute path, a query string, or both.
a combination of these options is included in a 2.01 (created) response to indicate the location of the resource created as the result of a post request (see section 5.8.2).
the location is resolved relative to the request uri.
if a response with one or more location-path and/or location-query options passes through a cache that interprets these options and the implied uri identifies one or more currently stored responses, those entries must be marked as not fresh.
each location-path option specifies one segment of the absolute path to the resource, and each location-query option specifies one argument parameterizing the resource.
the location-path and location-query option can contain any character sequence.
no percent-encoding is performed.
the value of a location-path option must not be "."
or "..".
the steps for constructing the location uri from the options are analogous to section 6.5, except that the first five steps are skipped and the result is a relative uri-reference, which is then interpreted relative to the request uri.
note that the relative uri- reference constructed this way always includes an absolute path (e.g., leaving out location-path but supplying location-query means the path component in the uri is "/").
the options that are used to compute the relative uri-reference are collectively called location-* options.
beyond location-path and location-query, more location-* options may be defined in the future and have been reserved option numbers 128, 132, 136, and 140.
if any of these reserved option numbers occurs in addition to location-path and/or location-query and are not supported, then a 4.02 (bad option) error must be returned.
conditional request options conditional request options enable a client to ask the server to perform the request only if certain conditions specified by the option are fulfilled.
for each of these options, if the condition given is not fulfilled, then the server must not perform the requested method.
instead, the server must respond with the 4.12 (precondition failed) response code.
if the condition is fulfilled, the server performs the request method as if the conditional request options were not present.
if the request would, without the conditional request options, result in anything other than a 2.xx or 4.12 response code, then any conditional request options may be ignored.
if-match the if-match option may be used to make a request conditional on the current existence or value of an etag for one or more representations of the target resource.
if-match is generally useful for resource update requests, such as put requests, as a means for protecting against accidental overwrites when multiple clients are acting in parallel on the same resource (i.e., the "lost update" problem).
the value of an if-match option is either an etag or the empty string.
an if-match option with an etag matches a representation with that exact etag.
an if-match option with an empty value matches any existing representation (i.e., it places the precondition on the existence of any current representation for the target resource).
the if-match option can occur multiple times.
if any of the options match, then the condition is fulfilled.
if there is one or more if-match options, but none of the options match, then the condition is not fulfilled.
if-none-match the if-none-match option may be used to make a request conditional on the nonexistence of the target resource.
if-none-match is useful for resource creation requests, such as put requests, as a means for protecting against accidental overwrites when multiple clients are acting in parallel on the same resource.
the if-none-match option carries no value.
if the target resource does exist, then the condition is not fulfilled.
(it is not very useful to combine if-match and if-none-match options in one request, because the condition will then never be fulfilled.)
size1 option the size1 option provides size information about the resource representation in a request.
the option value is an integer number of bytes.
its main use is with block-wise transfers [block].
in the present specification, it is used in 4.13 responses (section 5.9.2.9) to indicate the maximum size of request entity that the server is able and willing to handle.
coap uris coap uses the "coap" and "coaps" uri schemes for identifying coap resources and providing a means of locating the resource.
resources are organized hierarchically and governed by a potential coap origin server listening for coap requests ("coap") or dtls-secured coap requests ("coaps") on a given udp port.
the coap server is identified via the generic syntax's authority component, which includes a host component and optional udp port number.
the remainder of the uri is considered to be identifying a resource that can be operated on by the methods defined by the coap protocol.
the "coap" and "coaps" uri schemes can thus be compared to the "http" and "https" uri schemes, respectively.
the syntax of the "coap" and "coaps" uri schemes is specified in this section in augmented backus-naur form (abnf) [rfc5234].
the definitions of "host", "port", "path-abempty", "query", "segment", "ip-literal", "ipv4address", and "reg-name" are adopted from [rfc3986].
implementation note: unfortunately, over time, the uri format has acquired significant complexity.
implementers are encouraged to examine [rfc3986] closely.
for example, the abnf for ipv6 addresses is more complicated than maybe expected.
also, implementers should take care to perform the processing of percent-decoding or percent-encoding exactly once on the way from a uri to its decoded components or back.
percent-encoding is crucial for data transparency but may lead to unusual results such as a slash character in a path component.
6.1. coap uri scheme coap-uri = "coap:" "//" host [ ":" port ] path-abempty [ "?"
query ] if the host component is provided as an ip-literal or ipv4address, then the coap server can be reached at that ip address.
if host is a registered name, then that name is considered an indirect identifier and the endpoint might use a name resolution service, such as dns, to find the address of that host.
the host must not be empty; if a uri is received with a missing authority or an empty host, then it must be considered invalid.
the port subcomponent indicates the udp port at which the coap server is located.
if it is empty or not given, then the default port 5683 is assumed.
the path identifies a resource within the scope of the host and port.
it consists of a sequence of path segments separated by a slash character (u+002f solidus "/").
the query serves to further parameterize the resource.
it consists of a sequence of arguments separated by an ampersand character (u+0026 ampersand "&").
an argument is often in the form of a "key=value" pair.
the "coap" uri scheme supports the path prefix "/.well-known/" defined by [rfc5785] for "well-known locations" in the namespace of a host.
this enables discovery of policy or other information about a host ("site-wide metadata"), such as hosted resources (see section 7).
application designers are encouraged to make use of short but descriptive uris.
as the environments that coap is used in are usually constrained for bandwidth and energy, the trade-off between these two qualities should lean towards the shortness, without ignoring descriptiveness.
6.2. coaps uri scheme coaps-uri = "coaps:" "//" host [ ":" port ] path-abempty [ "?"
query ] all of the requirements listed above for the "coap" scheme are also requirements for the "coaps" scheme, except that a default udp port of 5684 is assumed if the port subcomponent is empty or not given, and the udp datagrams must be secured through the use of dtls as described in section 9.1.
considerations for caching of responses to "coaps" identified requests are discussed in section 11.2.
resources made available via the "coaps" scheme have no shared identity with the "coap" scheme even if their resource identifiers indicate the same authority (the same host listening to the same udp port).
they are distinct namespaces and are considered to be distinct origin servers.
normalization and comparison rules since the "coap" and "coaps" schemes conform to the uri generic syntax, such uris are normalized and compared according to the algorithm defined in [rfc3986], sectionÂ 6, using the defaults described above for each scheme.
if the port is equal to the default port for a scheme, the normal form is to elide the port subcomponent.
likewise, an empty path component is equivalent to an absolute path of "/", so the normal form is to provide a path of "/" instead.
the scheme and host are case insensitive and normally provided in lowercase; ip-literals are in recommended form [rfc5952]; all other components are compared in a case-sensitive manner.
characters other than those in the "reserved" set are equivalent to their percent-encoded bytes (see [rfc3986], sectionÂ 2.1): the normal form is to not encode them.
for example, the following three uris are equivalent and cause the same options and option values to appear in the coap messages: coap://example.com:5683/~sensors/temp.xml coap://example.com/%7esensors/temp.xml coap://example.com:/%7esensors/temp.xml6.4.
decomposing uris into options the steps to parse a request's options from a string |url| are as follows.
these steps either result in zero or more of the uri-host, uri-port, uri-path, and uri-query options being included in the request or they fail.
if the |url| string is not an absolute uri ([rfc3986]), then fail this algorithm.
resolve the |url| string using the process of reference resolution defined by [rfc3986].
at this stage, the url is in ascii encoding [rfc0020], even though the decoded components will be interpreted in utf-8 [rfc3629] after steps 5, 8, and 9.
note: it doesn't matter what it is resolved relative to, since we already know it is an absolute url at this point.
if |url| does not have a <scheme> component whose value, when converted to ascii lowercase, is "coap" or "coaps", then fail this algorithm.
if |url| has a <fragment> component, then fail this algorithm.
if the <host> component of |url| does not represent the request's destination ip address as an ip-literal or ipv4address, include a uri-host option and let that option's value be the value of the <host> component of |url|, converted to ascii lowercase, and then convert all percent-encodings ("%" followed by two hexadecimal digits) to the corresponding characters.
note: in the usual case where the request's destination ip address is derived from the host part, this ensures that a uri- host option is only used for a <host> component of the form reg- name.
if |url| has a <port> component, then let |port| be that component's value interpreted as a decimal integer; otherwise, let |port| be the default port for the scheme.
if |port| does not equal the request's destination udp port, include a uri-port option and let that option's value be |port|.
if the value of the <path> component of |url| is empty or consists of a single slash character (u+002f solidus "/"), then move to the next step.
otherwise, for each segment in the <path> component, include a uri-path option and let that option's value be the segment (not including the delimiting slash characters) after converting each percent-encoding ("%" followed by two hexadecimal digits) to the corresponding byte.
if |url| has a <query> component, then, for each argument in the <query> component, include a uri-query option and let that option's value be the argument (not including the question mark and the delimiting ampersand characters) after converting each percent-encoding to the corresponding byte.
note that these rules completely resolve any percent-encoding.
composing uris from options the steps to construct a uri from a request's options are as follows.
these steps either result in a uri or they fail.
in these steps, percent-encoding a character means replacing each of its (utf-8-encoded) bytes by a "%" character followed by two hexadecimal digits representing the byte, where the digits a-f are in uppercase (as defined in sectionÂ 2.1 of [rfc3986]; to reduce variability, the hexadecimal notation for percent-encoding in coap uris must use uppercase letters).
the definitions of "unreserved" and "sub-delims" are adopted from [rfc3986].
if the request is secured using dtls, let |url| be the string "coaps://".
otherwise, let |url| be the string "coap://".
if the request includes a uri-host option, let |host| be that option's value, where any non-ascii characters are replaced by their corresponding percent-encoding.
if |host| is not a valid reg-name or ip-literal or ipv4address, fail the algorithm.
if the request does not include a uri-host option, let |host| be the ip-literal (making use of the conventions of [rfc5952]) or ipv4address representing the request's destination ip address.
append |host| to |url|.
if the request includes a uri-port option, let |port| be that option's value.
otherwise, let |port| be the request's destination udp port.
if |port| is not the default port for the scheme, then append a single u+003a colon character (:) followed by the decimal representation of |port| to |url|.
let |resource name| be the empty string.
for each uri-path option in the request, append a single character u+002f solidus (/) followed by the option's value to |resource name|, after converting any character that is not either in the "unreserved" set, in the "sub-delims" set, a u+003a colon (:) character, or a u+0040 commercial at (@) character to its percent-encoded form.
if |resource name| is the empty string, set it to a single character u+002f solidus (/).
for each uri-query option in the request, append a single character u+003f question mark (?)
(first option) or u+0026 ampersand (&) (subsequent options) followed by the option's value to |resource name|, after converting any character that is not either in the "unreserved" set, in the "sub-delims" set (except u+0026 ampersand (&)), a u+003a colon (:), a u+0040 commercial at (@), a u+002f solidus (/), or a u+003f question mark (?)
character to its percent-encoded form.
append |resource name| to |url|.
return |url|.
note that these steps have been designed to lead to a uri in normal form (see section 6.3).
discovery7.1.
service discovery as a part of discovering the services offered by a coap server, a client has to learn about the endpoint used by a server.
a server is discovered by a client (knowing or) learning a uri that references a resource in the namespace of the server.
alternatively, clients can use multicast coap (see section 8) and the "all coap nodes" multicast address to find coap servers.
unless the port subcomponent in a "coap" or "coaps" uri indicates the udp port at which the coap server is located, the server is assumed to be reachable at the default port.
the coap default port number 5683 must be supported by a server that offers resources for resource discovery (see section 7.2 below) and should be supported for providing access to other resources.
the default port number 5684 for dtls-secured coap may be supported by a server for resource discovery and for providing access to other resources.
in addition, other endpoints may be hosted at other ports, e.g., in the dynamic port space.
implementation note: when a coap server is hosted by a 6lowpan node, header compression efficiency is improved when it also supports a port number in the 61616-61631 compressed udp port space defined in [rfc4944] and [rfc6282].
(note that, as its udp port differs from the default port, it is a different endpoint from the server at the default port.)
resource discovery the discovery of resources offered by a coap endpoint is extremely important in machine-to-machine applications where there are no humans in the loop and static interfaces result in fragility.
to maximize interoperability in a core environment, a coap endpoint should support the core link format of discoverable resources as described in [rfc6690], except where fully manual configuration is desired.
it is up to the server which resources are made discoverable (if any).
'ct' attribute this section defines a new web linking [rfc5988] attribute for use with [rfc6690].
the content-format code "ct" attribute provides a hint about the content-formats this resource returns.
note that this is only a hint, and it does not override the content-format option of a coap response obtained by actually requesting the representation of the resource.
the value is in the coap identifier code format as a decimal ascii integer and must be in the range of 0-65535 (16-bit unsigned integer).
for example, "application/xml" would be indicated as "ct=41".
if no content-format code attribute is present, then nothing about the type can be assumed.
the content-format code attribute may include a space-separated sequence of content-format codes, indicating that multiple content-formats are available.
the syntax of the attribute value is summarized in the production "ct- value" in figure 12, where "cardinal", "sp", and "dquote" are defined as in [rfc6690].
ct-value = cardinal / dquote cardinal *( 1*sp cardinal ) dquote figure 128.
multicast coap coap supports making requests to an ip multicast group.
this is defined by a series of deltas to unicast coap.
a more general discussion of group communication with coap is in [groupcomm].
coap endpoints that offer services that they want other endpoints to be able to find using multicast service discovery join one or more of the appropriate all-coap-node multicast addresses (section 12.8) and listen on the default coap port.
note that an endpoint might receive multicast requests on other multicast addresses, including the all- nodes ipv6 address (or via broadcast on ipv4); an endpoint must therefore be prepared to receive such messages but may ignore them if multicast service discovery is not desired.
messaging layer a multicast request is characterized by being transported in a coap message that is addressed to an ip multicast address instead of a coap endpoint.
such multicast requests must be non-confirmable.
a server should be aware that a request arrived via multicast, e.g., by making use of modern apis such as ipv6_recvpktinfo [rfc3542], if available.
to avoid an implosion of error responses, when a server is aware that a request arrived via multicast, it must not return a reset message in reply to a non-confirmable message.
if it is not aware, it may return a reset message in reply to a non-confirmable message as usual.
because such a reset message will look identical to one for a unicast message from the sender, the sender must avoid using a message id that is also still active from this endpoint with any unicast endpoint that might receive the multicast message.
at the time of writing, multicast messages can only be carried in udp not in dtls.
this means that the security modes defined for coap in this document are not applicable to multicast.
request/response layer when a server is aware that a request arrived via multicast, the server may always ignore the request, in particular if it doesn't have anything useful to respond (e.g., if it only has an empty payload or an error response).
the decision for this may depend on the application.
(for example, in query filtering as described in [rfc6690], a server should not respond to a multicast request if the filter does not match.
more examples are in [groupcomm].)
if a server does decide to respond to a multicast request, it should not respond immediately.
instead, it should pick a duration for the period of time during which it intends to respond.
for the purposes of this exposition, we call the length of this period the leisure.
the specific value of this leisure may depend on the application or may be derived as described below.
the server should then pick a random point of time within the chosen leisure period to send back the unicast response to the multicast request.
if further responses need to be sent based on the same multicast address membership, a new leisure period starts at the earliest after the previous one finishes.
to compute a value for leisure, the server should have a group size estimate g, a target data transfer rate r (which both should be chosen conservatively), and an estimated response size s; a rough lower bound for leisure can then be computed as lb_leisure = s * g / r for example, for a multicast request with link-local scope on a 2.4 ghz ieee 802.15.4 (6lowpan) network, g could be (relatively conservatively) set to 100, s to 100 bytes, and the target rate to 8 kbit/s = 1 kb/s.
the resulting lower bound for the leisure is 10 seconds.
if a coap endpoint does not have suitable data to compute a value for leisure, it may resort to default_leisure.
when matching a response to a multicast request, only the token must match; the source endpoint of the response does not need to (and will not) be the same as the destination endpoint of the original request.
for the purposes of interpreting the location-* options and any links embedded in the representation, the request uri (i.e., the base uri relative to which the response is interpreted) is formed by replacing the multicast address in the host component of the original request uri by the literal ip address of the endpoint actually responding.
caching when a client makes a multicast request, it always makes a new request to the multicast group (since there may be new group members that joined meanwhile or ones that did not get the previous request).
it may update a cache with the received responses.
then, it uses both cached-still-fresh and new responses as the result of the request.
a response received in reply to a get request to a multicast group may be used to satisfy a subsequent request on the related unicast request uri.
the unicast request uri is obtained by replacing the authority part of the request uri with the transport-layer source address of the response message.
a cache may revalidate a response by making a get request on the related unicast request uri.
a get request to a multicast group must not contain an etag option.
a mechanism to suppress responses the client already has is left for further study.
proxying when a forward-proxy receives a request with a proxy-uri or uri constructed from proxy-scheme that indicates a multicast address, the proxy obtains a set of responses as described above and sends all responses (both cached-still-fresh and new) back to the original client.
this specification does not provide a way to indicate the unicast- modified request uri (base uri) in responses thus forwarded.
proxying multicast requests is discussed in more detail in [groupcomm]; one proposal to address the base uri issue can be found in section 3 of [coap-misc].
securing coap this section defines the dtls binding for coap.
during the provisioning phase, a coap device is provided with the security information that it needs, including keying materials and access control lists.
this specification defines provisioning for the rawpublickey mode in section 9.1.3.2.1.
at the end of the provisioning phase, the device will be in one of four security modes with the following information for the given mode.
the nosec and rawpublickey modes are mandatory to implement for this specification.
nosec: there is no protocol-level security (dtls is disabled).
alternative techniques to provide lower-layer security should be used when appropriate.
the use of ipsec is discussed in [ipsec-coap].
certain link layers in use with constrained nodes also provide link-layer security, which may be appropriate with proper key management.
presharedkey: dtls is enabled, there is a list of pre-shared keys [rfc4279], and each key includes a list of which nodes it can be used to communicate with as described in section 9.1.3.1.
at the extreme, there may be one key for each node this coap node needs to communicate with (1:1 node/key ratio).
conversely, if more than two entities share a specific pre-shared key, this key only enables the entities to authenticate as a member of that group and not as a specific peer.
rawpublickey: dtls is enabled and the device has an asymmetric key pair without a certificate (a raw public key) that is validated using an out-of-band mechanism [rfc7250] as described in section 9.1.3.2.
the device also has an identity calculated from the public key and a list of identities of the nodes it can communicate with.
certificate: dtls is enabled and the device has an asymmetric key pair with an x.509 certificate [rfc5280] that binds it to its subject and is signed by some common trust root as described in section 9.1.3.3.
the device also has a list of root trust anchors that can be used for validating a certificate.
in the "nosec" mode, the system simply sends the packets over normal udp over ip and is indicated by the "coap" scheme and the coap default port.
the system is secured only by keeping attackers from being able to send or receive packets from the network with the coap nodes; see section 11.5 for an additional complication with this approach.
the other three security modes are achieved using dtls and are indicated by the "coaps" scheme and dtls-secured coap default port.
the result is a security association that can be used to authenticate (within the limits of the security model) and, based on this authentication, authorize the communication partner.
coap itself does not provide protocol primitives for authentication or authorization; where this is required, it can either be provided by communication security (i.e., ipsec or dtls) or by object security (within the payload).
devices that require authorization for certain operations are expected to require one of these two forms of security.
necessarily, where an intermediary is involved, communication security only works when that intermediary is part of the trust relationships.
coap does not provide a way to forward different levels of authorization that clients may have with an intermediary to further intermediaries or origin servers -- it therefore may be required to perform all authorization at the first intermediary.
dtls-secured coap just as http is secured using transport layer security (tls) over tcp, coap is secured using datagram tls (dtls) [rfc6347] over udp (see figure 13).
this section defines the coap binding to dtls, along with the minimal mandatory-to-implement configurations appropriate for constrained environments.
the binding is defined by a series of deltas to unicast coap.
in practice, dtls is tls with added features to deal with the unreliable nature of the udp transport.
in some constrained nodes (limited flash and/or ram) and networks (limited bandwidth or high scalability requirements), and depending on the specific cipher suites in use, all modes of dtls may not be applicable.
some dtls cipher suites can add significant implementation complexity as well as some initial handshake overhead needed when setting up the security association.
once the initial handshake is completed, dtls adds a limited per-datagram overhead of approximately 13 bytes, not including any initialization vectors/ nonces (e.g., 8 bytes with tls_psk_with_aes_128_ccm_8 [rfc6655]), integrity check values (e.g., 8 bytes with tls_psk_with_aes_128_ccm_8 [rfc6655]), and padding required by the cipher suite.
whether the use of a given mode of dtls is applicable for a coap-based application should be carefully weighed considering the specific cipher suites that may be applicable, whether the session maintenance makes it compatible with application flows, and whether sufficient resources are available on the constrained nodes and for the added network overhead.
(for some modes of using dtls, this specification identifies a mandatory-to-implement cipher suite.
this is an implementation requirement to maximize interoperability in those cases where these cipher suites are indeed appropriate.
the specific security policies of an application may determine the actual set of cipher suites that can be used.)
dtls is not applicable to group keying (multicast communication); however, it may be a component in a future group key management protocol.
messaging layer the endpoint acting as the coap client should also act as the dtls client.
it should initiate a session to the server on the appropriate port.
when the dtls handshake has finished, the client may initiate the first coap request.
all coap messages must be sent as dtls "application data".
the following rules are added for matching an acknowledgement message or reset message to a confirmable message, or a reset message to a non-confirmable message: the dtls session must be the same, and the epoch must be the same.
a message is the same when it is sent within the same dtls session and same epoch and has the same message id.
note: when a confirmable message is retransmitted, a new dtls sequence_number is used for each attempt, even though the coap message id stays the same.
so a recipient still has to perform deduplication as described in section 4.5.
retransmissions must not be performed across epochs.
dtls connections in rawpublickey and certificate mode are set up using mutual authentication so they can remain up and be reused for future message exchanges in either direction.
devices can close a dtls connection when they need to recover resources, but in general they should keep the connection up for as long as possible.
closing the dtls connection after every coap message exchange is very inefficient.
request/response layer the following rules are added for matching a response to a request: the dtls session must be the same, and the epoch must be the same.
this means the response to a dtls secured request must always be dtls secured using the same security session and epoch.
any attempt to supply a nosec response to a dtls request simply does not match the request and therefore must be rejected (unless it does match an unrelated nosec request).
endpoint identity devices should support the server name indication (sni) to indicate their authority in the sni hostname field as defined in sectionÂ 3 of [rfc6066].
this is needed so that when a host that acts as a virtual server for multiple authorities receives a new dtls connection, it knows which keys to use for the dtls session.
pre-shared keys when forming a connection to a new node, the system selects an appropriate key based on which nodes it is trying to reach and then forms a dtls session using a psk (pre-shared key) mode of dtls.
implementations in these modes must support the mandatory-to- implement cipher suite tls_psk_with_aes_128_ccm_8 as specified in [rfc6655].
depending on the commissioning model, applications may need to define an application profile for identity hints (as required and detailed in sectionÂ 5.2 of [rfc4279]) to enable the use of psk identity hints.
the security considerations of sectionÂ 7 of [rfc4279] apply.
in particular, applications should carefully weigh whether or not they need perfect forward secrecy (pfs) and select an appropriate cipher suite (sectionÂ 7.1 of [rfc4279]).
the entropy of the psk must be sufficient to mitigate against brute-force and (where the psk is not chosen randomly but by a human) dictionary attacks (sectionÂ 7.2 of [rfc4279]).
the cleartext communication of client identities may leak data or compromise privacy (sectionÂ 7.3 of [rfc4279]).
raw public key certificates in this mode, the device has an asymmetric key pair but without an x.509 certificate (called a raw public key); for example, the asymmetric key pair is generated by the manufacturer and installed on the device (see also section 11.6).
a device may be configured with multiple raw public keys.
the type and length of the raw public key depends on the cipher suite used.
implementations in rawpublickey mode must support the mandatory-to-implement cipher suite tls_ecdhe_ecdsa_with_aes_128_ccm_8 as specified in [rfc7251], [rfc5246], and [rfc4492].
the key used must be ecdsa capable.
the curve secp256r1 must be supported [rfc4492]; this curve is equivalent to the nist p-256 curve.
the hash algorithm is sha-256.
implementations must use the supported elliptic curves and supported point formats extensions [rfc4492]; the uncompressed point format must be supported; [rfc6090] can be used as an implementation method.
some guidance relevant to the implementation of this cipher suite can be found in [w3cxmlsec].
the mechanism for using raw public keys with tls is specified in [rfc7250].
provisioning the rawpublickey mode was designed to be easily provisioned in m2m deployments.
it is assumed that each device has an appropriate asymmetric public key pair installed.
an identifier is calculated by the endpoint from the public key as described in sectionÂ 2 of [rfc6920].
all implementations that support checking rawpublickey identities must support at least the sha-256-120 mode (sha-256 truncated to 120 bits).
implementations should also support longer length identifiers and may support shorter lengths.
note that the shorter lengths provide less security against attacks, and their use is not recommended.
depending on how identifiers are given to the system that verifies them, support for uri, binary, and/or human-speakable format [rfc6920] needs to be implemented.
all implementations should support the binary mode, and implementations that have a user interface should also support the human-speakable format.
during provisioning, the identifier of each node is collected, for example, by reading a barcode on the outside of the device or by obtaining a pre-compiled list of the identifiers.
these identifiers are then installed in the corresponding endpoint, for example, an m2m data collection server.
the identifier is used for two purposes, to associate the endpoint with further device information and to perform access control.
during (initial and ongoing) provisioning, an access control list of identifiers with which the device may start dtls sessions should also be installed and maintained.
x.509 certificates implementations in certificate mode must support the mandatory-to- implement cipher suite tls_ecdhe_ecdsa_with_aes_128_ccm_8 as specified in [rfc7251], [rfc5246], and [rfc4492].
namely, the certificate includes a subjectpublickeyinfo that indicates an algorithm of id-ecpublickey with namedcurves secp256r1 [rfc5480]; the public key format is uncompressed [rfc5480]; the hash algorithm is sha-256; if included, the key usage extension indicates digitalsignature.
certificates must be signed with ecdsa using secp256r1, and the signature must use sha-256.
the key used must be ecdsa capable.
the curve secp256r1 must be supported [rfc4492]; this curve is equivalent to the nist p-256 curve.
the hash algorithm is sha-256.
implementations must use the supported elliptic curves and supported point formats extensions [rfc4492]; the uncompressed point format must be supported; [rfc6090] can be used as an implementation method.
the subject in the certificate would be built out of a long-term unique identifier for the device such as the eui-64 [eui64].
the subject could also be based on the fully qualified domain name (fqdn) that was used as the host part of the coap uri.
however, the device's ip address should not typically be used as the subject, as it would change over time.
the discovery process used in the system would build up the mapping between ip addresses of the given devices and the subject for each device.
some devices could have more than one subject and would need more than a single certificate.
when a new connection is formed, the certificate from the remote device needs to be verified.
if the coap node has a source of absolute time, then the node should check that the validity dates of the certificate are within range.
the certificate must be validated as appropriate for the security requirements, using functionality equivalent to the algorithm specified in sectionÂ 6 of [rfc5280].
if the certificate contains a subjectaltname, then the authority of the request uri must match at least one of the authorities of any coap uri found in a field of uri type in the subjectaltname set.
if there is no subjectaltname in the certificate, then the authority of the request uri must match the common name (cn) found in the certificate using the matching rules defined in [rfc3280] with the exception that certificates with wildcards are not allowed.
core support for certificate status checking requires further study.
as a mapping of the online certificate status protocol (ocsp) [rfc6960] onto coap is not currently defined and ocsp may also not be easily applicable in all environments, an alternative approach may be using the tls certificate status request extension (sectionÂ 8 of [rfc6066]; also known as "ocsp stapling") or preferably the multiple certificate status extension ([rfc6961]), if available.
if the system has a shared key in addition to the certificate, then a cipher suite that includes the shared key such as tls_ecdhe_psk_with_aes_128_cbc_sha [rfc5489] should be used.
cross-protocol proxying between coap and http coap supports a limited subset of http functionality, and thus cross- protocol proxying to http is straightforward.
there might be several reasons for proxying between coap and http, for example, when designing a web interface for use over either protocol or when realizing a coap-http proxy.
likewise, coap could equally be proxied to other protocols such as xmpp [rfc6120] or sip [rfc3264]; the definition of these mechanisms is out of scope for this specification.
there are two possible directions to access a resource via a forward- proxy: coap-http proxying: enables coap clients to access resources on http servers through an intermediary.
this is initiated by including the proxy-uri or proxy-scheme option with an "http" or "https" uri in a coap request to a coap-http proxy.
http-coap proxying: enables http clients to access resources on coap servers through an intermediary.
this is initiated by specifying a "coap" or "coaps" uri in the request-line of an http request to an http-coap proxy.
either way, only the request/response model of coap is mapped to http.
the underlying model of confirmable or non-confirmable messages, etc., is invisible and must have no effect on a proxy function.
the following sections describe the handling of requests to a forward-proxy.
reverse-proxies are not specified, as the proxy function is transparent to the client with the proxy acting as if it were the origin server.
however, similar considerations apply to reverse-proxies as to forward-proxies, and there generally will be an expectation that reverse-proxies operate in a similar way forward- proxies would.
as an implementation note, http client libraries may make it hard to operate an http-coap forward-proxy by not providing a way to put a coap uri on the http request-line; reverse-proxying may therefore lead to wider applicability of a proxy.
a separate specification may define a convention for uris operating such an http-coap reverse-proxy [mapping].
coap-http proxying if a request contains a proxy-uri or proxy-scheme option with an 'http' or 'https' uri [rfc2616], then the receiving coap endpoint (called "the proxy" henceforth) is requested to perform the operation specified by the request method on the indicated http resource and return the result to the client.
(see also section 5.7 for how the request to the proxy is formulated, including security requirements.)
this section specifies for any coap request the coap response that the proxy should return to the client.
how the proxy actually satisfies the request is an implementation detail, although the typical case is expected to be that the proxy translates and forwards the request to an http origin server.
since http and coap share the basic set of request methods, performing a coap request on an http resource is not so different from performing it on a coap resource.
the meanings of the individual coap methods when performed on http resources are explained in the subsections of this section.
if the proxy is unable or unwilling to service a request with an http uri, a 5.05 (proxying not supported) response is returned to the client.
if the proxy services the request by interacting with a third party (such as the http origin server) and is unable to obtain a result within a reasonable time frame, a 5.04 (gateway timeout) response is returned; if a result can be obtained but is not understood, a 5.02 (bad gateway) response is returned.
get the get method requests the proxy to return a representation of the http resource identified by the request uri.
upon success, a 2.05 (content) response code should be returned.
the payload of the response must be a representation of the target http resource, and the content-format option must be set accordingly.
the response must indicate a max-age value that is no greater than the remaining time the representation can be considered fresh.
if the http entity has an entity-tag, the proxy should include an etag option in the response and process etag options in requests as described below.
a client can influence the processing of a get request by including the following option: accept: the request may include an accept option, identifying the preferred response content-format.
etag: the request may include one or more etag options, identifying responses that the client has stored.
this requests the proxy to send a 2.03 (valid) response whenever it would send a 2.05 (content) response with an entity-tag in the requested set otherwise.
note that coap etags are always strong etags in the http sense; coap does not have the equivalent of http weak etags, and there is no good way to make use of these in a cross-proxy.
put the put method requests the proxy to update or create the http resource identified by the request uri with the enclosed representation.
if a new resource is created at the request uri, a 2.01 (created) response must be returned to the client.
if an existing resource is modified, a 2.04 (changed) response must be returned to indicate successful completion of the request.
delete the delete method requests the proxy to delete the http resource identified by the request uri at the http origin server.
a 2.02 (deleted) response must be returned to the client upon success or if the resource does not exist at the time of the request.
post the post method requests the proxy to have the representation enclosed in the request be processed by the http origin server.
the actual function performed by the post method is determined by the origin server and dependent on the resource identified by the request uri.
if the action performed by the post method does not result in a resource that can be identified by a uri, a 2.04 (changed) response must be returned to the client.
if a resource has been created on the origin server, a 2.01 (created) response must be returned.
http-coap proxying if an http request contains a request-uri with a "coap" or "coaps" uri, then the receiving http endpoint (called "the proxy" henceforth) is requested to perform the operation specified by the request method on the indicated coap resource and return the result to the client.
this section specifies for any http request the http response that the proxy should return to the client.
unless otherwise specified, all the statements made are recommended behavior; some highly constrained implementations may need to resort to shortcuts.
how the proxy actually satisfies the request is an implementation detail, although the typical case is expected to be that the proxy translates and forwards the request to a coap origin server.
the meanings of the individual http methods when performed on coap resources are explained in the subsections of this section.
if the proxy is unable or unwilling to service a request with a coap uri, a 501 (not implemented) response is returned to the client.
if the proxy services the request by interacting with a third party (such as the coap origin server) and is unable to obtain a result within a reasonable time frame, a 504 (gateway timeout) response is returned; if a result can be obtained but is not understood, a 502 (bad gateway) response is returned.
options and trace as the options and trace methods are not supported in coap, a 501 (not implemented) error must be returned to the client.
get the get method requests the proxy to return a representation of the coap resource identified by the request-uri.
upon success, a 200 (ok) response is returned.
the payload of the response must be a representation of the target coap resource, and the content-type and content-encoding header fields must be set accordingly.
the response must indicate a max-age directive that indicates a value no greater than the remaining time the representation can be considered fresh.
if the coap response has an etag option, the proxy should include an etag header field in the response.
a client can influence the processing of a get request by including the following options: accept: the most-preferred media type of the http accept header field in a request is mapped to a coap accept option.
http accept media-type ranges, parameters, and extensions are not supported by the coap accept option.
if the proxy cannot send a response that is acceptable according to the combined accept field value, then the proxy sends a 406 (not acceptable) response.
the proxy may then retry the request with further media types from the http accept header field.
conditional gets: conditional http get requests that include an "if- match" or "if-none-match" request-header field can be mapped to a corresponding coap request.
the "if-modified-since" and "if- unmodified-since" request-header fields are not directly supported by coap but are implemented locally by a caching proxy.
head the head method is identical to get except that the server must not return a message-body in the response.
although there is no direct equivalent of http's head method in coap, an http-coap proxy responds to head requests for coap resources, and the http headers are returned without a message-body.
implementation note: an http-coap proxy may want to try using a block-wise transfer option [block] to minimize the amount of data actually transferred, but it needs to be prepared for the case that the origin server does not support block-wise transfers.
post the post method requests the proxy to have the representation enclosed in the request be processed by the coap origin server.
the actual function performed by the post method is determined by the origin server and dependent on the resource identified by the request uri.
if the action performed by the post method does not result in a resource that can be identified by a uri, a 200 (ok) or 204 (no content) response must be returned to the client.
if a resource has been created on the origin server, a 201 (created) response must be returned.
if any of the location-* options are present in the coap response, a location header field constructed from the values of these options is returned.
put the put method requests the proxy to update or create the coap resource identified by the request-uri with the enclosed representation.
if a new resource is created at the request-uri, a 201 (created) response is returned to the client.
if an existing resource is modified, either the 200 (ok) or 204 (no content) response codes is sent to indicate successful completion of the request.
delete the delete method requests the proxy to delete the coap resource identified by the request-uri at the coap origin server.
a successful response is 200 (ok) if the response includes an entity describing the status or 204 (no content) if the action has been enacted but the response does not include an entity.
connect this method cannot currently be satisfied by an http-coap proxy function, as tls to dtls tunneling has not yet been specified.
for now, a 501 (not implemented) error is returned to the client.
security considerations this section analyzes the possible threats to the protocol.
it is meant to inform protocol and application developers about the security limitations of coap as described in this document.
as coap realizes a subset of the features in http/1.1, the security considerations in sectionÂ 15 of [rfc2616] are also pertinent to coap.
this section concentrates on describing limitations specific to coap.
parsing the protocol and processing uris a network-facing application can exhibit vulnerabilities in its processing logic for incoming packets.
complex parsers are well- known as a likely source of such vulnerabilities, such as the ability to remotely crash a node, or even remotely execute arbitrary code on it.
coap attempts to narrow the opportunities for introducing such vulnerabilities by reducing parser complexity, by giving the entire range of encodable values a meaning where possible, and by aggressively reducing complexity that is often caused by unnecessary choice between multiple representations that mean the same thing.
much of the uri processing has been moved to the clients, further reducing the opportunities for introducing vulnerabilities into the servers.
even so, the uri processing code in coap implementations is likely to be a large source of remaining vulnerabilities and should be implemented with special care.
coap access control implementations need to ensure they don't introduce vulnerabilities through discrepancies between the code deriving access control decisions from a uri and the code finally serving up the resource addressed by the uri.
the most complex parser remaining could be the one for the core link format, although this also has been designed with a goal of reduced implementation complexity [rfc6690].
(see also sectionÂ 15.2 of [rfc2616].)
proxying and caching as mentioned in sectionÂ 15.7 of [rfc2616], proxies are by their very nature men-in-the-middle, breaking any ipsec or dtls protection that a direct coap message exchange might have.
they are therefore interesting targets for breaking confidentiality or integrity of coap message exchanges.
as noted in [rfc2616], they are also interesting targets for breaking availability.
the threat to confidentiality and integrity of request/response data is amplified where proxies also cache.
note that coap does not define any of the cache-suppressing cache-control options that http/1.1 provides to better protect sensitive data.
for a caching implementation, any access control considerations that would apply to making the request that generated the cache entry also need to be applied to the value in the cache.
this is relevant for clients that implement multiple security domains, as well as for proxies that may serve multiple clients.
also, a caching proxy must not make cached values available to requests that have lesser transport-security properties than those the proxy would require to perform request forwarding in the first place.
unlike the "coap" scheme, responses to "coaps" identified requests are never "public" and thus must not be reused for shared caching, unless the cache is able to make equivalent access control decisions to the ones that led to the cached entry.
they can, however, be reused in a private cache if the message is cacheable by default in coap.
finally, a proxy that fans out separate responses (as opposed to piggybacked responses) to multiple original requesters may provide additional amplification (see section 11.3).
risk of amplification coap servers generally reply to a request packet with a response packet.
this response packet may be significantly larger than the request packet.
an attacker might use coap nodes to turn a small attack packet into a larger attack packet, an approach known as amplification.
there is therefore a danger that coap nodes could become implicated in denial-of-service (dos) attacks by using the amplifying properties of the protocol: an attacker that is attempting to overload a victim but is limited in the amount of traffic it can generate can use amplification to generate a larger amount of traffic.
this is particularly a problem in nodes that enable nosec access, are accessible from an attacker, and can access potential victims (e.g., on the general internet), as the udp protocol provides no way to verify the source address given in the request packet.
an attacker need only place the ip address of the victim in the source address of a suitable request packet to generate a larger packet directed at the victim.
as a mitigating factor, many constrained networks will only be able to generate a small amount of traffic, which may make coap nodes less attractive for this attack.
however, the limited capacity of the constrained network makes the network itself a likely victim of an amplification attack.
therefore, large amplification factors should not be provided in the response if the request is not authenticated.
a coap server can reduce the amount of amplification it provides to an attacker by using slicing/blocking modes of coap [block] and offering large resource representations only in relatively small slices.
for example, for a 1000-byte resource, a 10-byte request might result in an 80-byte response (with a 64-byte block) instead of a 1016-byte response, considerably reducing the amplification provided.
coap also supports the use of multicast ip addresses in requests, an important requirement for m2m.
multicast coap requests may be the source of accidental or deliberate dos attacks, especially over constrained networks.
this specification attempts to reduce the amplification effects of multicast requests by limiting when a response is returned.
to limit the possibility of malicious use, coap servers should not accept multicast requests that can not be authenticated in some way, cryptographically or by some multicast boundary limiting the potential sources.
if possible, a coap server should limit the support for multicast requests to the specific resources where the feature is required.
on some general-purpose operating systems providing a posix-style api [ieee1003.1], it is not straightforward to find out whether a packet received was addressed to a multicast address.
while many implementations will know whether they have joined a multicast group, this creates a problem for packets addressed to multicast addresses of the form ff0x::1, which are received by every ipv6 node.
implementations should make use of modern apis such as ipv6_recvpktinfo [rfc3542], if available, to make this determination.
ip address spoofing attacks due to the lack of a handshake in udp, a rogue endpoint that is free to read and write messages carried by the constrained network (i.e., nosec or presharedkey deployments with a nodes/key ratio > 1:1), may easily attack a single endpoint, a group of endpoints, as well as the whole network, e.g., by: 1. spoofing a reset message in response to a confirmable message or non-confirmable message, thus making an endpoint "deaf"; or 2. spoofing an ack in response to a con message, thus potentially preventing the sender of the con message from retransmitting, and drowning out the actual response; or 3. spoofing the entire response with forged payload/options (this has different levels of impact: from single-response disruption, to much bolder attacks on the supporting infrastructure, e.g., poisoning proxy caches, or tricking validation/lookup interfaces in resource directories and, more generally, any component that stores global network state and uses coap as the messaging facility to handle setting or updating state is a potential target.
); or 4. spoofing a multicast request for a target node; this may result in network congestion/collapse, a dos attack on the victim, or forced wake-up from sleeping; or 5. spoofing observe messages, etc.
response spoofing by off-path attackers can be detected and mitigated even without transport layer security by choosing a nontrivial, randomized token in the request (section 5.3.1).
[rfc4086] discusses randomness requirements for security.
in principle, other kinds of spoofing can be detected by coap only in case confirmable message semantics is used, because of unexpected acknowledgement or reset messages coming from the deceived endpoint.
but this imposes keeping track of the used message ids, which is not always possible, and moreover detection becomes available usually after the damage is already done.
this kind of attack can be prevented using security modes other than nosec.
with or without source address spoofing, a client can attempt to overload a server by sending requests, preferably complex ones, to a server; address spoofing makes tracing back, and blocking, this attack harder.
given that the cost of a con request is small, this attack can easily be executed.
under this attack, a constrained node with limited total energy available may exhaust that energy much more quickly than planned (battery depletion attack).
also, if the client uses a confirmable message and the server responds with a confirmable separate response to a (possibly spoofed) address that does not respond, the server will have to allocate buffer and retransmission logic for each response up to the exhaustion of max_transmit_span, making it more likely that it runs out of resources for processing legitimate traffic.
the latter problem can be mitigated somewhat by limiting the rate of responses as discussed in section 4.7.
an attacker could also spoof the address of a legitimate client; this might cause the server, if it uses separate responses, to block legitimate responses to that client because of nstart=1.
all these attacks can be prevented using a security mode other than nosec, thus leaving only attacks on the security protocol.
cross-protocol attacks the ability to incite a coap endpoint to send packets to a fake source address can be used not only for amplification, but also for cross-protocol attacks against a victim listening to udp packets at a given address (ip address and port).
this would occur as follows: o the attacker sends a message to a coap endpoint with the given address as the fake source address.
o the coap endpoint replies with a message to the given source address.
o the victim at the given address receives a udp packet that it interprets according to the rules of a different protocol.
this may be used to circumvent firewall rules that prevent direct communication from the attacker to the victim but happen to allow communication from the coap endpoint (which may also host a valid role in the other protocol) to the victim.
also, coap endpoints may be the victim of a cross-protocol attack generated through an endpoint of another udp-based protocol such as dns.
in both cases, attacks are possible if the security properties of the endpoints rely on checking ip addresses (and firewalling off direct attacks sent from outside using fake ip addresses).
in general, because of their lack of context, udp-based protocols are relatively easy targets for cross-protocol attacks.
finally, coap uris transported by other means could be used to incite clients to send messages to endpoints of other protocols.
one mitigation against cross-protocol attacks is strict checking of the syntax of packets received, combined with sufficient difference in syntax.
as an example, it might help if it were difficult to incite a dns server to send a dns response that would pass the checks of a coap endpoint.
unfortunately, the first two bytes of a dns reply are an id that can be chosen by the attacker and that map into the interesting part of the coap header, and the next two bytes are then interpreted as coap's message id (i.e., any value is acceptable).
the dns count words may be interpreted as multiple instances of a (nonexistent but elective) coap option 0, or possibly as a token.
the echoed query finally may be manufactured by the attacker to achieve a desired effect on the coap endpoint; the response added by the server (if any) might then just be interpreted as added payload.
it is often much harder to ensure or prove the absence of viable attacks than to generate examples that may not yet completely enable an attack but might be further developed by more creative minds.
cross-protocol attacks can therefore only be completely mitigated if endpoints don't authorize actions desired by an attacker just based on trusting the source ip address of a packet.
conversely, a nosec environment that completely relies on a firewall for coap security not only needs to firewall off the coap endpoints but also all other endpoints that might be incited to send udp messages to coap endpoints using some other udp-based protocol.
in addition to the considerations above, the security considerations for dtls with respect to cross-protocol attacks apply.
for example, if the same dtls security association ("connection") is used to carry data of multiple protocols, dtls no longer provides protection against cross-protocol attacks between these protocols.
constrained-node considerations implementers on constrained nodes often find themselves without a good source of entropy [rfc4086].
if that is the case, the node must not be used for processes that require good entropy, such as key generation.
instead, keys should be generated externally and added to the device during manufacturing or commissioning.
due to their low processing power, constrained nodes are particularly susceptible to timing attacks.
special care must be taken in implementation of cryptographic primitives.
large numbers of constrained nodes will be installed in exposed environments and will have little resistance to tampering, including recovery of keying materials.
this needs to be considered when defining the scope of credentials assigned to them.
in particular, assigning a shared key to a group of nodes may make any single constrained node a target for subverting the entire group.
iana considerations12.1.
coap code registries this document defines two sub-registries for the values of the code field in the coap header within the "constrained restful environments (core) parameters" registry, hereafter referred to as the "core parameters" registry.
values in the two sub-registries are eight-bit values notated as three decimal digits c.dd separated by a period between the first and the second digit; the first digit c is between 0 and 7 and denotes the code class; the second and third digits dd denote a decimal number between 00 and 31 for the detail.
all code values are assigned by sub-registries according to the following ranges: 0.00 indicates an empty message (see section 4.1).
0.01-0.31 indicates a request.
values in this range are assigned by the "coap method codes" sub-registry (see section 12.1.1).
1.00-1.31 reserved 2.00-5.31 indicates a response.
values in this range are assigned by the "coap response codes" sub-registry (see section 12.1.2).
6.00-7.31 reserved12.1.1.
method codes the name of the sub-registry is "coap method codes".
each entry in the sub-registry must include the method code in the range 0.01-0.31, the name of the method, and a reference to the method's documentation.
the iana policy for future additions to this sub-registry is "ietf review or iesg approval" as described in [rfc5226].
the documentation of a method code should specify the semantics of a request with that code, including the following properties: o the response codes the method returns in the success case.
o whether the method is idempotent, safe, or both.
response codes the name of the sub-registry is "coap response codes".
each entry in the sub-registry must include the response code in the range 2.00-5.31, a description of the response code, and a reference to the response code's documentation.
all other response codes are unassigned.
the iana policy for future additions to this sub-registry is "ietf review or iesg approval" as described in [rfc5226].
the documentation of a response code should specify the semantics of a response with that code, including the following properties: o the methods the response code applies to.
o whether payload is required, optional, or not allowed.
o the semantics of the payload.
for example, the payload of a 2.05 (content) response is a representation of the target resource; the payload in an error response is a human-readable diagnostic payload.
o the format of the payload.
for example, the format in a 2.05 (content) response is indicated by the content-format option; the format of the payload in an error response is always net-unicode text.
o whether the response is cacheable according to the freshness model.
o whether the response is validatable according to the validation model.
o whether the response causes a cache to mark responses stored for the request uri as not fresh.
coap option numbers registry this document defines a sub-registry for the option numbers used in coap options within the "core parameters" registry.
the name of the sub-registry is "coap option numbers".
each entry in the sub-registry must include the option number, the name of the option, and a reference to the option's documentation.
the range of 0..255 is reserved for options defined by the ietf (ietf review or iesg approval).
the range of 256..2047 is reserved for commonly used options with public specifications (specification required).
the range of 2048..64999 is for all other options including private or vendor-specific ones, which undergo a designated expert review to help ensure that the option semantics are defined correctly.
the option numbers between 65000 and 65535 inclusive are reserved for experiments.
they are not meant for vendor-specific use of any kind and must not be used in operational deployments.
o the meaning of the option in a response.
o whether the option is critical or elective, as determined by the option number.
o whether the option is safe-to-forward, and, if yes, whether it is part of the cache-key, as determined by the option number (see section 5.4.2).
o the format and length of the option's value.
o whether the option must occur at most once or whether it can occur multiple times.
o the default value, if any.
for a critical option with a default value, a discussion on how the default value enables processing by implementations that do not support the critical option (section 5.4.4).
coap content-formats registry internet media types are identified by a string, such as "application/xml" [rfc2046].
in order to minimize the overhead of using these media types to indicate the format of payloads, this document defines a sub-registry for a subset of internet media types to be used in coap and assigns each, in combination with a content- coding, a numeric identifier.
the name of the sub-registry is "coap content-formats", within the "core parameters" registry.
each entry in the sub-registry must include the media type registered with iana, the numeric identifier in the range 0-65535 to be used for that media type in coap, the content-coding associated with this identifier, and a reference to a document describing what a payload with that media type means semantically.
coap does not include a separate way to convey content-encoding information with a request or response, and for that reason the content-encoding is also specified for each identifier (if any).
if multiple content-encodings will be used with a media type, then a separate content-format identifier for each is to be registered.
similarly, other parameters related to an internet media type, such as level, can be defined for a coap content-format entry.
they are not meant for vendor-specific use of any kind and must not be used in operational deployments.
the identifiers between 256 and 9999 are reserved for future use in ietf specifications (ietf review or iesg approval).
all other identifiers are unassigned.
because the namespace of single-byte identifiers is so small, the iana policy for future additions in the range 0-255 inclusive to the sub-registry is "expert review" as described in [rfc5226].
the iana policy for additions in the range 10000-64999 inclusive is "first come first served" as described in [rfc5226].
this is summarized in the following table.
it is recommended that m2m applications making use of coap request new internet media types from iana indicating semantic information about how to create or parse a payload.
for example, a smart energy application payload carried as xml might request a more specific type like application/se+xml or application/se-exi.
uri scheme registration this document contains the request for the registration of the uniform resource identifier (uri) scheme "coap".
the registration request complies with [rfc4395].
uri scheme name.
coap status.
permanent.
uri scheme syntax.
defined in sectionÂ 6.1 of [rfc7252].
uri scheme semantics.
the "coap" uri scheme provides a way to identify resources that are potentially accessible over the constrained application protocol (coap).
the resources can be located by contacting the governing coap server and operated on by sending coap requests to the server.
this scheme can thus be compared to the "http" uri scheme [rfc2616].
see sectionÂ 6 of [rfc7252] for the details of operation.
encoding considerations.
the scheme encoding conforms to the encoding rules established for uris in [rfc3986], i.e., internationalized and reserved characters are expressed using utf-8-based percent-encoding.
applications/protocols that use this uri scheme name.
the scheme is used by coap endpoints to access coap resources.
interoperability considerations.
none.
security considerations.
see sectionÂ 11.1 of [rfc7252].
contact.
ietf chair <chair@ietf.org> author/change controller.
iesg <iesg@ietf.org> references.
[rfc7252]12.5.
secure uri scheme registration this document contains the request for the registration of the uniform resource identifier (uri) scheme "coaps".
the registration request complies with [rfc4395].
uri scheme name.
coaps status.
permanent.
uri scheme syntax.
defined in sectionÂ 6.2 of [rfc7252].
uri scheme semantics.
the "coaps" uri scheme provides a way to identify resources that are potentially accessible over the constrained application protocol (coap) using datagram transport layer security (dtls) for transport security.
the resources can be located by contacting the governing coap server and operated on by sending coap requests to the server.
this scheme can thus be compared to the "https" uri scheme [rfc2616].
see sectionÂ 6 of [rfc7252] for the details of operation.
encoding considerations.
the scheme encoding conforms to the encoding rules established for uris in [rfc3986], i.e., internationalized and reserved characters are expressed using utf-8-based percent-encoding.
applications/protocols that use this uri scheme name.
the scheme is used by coap endpoints to access coap resources using dtls.
interoperability considerations.
none.
security considerations.
see sectionÂ 11.1 of [rfc7252].
contact.
ietf chair <chair@ietf.org> author/change controller.
iesg <iesg@ietf.org> references.
[rfc7252]12.6.
service name and port number registration one of the functions of coap is resource discovery: a coap client can ask a coap server about the resources offered by it (see section 7).
to enable resource discovery just based on the knowledge of an ip address, the coap port for resource discovery needs to be standardized.
iana has assigned the port number 5683 and the service name "coap", in accordance with [rfc6335].
besides unicast, coap can be used with both multicast and anycast.
service name.
coap transport protocol.
udp assignee.
iesg <iesg@ietf.org> contact.
ietf chair <chair@ietf.org> description.
constrained application protocol (coap) reference.
[rfc7252] port number.
secure service name and port number registration coap resource discovery may also be provided using the dtls-secured coap "coaps" scheme.
thus, the coap port for secure resource discovery needs to be standardized.
iana has assigned the port number 5684 and the service name "coaps", in accordance with [rfc6335].
besides unicast, dtls-secured coap can be used with anycast.
service name.
coaps transport protocol.
udp assignee.
iesg <iesg@ietf.org> contact.
ietf chair <chair@ietf.org> description.
dtls-secured coap reference.
[rfc7252] port number.
5684
multicast address registration section 8, "multicast coap", defines the use of multicast.
iana has assigned the following multicast addresses for use by coap nodes: ipv4 -- "all coap nodes" address 224.0.1.187, from the "ipv4 multicast address space registry".
as the address is used for discovery that may span beyond a single network, it has come from the internetwork control block (224.0.1.x, rfc 5771).
ipv6 -- "all coap nodes" address ff0x::fd, from the "ipv6 multicast address space registry", in the "variable scope multicast addresses" space (rfc 3307).
note that there is a distinct multicast address for each scope that interested coap nodes should listen to; coap needs the link-local and site-local scopes only.
acknowledgements brian frank was a contributor to and coauthor of early versions of this specification.
special thanks to peter bigot, esko dijk, and cullen jennings for substantial contributions to the ideas and text in the document, along with countless detailed reviews and discussions.
thanks to floris van den abeele, anthony baire, ed beroset, berta carballido, angelo p. castellani, gilbert clark, robert cragie, pierre david, esko dijk, lisa dusseault, mehmet ersue, thomas fossati, tobias gondrom, bert greevenbosch, tom herbst, jeroen hoebeke, richard kelsey, sye loong keoh, ari keranen, matthias kovatsch, avi lior, stephan lohse, salvatore loreto, kerry lynn, andrew mcgregor, alexey melnikov, guido moritz, petri mutka, colin o'flynn, charles palmer, adriano pezzuto, thomas poetsch, robert quattlebaum, akbar rahman, eric rescorla, dan romascanu, david ryan, peter saint-andre, szymon sasin, michael scharf, dale seed, robby simpson, peter van der stok, michael stuber, linyi tian, gilman tolle, matthieu vial, maciej wasilak, fan xianyou, and alper yegin for helpful comments and discussions that have shaped the document.
special thanks also to the responsible ietf area director at the time of completion, barry leiba, and the iesg reviewers, adrian farrel, martin stiemerling, pete resnick, richard barnes, sean turner, spencer dawkins, stephen farrell, and ted lemon, who contributed in- depth reviews.
some of the text has been borrowed from the working documents of the ietf httpbis working group.

introduction the work on constrained restful environments (core) aims at realizing the representational state transfer (rest) architecture in a suitable form for the most constrained nodes (such as microcontrollers with limited ram and rom [rfc7228]) and networks (such as ipv6 over low- power wireless personal area networks (6lowpans) [rfc4944]) [rfc7252].
the coap protocol is intended to provide restful [rest] services not unlike http [rfc7230], while reducing the complexity of implementation as well as the size of packets exchanged in order to make these services useful in a highly constrained network of highly constrained nodes.
this objective requires restraint in a number of sometimes conflicting ways: o reducing implementation complexity in order to minimize code size, o reducing message sizes in order to minimize the number of fragments needed for each message (to maximize the probability of delivery of the message), the amount of transmission power needed, and the loading of the limited-bandwidth channel, o reducing requirements on the environment such as stable storage, good sources of randomness, or user-interaction capabilities.
because coap is based on datagram transports such as udp or datagram transport layer security (dtls), the maximum size of resource representations that can be transferred without too much fragmentation is limited.
in addition, not all resource representations will fit into a single link-layer packet of a constrained network, which may cause adaptation layer fragmentation even if ip-layer fragmentation is not required.
using fragmentation (either at the adaptation layer or at the ip layer) for the transport of larger representations would be possible up to the maximum size of the underlying datagram protocol (such as udp), but the fragmentation/reassembly process burdens the lower layers with conversation state that is better managed in the application layer.
the present specification defines a pair of coap options to enable block-wise access to resource representations.
the block options provide a minimal way to transfer larger resource representations in a block-wise fashion.
the overriding objective is to avoid the need for creating conversation state at the server for block-wise get requests.
(it is impossible to fully avoid creating conversation state for post/put, if the creation/replacement of resources is to be atomic; where that property is not needed, there is no need to create server conversation state in this case, either.)
block-wise transfers are realized as combinations of exchanges, each of which is performed according to the coap base protocol [rfc7252].
each exchange in such a combination is governed by the specifications in [rfc7252], including the congestion control specifications (section 4.7 of [rfc7252]) and the security considerations (section 11 of [rfc7252]; additional security considerations then apply to the transfers as a whole, see section 7).
the present specification minimizes the constraints it adds to those base exchanges; however, not all variants of using coap are very useful inside a block-wise transfer (e.g., using non-confirmable requests within block-wise transfers outside the use case of section 2.8 would escalate the overall non-delivery probability).
to be perfectly clear, the present specification also does not remove any of the constraints posed by the base specification it is strictly layered on top of.
for example, back-to-back packets are limited by the congestion control described in section 4.7 of [rfc7252] (nstart as a limit for initiating exchanges, probing_rate as a limit for sending with no response); block-wise transfers cannot send/solicit more traffic than a client could be sending to / soliciting from the same server without the block-wise mode.
in some cases, the present specification will recommend that a client perform a sequence of block-wise transfers "without undue delay".
this cannot be phrased as an interoperability requirement, but is an expectation on implementation quality.
conversely, the expectation is that servers will not have to go out of their way to accommodate clients that take considerable time to finish a block-wise transfer.
for example, for a block-wise get, if the resource changes while this proceeds, the entity-tag (etag) for a further block obtained may be different.
to avoid this happening all the time for a fast-changing resource, a server may try to keep a cache around for a specific client for a short amount of time.
the expectation here is that the lifetime for such a cache can be kept short, on the order of a few expected round-trip times, counting from the previous block transferred.
in summary, this specification adds a pair of block options to coap that can be used for block-wise transfers.
benefits of using these options include: o transfers larger than what can be accommodated in constrained- network link-layer packets can be performed in smaller blocks.
o no hard-to-manage conversation state is created at the adaptation layer or ip layer for fragmentation.
o the transfer of each block is acknowledged, enabling individual retransmission if required.
o both sides have a say in the block size that actually will be used.
o the resulting exchanges are easy to understand using packet analyzer tools, and thus quite accessible to debugging.
o if needed, the block options can also be used (without changes) to provide random access to power-of-two sized blocks within a resource representation.
a coap implementation that does not support these options generally is limited in the size of the representations that can be exchanged, see section 4.6 of [rfc7252].
even though the options are critical, a server may decide to start using them in an unsolicited way in a response.
no effort was expended to provide a capability indication mechanism supporting that decision: since the block-wise transfer mechanisms are so fundamental to the use of coap for representations larger than about a kilobyte, there is an expectation that they are very widely implemented.
the key words "must", "must not", "required", "shall", "shall not", "should", "should not", "recommended", "not recommended", "may", and "optional" in this document are to be interpreted as described in rfc 2119, bcp 14 [rfc2119] and indicate requirement levels for compliant coap implementations.
in this document, the term "byte" is used in its now customary sense as a synonym for "octet".
where bit arithmetic is explained, this document uses the notation familiar from the programming language c, except that the operator "**" stands for exponentiation.
block-wise transfers as discussed in the introduction, there are good reasons to limit the size of datagrams in constrained networks: o by the maximum datagram size (~ 64 kib for udp) o by the desire to avoid ip fragmentation (mtu of 1280 for ipv6) o by the desire to avoid adaptation-layer fragmentation (60-80 bytes for 6lowpan [rfc4919]) when a resource representation is larger than can be comfortably transferred in the payload of a single coap datagram, a block option can be used to indicate a block-wise transfer.
as payloads can bebormann & shelby standards track [page 6]rfc 7959 block-wise transfer in coap august 2016 sent both with requests and with responses, this specification provides two separate options for each direction of payload transfer.
in naming these options (for block-wise transfers as well as in section 4), we use the number 1 ("block1", "size1") to refer to the transfer of the resource representation that pertains to the request, and the number 2 ("block2", "size2") to refer to the transfer of the resource representation for the response.
in the following, the term "payload" will be used for the actual content of a single coap message, i.e., a single block being transferred, while the term "body" will be used for the entire resource representation that is being transferred in a block-wise fashion.
the content-format option applies to the body, not to the payload; in particular, the boundaries between the blocks may be in places that are not separating whole units in terms of the structure, encoding, or content-coding used by the content-format.
(similarly, the etag option defined in section 5.10.6 of [rfc7252] applies to the whole representation of the resource, and thus to the body of the response.)
in most cases, all blocks being transferred for a body (except for the last one) will be of the same size.
(if the first request uses a bigger block size than the receiver prefers, subsequent requests will use the preferred block size.)
the block size is not fixed by the protocol.
to keep the implementation as simple as possible, the block options support only a small range of power-of-two block sizes, from 2**4 (16) to 2**10 (1024) bytes.
as bodies often will not evenly divide into the power-of-two block size chosen, the size need not be reached in the final block (but even for the final block, the chosen power-of-two size will still be indicated in the block size field of the block option).
in either case, the block1 option pertains to the request payload, and the block2 option pertains to the response payload.
hence, for the methods defined in [rfc7252], block1 is useful with the payload-bearing post and put requests and their responses.
block2 is useful with get, post, and put requests and their payload- bearing responses (2.01, 2.02, 2.04, and 2.05 -- see section 5.5 of [rfc7252]).
where block1 is present in a request or block2 in a response (i.e., in that message to the payload of which it pertains) it indicates a block-wise transfer and describes how this specific block-wise payload forms part of the entire body being transferred ("descriptive usage").
where it is present in the opposite direction, it provides additional control on how that payload will be formed or was processed ("control usage").
implementation of either block option is intended to be optional.
however, when it is present in a coap message, it must be processed (or the message rejected); therefore, it is identified as a critical option.
either block option must not occur more than once in a single message.
structure of a block option three items of information may need to be transferred in a block (block1 or block2) option: o the size of the block (szx); o whether more blocks are following (m); o the relative number of the block (num) within a sequence of blocks with the given size.
the value of the block option is a variable-size (0 to 3 byte) unsigned integer (uint, see section 3.2 of [rfc7252]).
this integer value encodes these three fields, see figure 1.
(due to the coap uint-encoding rules, when all of num, m, and szx happen to be zero, a zero-byte integer will be sent.)
szx is transferred in the three least significant bits of the option value (i.e., "val & 7" where "val" is the value of the option).
the fourth least significant bit, the m or "more" bit ("val & 8"), indicates whether more blocks are following or if the current block- wise transfer is the last block being transferred.
the option value divided by sixteen (the num field) is the sequence number of the block currently being transferred, starting from zero.
the current transfer is, therefore, about the "size" bytes starting at byte "num << (szx + 4)".
implementation note: as an implementation convenience, "(val & ~0xf) << (val & 7)", i.e., the option value with the last 4 bits masked out, shifted to the left by the value of szx, gives the byte position of the first byte of the block being transferred.
more specifically, within the option value of a block1 or block2 option, the meaning of the option fields is defined as follows: num: block number, indicating the block number being requested or provided.
block number 0 indicates the first block of a body (i.e., starting with the first byte of the body).
m: more flag ("not last block").
for descriptive usage, this flag, if unset, indicates that the payload in this message is the last block in the body; when set, it indicates that there are one or more additional blocks available.
when a block2 option is used in a request to retrieve a specific block number ("control usage"), the m bit must be sent as zero and ignored on reception.
(in a block1 option in a response, the m flag is used to indicate atomicity, see below.)
szx: block size.
the block size is represented as a three-bit unsigned integer indicating the size of a block to the power of two.
thus, block size = 2**(szx + 4).
the allowed values of szx are 0 to 6, i.e., the minimum block size is 2**(0+4) = 16 and the maximum is 2**(6+4) = 1024.
the value 7 for szx (which would indicate a block size of 2048) is reserved, i.e., must not be sent and must lead to a 4.00 bad request response code upon reception in a request.
there is no default value for the block1 and block2 options.
absence of one of these options is equivalent to an option value of 0 with respect to the value of num and m that could be given in the option, i.e., it indicates that the current block is the first and only block of the transfer (block number 0, m bit not set).
however, in contrast to the explicit value 0, which would indicate an szx of 0 and thus a size value of 16 bytes, there is no specific explicit size implied by the absence of the option -- the size is left unspecified.
(as for any uint, the explicit value 0 is efficiently indicated by a zero-length option; this, therefore, is different in semantics from the absence of the option.)
block options in requests and responses the block options are used in one of three roles: o in descriptive usage, i.e., a block2 option in a response (such as a 2.05 response for get), or a block1 option in a request (a put or post): * the num field in the option value describes what block number is contained in the payload of this message.
* the m bit indicates whether further blocks need to be transferred to complete the transfer of that body.
* the block size implied by szx must match the size of the payload in bytes, if the m bit is set.
(szx does not govern the payload size if m is unset).
for block2, if the request suggested a larger value of szx, the next request must move szxbormann & shelby standards track [page 10]rfc 7959 block-wise transfer in coap august 2016 down to the size given in the response.
(the effect is that, if the server uses the smaller of (1) its preferred block size and (2) the block size requested, all blocks for a body use the same block size.)
o a block2 option in control usage in a request (e.g., get): * the num field in the block2 option gives the block number of the payload that is being requested to be returned in the response.
* in this case, the m bit has no function and must be set to zero.
* the block size given (szx) suggests a block size (in the case of block number 0) or repeats the block size of previous blocks received (in the case of a non-zero block number).
o a block1 option in control usage in a response (e.g., a 2.xx response for a put or post request): * the num field of the block1 option indicates what block number is being acknowledged.
* if the m bit was set in the request, the server can choose whether to act on each block separately, with no memory, or whether to handle the request for the entire body atomically, or any mix of the two.
+ if the m bit is also set in the response, it indicates that this response does not carry the final response code to the request, i.e., the server collects further blocks from the same endpoint and plans to implement the request atomically (e.g., acts only upon reception of the last block of payload).
in this case, the response must not carry a block2 option.
+ conversely, if the m bit is unset even though it was set in the request, it indicates the block-wise request was enacted now specifically for this block, and the response carries the final response to this request (and to any previous ones with the m bit set in the response's block1 option in this sequence of block-wise transfers); the client is still expected to continue sending further blocks, the request method for which may or may not also be enacted per-block.
(note that the resource is now in a partially updated state; this approach is only appropriate where exposing such anbormann & shelby standards track [page 11]rfc 7959 block-wise transfer in coap august 2016 intermediate state is acceptable.
the client can reduce the window by quickly continuing to update the resource, or, in case of failure, restarting the update.)
* finally, the szx block size given in a control block1 option indicates the largest block size preferred by the server for transfers toward the resource that is the same or smaller than the one used in the initial exchange; the client should use this block size or a smaller one in all further requests in the transfer sequence, even if that means changing the block size (and possibly scaling the block number accordingly) from now on.
using one or both block options, a single rest operation can be split into multiple coap message exchanges.
as specified in [rfc7252], each of these message exchanges uses their own coap message id.
the content-format option sent with the requests or responses must reflect the content-format of the entire body.
if blocks of a response body arrive with different content-format options, it is up to the client how to handle this error (it will typically abort any ongoing block-wise transfer).
if blocks of a request arrive at a server with mismatching content-format options, the server must not assemble them into a single request; this usually leads to a 4.08 (request entity incomplete, section 2.9.2) error response on the mismatching block.
using the block2 option when a request is answered with a response carrying a block2 option with the m bit set, the requester may retrieve additional blocks of the resource representation by sending further requests with the same options as the initial request and a block2 option giving the block number and block size desired.
in a request, the client must set the m bit of a block2 option to zero and the server must ignore it on reception.
to influence the block size used in a response, the requester may also use the block2 option on the initial request, giving the desired size, a block number of zero and an m bit of zero.
a server must use the block size indicated or a smaller size.
any further block-wise requests for blocks beyond the first one must indicate the same block size that was used by the server in the response for the first request that gave a desired size using a block2 option.
once the block2 option is used by the requester and a first response has been received with a possibly adjusted block size, all further requests in a single block-wise transfer will ultimately converge onbormann & shelby standards track [page 12]rfc 7959 block-wise transfer in coap august 2016 using the same size, except that there may not be enough content to fill the last block (the one returned with the m bit not set).
(note that the client may start using the block2 option in a second request after a first request without a block2 option resulted in a block2 option in the response.)
the server uses the block size indicated in the request option or a smaller size, but the requester must take note of the actual block size used in the response it receives to its initial request and proceed to use it in subsequent requests.
the server behavior must ensure that this client behavior results in the same block size for all responses in a sequence (except for the last one with the m bit not set, and possibly the first one if the initial request did not contain a block2 option).
block-wise transfers can be used to get resources whose representations are entirely static (not changing over time at all, such as in a schema describing a device), or for dynamically changing resources.
in the latter case, the block2 option should be used in conjunction with the etag option ([rfc7252], section 5.10.6), to ensure that the blocks being reassembled are from the same version of the representation: the server should include an etag option in each response.
if an etag option is available, the client, when reassembling the representation from the blocks being exchanged, must compare etag options.
if the etag options do not match in a get transfer, the requester has the option of attempting to retrieve fresh values for the blocks it retrieved first.
to minimize the resulting inefficiency, the server may cache the current value of a representation for an ongoing sequence of requests.
(the server may identify the sequence by the combination of the requesting endpoint and the uri being the same in each block-wise request.)
note well that this specification makes no requirement for the server to establish any state; however, servers that offer quickly changing resources may thereby make it impossible for a client to ever retrieve a consistent set of blocks.
clients that want to retrieve all blocks of a resource should strive to do so without undue delay.
servers can fully expect to be free to discard any cached state after a period of exchange_lifetime ([rfc7252], section 4.8.2) after the last access to the state, however, there is no requirement to always keep the state for as long.
the block2 option provides no way for a single endpoint to perform multiple concurrently proceeding block-wise response payload transfer (e.g., get) operations to the same resource.
this is rarely a requirement, but as a workaround, a client may vary the cache key (e.g., by using one of several uris accessing resources with the same semantics, or by varying a proxy-safe elective option).
using the block1 option in a request with a request payload (e.g., put or post), the block1 option refers to the payload in the request (descriptive usage).
in response to a request with a payload (e.g., a put or post transfer), the block size given in the block1 option indicates the block size preference of the server for this resource (control usage).
obviously, at this point the first block has already been transferred by the client without benefit of this knowledge.
still, the client should heed the preference indicated and, for all further blocks, use the block size preferred by the server or a smaller one.
note that any reduction in the block size may mean that the second request starts with a block number larger than one, as the first request already transferred multiple blocks as counted in the smaller size.
to counter the effects of adaptation-layer fragmentation on packet- delivery probability, a client may want to give up retransmitting a request with a relatively large payload even before max_retransmit has been reached, and try restating the request as a block-wise transfer with a smaller payload.
note that this new attempt is then a new message-layer transaction and requires a new message id.
(because of the uncertainty about whether the request or the acknowledgement was lost, this strategy is useful mostly for idempotent requests.)
in a block-wise transfer of a request payload (e.g., a put or post) that is intended to be implemented in an atomic fashion at the server, the actual creation/replacement takes place at the time the final block, i.e., a block with the m bit unset in the block1 option, is received.
in this case, all success responses to non-final blocks carry the response code 2.31 (continue, section 2.9.1).
if not all previous blocks are available at the server at the time of processing the final block, the transfer fails and error code 4.08 (request entity incomplete, section 2.9.2) must be returned.
a server may also return a 4.08 error code for any (final or non-final) block1 transfer that is not in sequence; therefore, clients that do not have specific mechanisms to handle this case should always start with block zero and send the following blocks in order.
one reason that a client might encounter a 4.08 error code is that the server has already timed out and discarded the partial request body being assembled.
clients should strive to send all blocks of a request without undue delay.
servers can fully expect to be free to discard any partial request body when a period of exchange_lifetimebormann & shelby standards track [page 14]rfc 7959 block-wise transfer in coap august 2016 ([rfc7252], section 4.8.2) has elapsed after the most recent block was transferred; however, there is no requirement on a server to always keep the partial request body for as long.
the error code 4.13 (request entity too large) can be returned at any time by a server that does not currently have the resources to store blocks for a block-wise request payload transfer that it would intend to implement in an atomic fashion.
(note that a 4.13 response to a request that does not employ block1 is a hint for the client to try sending block1, and a 4.13 response with a smaller szx in its block1 option than requested is a hint to try a smaller szx.)
a block-wise transfer of a request payload that is implemented in a stateless fashion at the server is likely to leave the resource being operated on in an inconsistent state while the transfer is still ongoing or when the client does not complete the transfer.
this characteristic is closer to that of remote file systems than to that of http, where state is always kept on the server during a transfer.
techniques well known from shared file access (e.g., client-specific temporary resources) can be used to mitigate this difference from http.
the block1 option provides no way for a single endpoint to perform multiple concurrently proceeding block-wise request payload transfer (e.g., put or post) operations to the same resource.
starting a new block-wise sequence of requests to the same resource (before an old sequence from the same endpoint was finished) simply overwrites the context the server may still be keeping.
(this is probably exactly what one wants in this case -- the client may simply have restarted and lost its knowledge of the previous sequence.)
combining block-wise transfers with the observe option the observe option provides a way for a client to be notified about changes over time of a resource [rfc7641].
resources observed by clients may be larger than can be comfortably processed or transferred in one coap message.
the following rules apply to the combination of block-wise transfers with notifications.
observation relationships always apply to an entire resource; the block2 option does not provide a way to observe a single block of a resource.
as with basic get transfers, the client can indicate its desired block size in a block2 option in the get request establishing or renewing the observation relationship.
if the server supports block- wise transfers, it should take note of the block size and apply it as a maximum size to all notifications/responses resulting from the getbormann & shelby standards track [page 15]rfc 7959 block-wise transfer in coap august 2016 request (until the client is removed from the list of observers or the entry in that list is updated by the server receiving a new get request for the resource from the client).
when sending a 2.05 (content) notification, the server only sends the first block of the representation.
the client retrieves the rest of the representation as if it had caused this first response by a get request, i.e., by using additional get requests with block2 options containing num values greater than zero.
(this results in the transfer of the entire representation, even if only some of the blocks have changed with respect to a previous notification.)
as with other dynamically changing resources, to ensure that the blocks being reassembled are from the same version of the representation, the server should include an etag option in each response, and the reassembling client must compare the etag options (section 2.4).
even more so than for the general case of block2, clients that want to retrieve all blocks of a resource they have been notified about with a first block should strive to do so without undue delay.
see section 3.4 for examples.
combining block1 and block2 in put and particularly in post exchanges, both the request body and the response body may be large enough to require the use of block- wise transfers.
first, the block1 transfer of the request body proceeds as usual.
in the exchange of the last slice of this block- wise transfer, the response carries the first slice of the block2 transfer (num is zero).
to continue this block2 transfer, the client continues to send requests similar to the requests in the block1 phase, but leaves out the block1 options and includes a block2 request option with non-zero num.
block2 transfers that retrieve the response body for a request that used block1 must be performed in sequential order.
combining block2 with multicast a client can use the block2 option in a multicast get request with num = 0 to aid in limiting the size of the response.
similarly, a response to a multicast get request can use a block2 option with num = 0 if the representation is large, or to further limit the size of the response.
in both cases, the client retrieves any further blocks using unicast exchanges; in the unicast requests, the client should heed any block size preferences indicated by the server in the response to the multicast request.
other uses of the block options in conjunction with multicast messages are for further study.
response codes beyond the response codes defined in [rfc7252], this specification defines two response codes and extends the meaning of one.
2.31 continue this new success status code indicates that the transfer of this block of the request body was successful and that the server encourages sending further blocks, but that a final outcome of the whole block-wise request cannot yet be determined.
no payload is returned with this response code.
4.08 request entity incomplete this new client error status code indicates that the server has not received the blocks of the request body that it needs to proceed.
the client has not sent all blocks, not sent them in the order required by the server, or has sent them long enough ago that the server has already discarded them.
(note that one reason for not having the necessary blocks at hand may be a content-format mismatch, see section 2.3.
implementation note: a server can reject a block1 transfer with this code when num != 0 and a different content-format is indicated than expected from the current state of the resource.
if it implements the transfer in a stateless fashion, it can match up the content-format of the block against that of the existing resource.
if it implements the transfer in an atomic fashion, it can match up the block against the partially reassembled piece of representation that is going to replace the state of the resource.)
4.13 request entity too large in section 5.9.2.9 of [rfc7252], the response code 4.13 (request entity too large) is defined to be like http 413 "request entity too large".
[rfc7252] also recommends that this response should include a size1 option (section 4) to indicate the maximum size of request entity the server is able and willing to handle, unless the server is not in a position to make this information available.
the present specification allows the server to return this response code at any time during a block1 transfer to indicate that it does not currently have the resources to store blocks for a transfer that it would intend to implement in an atomic fashion.
it also allows the server to return a 4.13 response to a request that does not employ block1 as a hint for the client to try sending block1.
finally, a 4.13 response to a request with a block1 option (control usage, see section 2.3) where the response carries a smaller szx in its block1 option is a hint to try that smaller szx.
caching considerations this specification attempts to leave a variety of implementation strategies open for caches, in particular those in caching proxies.
for example, a cache is free to cache blocks individually, but also could wait to obtain the complete representation before it serves parts of it.
partial caching may be more efficient in a cross-proxy (equivalent to a streaming http proxy).
a cached block (partial cached response) can be used in place of a complete response to satisfy a block-wise request that is presented to a cache.
note that different blocks can have different max-age values, as they are transferred at different times.
a response with a block updates the freshness of the complete representation.
individual blocks can be validated, and validating a single block validates the complete representation.
a response with a block1 option in control usage with the m bit set invalidates cached responses for the target uri.
a cache or proxy that combines responses (e.g., to split blocks in a request or increase the block size in a response, or a cross-proxy) may need to combine 2.31 and 2.01/2.04 responses; a stateless server may be responding with 2.01 only on the first block1 block transferred, which dominates any 2.04 responses for later blocks.
if-none-match only works correctly on block1 requests with (num=0) and must not be used on block1 requests with num != 0.
examples this section gives a number of short examples with message flows for a block-wise get, and for a put or post.
these examples demonstrate the basic operation, the operation in the presence of retransmissions, and examples for the operation of the block size negotiation.
in all these examples, a block option is shown in a decomposed way indicating the kind of block option (1 or 2) followed by a colon, and then the block number (num), more bit (m), and block size exponent (2**(szx+4)) separated by slashes.
for example, a block2 option value of 33 would be shown as 2:2/0/32) and a block1 option value of 59 would be shown as 1:3/1/128.
as in [rfc7252], "mid" is used as an abbreviation for "message id".
block2 examples the first example (figure 2) shows a get request that is split into three blocks.
the server proposes a block size of 128, and the client agrees.
the first two acks contain a payload of 128 bytes each, and the third ack contains a payload between 1 and 128 bytes.
all ack messages except for the last carry 64 bytes of payload; the last one carries between 1 and 64 bytes.
as it did not send a size proposal initially, the negotiation only influences the size from the second message exchange onward.
since the client already obtained both the first and second 64-byte block in the first 128-byte exchange, it goes on requesting the third 64-byte block ("2/0/64").
none of this is (or needs to be) understood by the server, which simply responds to the requests as it best can.
block1 examples the following examples demonstrate a put exchange; a post exchange looks the same, with different requirements on atomicity/idempotence.
note that, similar to get, the responses to the requests that have a more bit in the request block1 option are provisional and carry the response code 2.31 (continue); only the final response tells the client that the put succeeded.
this is of course only an acceptable behavior of the server if the potential inconsistency present during the run of the message exchange sequence does not lead to problems, e.g., because the resource being created or changed is not yet or not currently in use.
in this case, the client should continue with a smaller block size; if it does, it must adjust the block number to properly count in that smaller size.
combining block1 and block2 block options may be used in both directions of a single exchange.
the following example demonstrates a block-wise post request, resulting in a separate block-wise response.
combining observe and block2 in the following example, the server first sends a direct response (observe sequence number 62350) to the initial get request (the resulting block-wise transfer is as in figure 4 and has therefore been left out).
the second transfer is started by a 2.05 notification that contains just the first block (observe sequence number 62354); the client then goes on to obtain the rest of the blocks.
as a general comment on tokens, there is no other mention of tokens in this document, as block-wise transfers handle tokens like any other coap exchange.
as usual, the client is free to choose tokens for each exchange as it likes.)
in the following example, the client also uses early negotiation to limit the block size to 64 bytes.
the size2 and size1 options in many cases when transferring a large resource representation block by block, it is advantageous to know the total size early in the process.
some indication may be available from the maximum size estimate attribute "sz" provided in a resource description [rfc6690].
however, the size may vary dynamically, so a more up-to-date indication may be useful.
this specification defines two coap options, size1 for indicating the size of the representation transferred in requests, and size2 for indicating the size of the representation transferred in responses.
(size1 has already been defined in section 5.10.9 of [rfc7252] to provide "size information about the resource representation in a request"; however, that section only details the narrow case of indicating in 4.13 responses the maximum size of request payload that the server is able and willing to handle.
the present specification provides details about its use as a request option as well.)
the size2 option may be used for two purposes: o in a request, to ask the server to provide a size estimate along with the usual response ("size request").
for this usage, the value must be set to 0. o in a response carrying a block2 option, to indicate the current estimate the server has of the total size of the resource representation, measured in bytes ("size indication").
similarly, the size1 option may be used for two purposes: o in a request carrying a block1 option, to indicate the current estimate the client has of the total size of the resource representation, measured in bytes ("size indication").
o in a 4.13 response, to indicate the maximum size that would have been acceptable [rfc7252], measured in bytes.
apart from conveying/asking for size information, the size options have no other effect on the processing of the request or response.
if the client wants to minimize the size of the payload in the resulting response, it should add a block2 option to the request with a small block size (e.g., setting szx=0).
the size options are "elective", i.e., a client must be prepared for the server to ignore the size estimate request.
either size option must not occur more than once in a single message.
if the size estimate does not change, the indication does not need to be repeated for every block.
o the end of a block-wise transfer is governed by the m bits in the block options, _not_ by exhausting the size estimates exchanged.
o as usual for an option of type uint, the value 0 is best expressed as an empty option (0 bytes).
there is no default value for either size option.
o the size options are neither critical nor unsafe, and are marked as no-cache-key.
http-mapping considerations in this subsection, we give some brief examples of the influence that the block options might have on intermediaries that map between coap and http.
for mapping coap requests to http, the intermediary may want to map the sequence of block-wise transfers into a single http transfer.
for example, for a get request, the intermediary could perform the http request once the first block has been requested and could then fulfill all further block requests out of its cache.
a constrained implementation may not be able to cache the entire object and may use a combination of tcp flow control and (in particular if timeouts occur) http range requests to obtain the information necessary for the next block transfer at the right time.
for put or post requests, historically there was more variation in how http servers might implement ranges; recently, [rfc7233] has defined that range header fields received with a request method other than get are not to be interpreted.
so, in general, the coap-to-http intermediary will have to try sending the payload of all the blocks of a block-wise transfer for these other methods within one http request.
if enough buffering is available, this request can be started when the last coap block is received.
a constrained implementation may want to relieve its buffering by already starting to send the http request at the time the first coap block is received; any http 408 status code that indicates that the http server became impatient with the resulting transfer can then be mapped into a coap 4.08 response code (similarly, 413 maps to 4.13).
for mapping http to coap, the intermediary may want to map a single http transfer into a sequence of block-wise transfers.
if the http client is too slow delivering a request body on a put or post, the coap server might time out and return a 4.08 response code, which in turn maps well to an http 408 status code (again, 4.13 maps to 413).
http range requests received on the http side may be served out of a cache and/or mapped to get requests that request a sequence of blocks that cover the range.
(note that, while the semantics of coap 4.08 and http 408 differ, this difference is largely due to the different way the two protocols are mapped to transport.
http has an underlying tcp connection, which supplies connection state, so an http 408 status code can immediately be used to indicate that a timeout occurred during transmitting a request through that active tcp connection.
the coap 4.08 response code indicates one or more missing blocks, which may be due to timeouts or resource constraints; as there is no connection state, there is no way to deliver such a response immediately; instead, it is delivered on the next block transfer.
still, http 408 is probably the best mapping back to http, as the timeout is the most likely cause for a coap 4.08.
note that there is no way to distinguish a timeout from a missing block for a server without creating additional state, the need for which we want to avoid.)
security considerations providing access to blocks within a resource may lead to surprising vulnerabilities.
where requests are not implemented atomically, an attacker may be able to exploit a race condition or confuse a server by inducing it to use a partially updated resource representation.
partial transfers may also make certain problematic data invisible to intrusion detection systems (idss); it is recommended that an ids that analyzes resource representations transferred by coap implement the block options to gain access to entire resource representations.
still, approaches such as transferring even-numbered blocks on one path and odd-numbered blocks on another path, or even transferring blocks multiple times with different content and obtaining a different interpretation of temporal order at the ids than at the server, may prevent an ids from seeing the whole picture.
these kinds of attacks are well understood from ip fragmentation and tcp segmentation; coap does not add fundamentally new considerations.
where access to a resource is only granted to clients making use of specific security associations, all blocks of that resource must be subject to the same security checks; it must not be possible for unprotected exchanges to influence blocks of an otherwise protected resource.
as a related consideration, where object security is employed, put/post should be implemented in the atomic fashion, unless the object security operation is performed on each access and the creation of unusable resources can be tolerated.
future end-to- end security mechanisms that may be added to coap itself may have related security considerations, this includes considerations about caching of blocks in clients and in proxies (see sections 2.10 and 5 for different strategies in performing this caching); these security considerations will need to be described in the specifications of those mechanisms.
a stateless server might be susceptible to an attack where the adversary sends a block1 (e.g., put) block with a high block number: a naive implementation might exhaust its resources by creating a huge resource representation.
misleading size indications may be used by an attacker to induce buffer overflows in poor implementations, for which the usual considerations apply.
mitigating resource exhaustion attacks certain block-wise requests may induce the server to create state, e.g., to create a snapshot for the block-wise get of a fast-changing resource to enable consistent access to the same version of a resource for all blocks, or to create temporary resourcebormann & shelby standards track [page 33]rfc 7959 block-wise transfer in coap august 2016 representations that are collected until pressed into service by a final put or post with the more bit unset.
all mechanisms that induce a server to create state that cannot simply be cleaned up create opportunities for denial-of-service attacks.
servers should avoid being subject to resource exhaustion based on state created by untrusted sources.
but even if this is done, the mitigation may cause a denial-of-service to a legitimate request when it is drowned out by other state-creating requests.
wherever possible, servers should therefore minimize the opportunities to create state for untrusted sources, e.g., by using stateless approaches.
performing segmentation at the application layer is almost always better in this respect than at the transport layer or lower (ip fragmentation, adaptation-layer fragmentation), for instance, because there are application-layer semantics that can be used for mitigation or because lower layers provide security associations that can prevent attacks.
however, it is less common to apply timeouts and keepalive mechanisms at the application layer than at lower layers.
servers may want to clean up accumulated state by timing it out (cf.
response code 4.08), and clients should be prepared to run block-wise transfers in an expedient way to minimize the likelihood of running into such a timeout.
mitigating amplification attacks [rfc7252] discusses the susceptibility of coap endpoints for use in amplification attacks.
a coap server can reduce the amount of amplification it provides to an attacker by offering large resource representations only in relatively small blocks.
with this, e.g., for a 1000-byte resource, a 10-byte request might result in an 80-byte response (with a 64-byte block) instead of a 1016-byte response, considerably reducing the amplification provided.

introduction the constrained application protocol (coap) [rfc7252] is a web transfer protocol designed for constrained nodes and networks [rfc7228]; coap may be mapped from http [rfc8075].
coap specifies the use of proxies for scalability and efficiency and references dtls [rfc6347] for security.
coap-to-coap, http-to-coap, and coap-to-http proxies require dtls or tls [rfc8446] to be terminated at the proxy.
therefore, the proxy not only has access to the data required for performing the intended proxy functionality, but is also able to eavesdrop on, or manipulate any part of, the message payload and metadata in transit between the endpoints.
the proxy can also inject, delete, or reorder packets since they are no longer protected by (d)tls.
this document defines the object security for constrained restful environments (oscore) security protocol, protecting coap and coap- mappable http requests and responses end-to-end across intermediary nodes such as coap forward proxies and cross-protocol translators including http-to-coap proxies [rfc8075].
in addition to the core coap features defined in [rfc7252], oscore supports the observe [rfc7641], block-wise [rfc7959], and no-response [rfc7967] options, as well as the patch and fetch methods [rfc8132].
an analysis of end-to-end security for coap messages through some types of intermediary nodes is performed in [coap-e2e-sec].
oscore essentially protects the restful interactions: the request method, the requested resource, the message payload, etc.
(see section 4), where "restful" refers to the representational state transfer (rest) architecture [rest].
oscore protects neither the coap messaging layer nor the coap token, which may change between the endpoints; therefore, those are processed as defined in [rfc7252].
additionally, since the message formats for coap over unreliable transport [rfc7252] and for coap over reliable transport [rfc8323] differ only in terms of coap messaging layer, oscore can be applied to both unreliable and reliable transports (see figure 1).
oscore works in very constrained nodes and networks, thanks to its small message size and the restricted code and memory requirements in addition to what is required by coap.
examples of the use of oscore are given in appendix a. oscore may be used over any underlying layer, such as udp or tcp, and with non-ip transports (e.g., [coap-802.15.4]).
oscore may also be used in different ways with http.
oscore messages may be transported in http, and oscore may also be used to protect coap-mappable http messages, as described below.
it works with existing coap-to-coap forward proxies [rfc7252], but an oscore-aware proxy will be more efficient.
http-to-coap proxies [rfc8075] and coap-to-http proxies can also be used with oscore, as specified in section 11.
oscore may be used together with tls or dtls over one or more hops in the end-to-end path, e.g., transported with https in one hop and with plain coap in another hop.
the use of oscore does not affect the uri scheme; therefore, oscore can be used with any uri scheme defined for coap or http.
the application decides the conditions for which oscore is required.
oscore uses pre-shared keys that may have been established out-of- band or with a key establishment protocol (see section 3.2).
the technical solution builds on cbor object signing and encryption (cose) [rfc8152], providing end-to-end encryption, integrity, replay protection, and binding of response to request.
a compressed version of cose is used, as specified in section 6.
the use of oscore is signaled in coap with a new option (section 2), and in http with a new header field (section 11.1) and content type (section 13.5).
the solution transforms a coap/http message into an "oscore message" before sending, and vice versa after receiving.
the oscore message is a coap/http message related to the original message in the following way: the original coap/http message is translated to coap (if not already in coap) and protected in a cose object.
the encrypted message fields of this cose object are transported in the coap payload/http body of the oscore message, and the oscore option/ header field is included in the message.
a sketch of an exchange of oscore messages, in the case of the original message being coap, is provided in figure 2.
the use of oscore with http is detailed in section 11.
terminology the key words "must", "must not", "required", "shall", "shall not", "should", "should not", "recommended", "not recommended", "may", and "optional" in this document are to be interpreted as described in bcp 14 [rfc2119] [rfc8174] when, and only when, they appear in all capitals, as shown here.
readers are expected to be familiar with the terms and concepts described in coap [rfc7252], cose [rfc8152], concise binary object representation (cbor) [rfc7049], concise data definition language (cddl) [rfc8610] as summarized in appendix e, and constrained environments [rfc7228].
additional optional features include observe [rfc7641], block-wise [rfc7959], no-response [rfc7967] and coap over reliable transport [rfc8323].
the term "hop" is used to denote a particular leg in the end-to-end path.
the concept "hop-by-hop" (as in "hop-by-hop encryption" or "hop-by-hop fragmentation") opposed to "end-to-end", is used in this document to indicate that the messages are processed accordingly in the intermediaries, rather than just forwarded to the next node.
the term "stop processing" is used throughout the document to denote that the message is not passed up to the coap request/response layer (see figure 1).
the terms common context, sender context, recipient context, master secret, master salt, sender id, sender key, recipient id, recipient key, id context, and common iv are defined in section 3.1.
the oscore option is critical, safe to forward, part of the cache key, and not repeatable.
the detailed format and length is specified in section 6.
if the oscore flag bits are all zero (0x00), the option value shall be empty (option length = 0).
an endpoint receiving a coap message without payload that also contains an oscore option shall treat it as malformed and reject it.
a successful response to a request with the oscore option shall contain the oscore option.
whether error responses contain the oscore option depends on the error type (see section 8).
for coap proxy operations, see section 10.
the security context oscore requires that client and server establish a shared security context used to process the cose objects.
oscore uses cose with an authenticated encryption with associated data (aead, [rfc5116]) algorithm for protecting message data between a client and a server.
in this section, we define the security context and how it is derived in client and server based on a shared secret and a key derivation function.
security context definition the security context is the set of information elements necessary to carry out the cryptographic operations in oscore.
for each endpoint, the security context is composed of a "common context", a "sender context", and a "recipient context".
the endpoints protect messages to send using the sender context and verify messages received using the recipient context; both contexts being derived from the common context and other data.
clients and servers need to be able to retrieve the correct security context to use.
an endpoint uses its sender id (sid) to derive its sender context; the other endpoint uses the same id, now called recipient id (rid), to derive its recipient context.
in communication between two endpoints, the sender context of one endpoint matches the recipient context of the other endpoint, and vice versa.
thus, the two security contexts identified by the same ids in the two endpoints are not the same, but they are partly mirrored.
retrieval and use of the security context are shown in figure 4.
the common context contains the following parameters: o aead algorithm.
the cose aead algorithm to use for encryption.
o hkdf algorithm.
an hmac-based key derivation function (hkdf, [rfc5869]) used to derive the sender key, recipient key, and common iv.
o master secret.
variable length, random byte string (see section 12.3) used to derive aead keys and common iv.
o master salt.
optional variable-length byte string containing the salt used to derive aead keys and common iv.
o id context.
optional variable-length byte string providing additional information to identify the common context and to derive aead keys and common iv.
the use of id context is described in section 5.1. o common iv.
byte string derived from the master secret, master salt, and id context.
used to generate the aead nonce (see section 5.2).
same length as the nonce of the aead algorithm.
the sender context contains the following parameters: o sender id.
byte string used to identify the sender context, to derive aead keys and common iv, and to contribute to the uniqueness of aead nonces.
maximum length is determined by the aead algorithm.
o sender key.
byte string containing the symmetric aead key to protect messages to send.
derived from common context and sender id.
length is determined by the aead algorithm.
o sender sequence number.
non-negative integer used by the sender to enumerate requests and certain responses, e.g., observe notifications.
used as "partial iv" [rfc8152] to generate unique aead nonces.
maximum value is determined by the aead algorithm.
initialization is described in section 3.2.2.
the recipient context contains the following parameters: o recipient id.
byte string used to identify the recipient context, to derive aead keys and common iv, and to contribute to the uniqueness of aead nonces.
maximum length is determined by the aead algorithm.
o recipient key.
byte string containing the symmetric aead key to verify messages received.
derived from common context and recipient id.
length is determined by the aead algorithm.
o replay window (server only).
the replay window used to verify requests received.
replay protection is described in section 7.4 and section 3.2.2.
all parameters except sender sequence number and replay window are immutable once the security context is established.
an endpoint may free up memory by not storing the common iv, sender key, and recipient key, deriving them when needed.
alternatively, an endpoint may free up memory by not storing the master secret and master salt after the other parameters have been derived.
endpoints may operate as both client and server and use the same security context for those roles.
independent of being client or server, the endpoint protects messages to send using its sender context, and verifies messages received using its recipient context.
the endpoints must not change the sender/recipient id when changing roles.
in other words, changing the roles does not change the set of aead keys to be used.
establishment of security context parameters each endpoint derives the parameters in the security context from a small set of input parameters.
the following input parameters shall be preestablished: o master secret o sender id o recipient id the following input parameters may be preestablished.
in case any of these parameters is not preestablished, the default value indicated below is used: o aead algorithm * default is aes-ccm-16-64-128 (cose algorithm encoding: 10) o master salt * default is the empty byte stringselander, et al.
o hkdf algorithm * default is hkdf sha-256 o replay window * the default mechanism is an anti-replay sliding window (see section 4.1.2.6 of [rfc6347] with a window size of 32 all input parameters need to be known and agreed on by both endpoints, but the replay window may be different in the two endpoints.
the way the input parameters are preestablished is application specific.
considerations of security context establishment are given in section 12.2 and examples of deploying oscore in appendix b.
derivation of sender key, recipient key, and common iv the hkdf must be one of the hmac-based hkdf [rfc5869] algorithms defined for cose [rfc8152].
hkdf sha-256 is mandatory to implement.
the security context parameters sender key, recipient key, and common iv shall be derived from the input parameters using the hkdf, which consists of the composition of the hkdf-extract and hkdf-expand steps [rfc5869]: output parameter = hkdf(salt, ikm, info, l) where: o salt is the master salt as defined above o ikm is the master secret as defined above o info is the serialization of a cbor array consisting of (the notation follows [rfc8610] as summarized in appendix e): info = [ id : bstr, id_context : bstr / nil, alg_aead : int / tstr, type : tstr, l : uint, ]selander, et al.
where: o id is the sender id or recipient id when deriving sender key and recipient key, respectively, and the empty byte string when deriving the common iv.
o id_context is the id context, or nil if id context is not provided.
o alg_aead is the aead algorithm, encoded as defined in [rfc8152].
o type is "key" or "iv".
the label is an ascii string and does not include a trailing nul byte.
o l is the size of the key/nonce for the aead algorithm used, in bytes.
for example, if the algorithm aes-ccm-16-64-128 (see section 10.2 in [rfc8152]) is used, the integer value for alg_aead is 10, the value for l is 16 for keys and 13 for the common iv.
assuming use of the default algorithms hkdf sha-256 and aes-ccm-16-64-128, the extract phase of hkdf produces a pseudorandom key (prk) as follows: prk = hmac-sha-256(master salt, master secret) and as l is smaller than the hash function output size, the expand phase of hkdf consists of a single hmac invocation; therefore, the sender key, recipient key, and common iv are the first 16 or 13 bytes of output parameter = hmac-sha-256(prk, info || 0x01) where different values of info are used for each derived parameter and where || denotes byte string concatenation.
note that [rfc5869] specifies that if the salt is not provided, it is set to a string of zeros.
for implementation purposes, not providing the salt is the same as setting the salt to the empty byte string.
oscore sets the salt default value to empty byte string, which is converted to a string of zeroes (see section 2.2 of [rfc5869]).
initial sequence numbers and replay window the sender sequence number is initialized to 0.
the supported types of replay protection and replay window size is application specific and depends on how oscore is transported (see section 7.4).
the default mechanism is the anti-replay window of received messages used by ipsec ah/esp and dtls (see section 4.1.2.6 of [rfc6347]) with a window size of 32.
requirements on the security context parameters to ensure unique sender keys, the quartet (master secret, master salt, id context, sender id) must be unique, i.e., the pair (id context, sender id) shall be unique in the set of all security contexts using the same master secret and master salt.
this means that sender id shall be unique in the set of all security contexts using the same master secret, master salt, and id context; such a requirement guarantees unique (key, nonce) pairs for the aead.
different methods can be used to assign sender ids: a protocol that allows the parties to negotiate locally unique identifiers, a trusted third party (e.g., [ace-oauth]), or the identifiers can be assigned out-of-band.
the sender ids can be very short (note that the empty string is a legitimate value).
the maximum length of sender id in bytes equals the length of the aead nonce minus 6, see section 5.2.
for aes-ccm-16-64-128 the maximum length of sender id is 7 bytes.
to simplify retrieval of the right recipient context, the recipient id should be unique in the sets of all recipient contexts used by an endpoint.
if an endpoint has the same recipient id with different recipient contexts, i.e., the recipient contexts are derived from different common contexts, then the endpoint may need to try multiple times before verifying the right security context associated to the recipient id.
the id context is used to distinguish between security contexts.
the methods used for assigning sender id can also be used for assigning the id context.
additionally, the id context can be used to introduce randomness into new sender and recipient contexts (see appendix b.2).
id context can be arbitrarily long.
protected message fields oscore transforms a coap message (which may have been generated from an http message) into an oscore message, and vice versa.
oscore protects as much of the original message as possible while still allowing certain proxy operations (see sections 10 and 11).
this section defines how oscore protects the message fields and transfers them end-to-end between client and server (in any direction).
the remainder of this section and later sections focus on the behavior in terms of coap messages.
if http is used for a particular hop in the end-to-end path, then this section applies to the conceptual coap message that is mappable to/from the original http message as discussed in section 11.
that is, an http message is conceptually transformed to a coap message and then to an oscore message, and similarly in the reverse direction.
an actual implementation might translate directly from http to oscore without the intervening coap representation.
protection of signaling messages (section 5 of [rfc8323]) is specified in section 4.3.
the other parts of this section target request/response messages.
message fields of the coap message may be protected end-to-end between coap client and coap server in different ways: o class e: encrypted and integrity protected, o class i: integrity protected only, or o class u: unprotected.
the sending endpoint shall transfer class e message fields in the ciphertext of the cose object in the oscore message.
the sending endpoint shall include class i message fields in the aad of the aead algorithm, allowing the receiving endpoint to detect if the value has changed in transfer.
class u message fields shall not be protected in transfer.
class i and class u message field values are transferred in the header or options part of the oscore message, which is visible to proxies.
message fields not visible to proxies, i.e., transported in the ciphertext of the cose object, are called "inner" (class e).
message fields transferred in the header or options part of the oscore message, which is visible to proxies, are called "outer" (class i or class u).
there are currently no class i options defined.
an oscore message may contain both an inner and an outer instance of a certain coap message field.
inner message fields are intended for the receiving endpoint, whereas outer message fields are used to enable proxy operations.
coap options a summary of how options are protected is shown in figure 5.
note that some options may have both inner and outer message fields, which are protected accordingly.
certain options require special processing as is described in section 4.1.3.
options that are unknown or for which oscore processing is not defined shall be processed as class e (and no special processing).
specifications of new coap options should define how they are processed with oscore.
a new coap option should be of class e unless it requires proxy processing.
if a new coap option is of class u, the potential issues with the option being unprotected should be documented (see appendix d.5).
inner options inner option message fields (class e) are used to communicate directly with the other endpoint.
the sending endpoint shall write the inner option message fields present in the original coap message into the plaintext of the cose object (section 5.3) and then remove the inner option message fields from the oscore message.
the processing of inner option message fields by the receiving endpoint is specified in sections 8.2 and 8.4.
outer options outer option message fields (class u or i) are used to support proxy operations, see appendix d.2.
the sending endpoint shall include the outer option message field present in the original message in the options part of the oscore message.
all outer option message fields, including the oscore option, shall be encoded as described in section 3.1 of [rfc7252], where the delta is the difference from the previously included instance of outer option message field.
the processing of outer options by the receiving endpoint is specified in sections 8.2 and 8.4.
a procedure for integrity-protection-only of class i option message fields is specified in section 5.4.
specifications that introduce repeatable class i options must specify that proxies must not change the order of the instances of such an option in the coap message.
note: there are currently no class i option message fields defined.
special options some options require special processing as specified in this section.
max-age an inner max-age message field is used to indicate the maximum time a response may be cached by the client (as defined in [rfc7252]), end- to-end from the server to the client, taking into account that the option is not accessible to proxies.
the inner max-age shall be processed by oscore as a normal inner option, specified in section 4.1.1.
an outer max-age message field is used to avoid unnecessary caching of error responses caused by oscore processing at oscore-unaware intermediary nodes.
a server may set a class u max-age message field with value zero to such error responses, described in sections 7.4, 8.2, and 8.4, since these error responses are cacheable, but subsequent oscore requests would never create a hit in the intermediary node caching it.
setting the outer max-age to zero relieves the intermediary from uselessly caching responses.
successful oscore responses do not need to include an outer max-age option.
except when the observe option (see section 4.1.3.5) is used, responses appear to the oscore-unaware intermediary as 2.04 (changed) responses, which are non-cacheable (see section 4.2).
for observe responses, which are cacheable, an outer max-age option with value 0 may be used to avoid unnecessary proxy caching.
the outer max-age message field is processed according to section 4.1.2.
uri-host and uri-port when the uri-host and uri-port are set to their default values (see section 5.10.1 [rfc7252]), they are omitted from the message (section 5.4.4 of [rfc7252]), which is favorable both for overhead and privacy.
in order to support forward proxy operations, proxy-scheme, uri-host, and uri-port need to be class u.
for the use of proxy-uri, see section 4.1.3.3.
manipulation of unprotected message fields (including uri-host, uri- port, destination ip/port or request scheme) must not lead to an oscore message becoming verified by an unintended server.
different servers shall have different security contexts.
proxy-uri when proxy-uri is present, the client shall first decompose the proxy-uri value of the original coap message into the proxy-scheme, uri-host, uri-port, uri-path, and uri-query options according to section 6.4 of [rfc7252].
uri-path and uri-query are class e options and shall be protected and processed as inner options (section 4.1.1).
the proxy-uri option of the oscore message shall be set to the composition of proxy-scheme, uri-host, and uri-port options as specified in section 6.5 of [rfc7252] and processed as an outer option of class u (section 4.1.2).
note that replacing the proxy-uri value with the proxy-scheme and uri-* options works by design for all coap uris (see section 6 of [rfc7252]).
oscore-aware http servers should not use the userinfo component of the http uri (as defined in section 3.2.1 of [rfc3986]), so that this type of replacement is possible in the presence of coap- to-http proxies (see section 11.2).
in future specifications of cross-protocol proxying behavior using different uri structures, it is expected that the authors will create uri-* options that allow decomposing the proxy-uri, and specifying the oscore processing.
an example of how proxy-uri is processed is given here.
assume that the original coap message contains: o proxy-uri = "coap://example.com/resource?q=1" during oscore processing, proxy-uri is split into: o proxy-scheme = "coap" o uri-host = "example.com" o uri-port = "5683" (default) o uri-path = "resource" o uri-query = "q=1"selander, et al.
uri-path and uri-query follow the processing defined in section 4.1.1; thus, they are encrypted and transported in the cose object: o uri-path = "resource" o uri-query = "q=1" the remaining options are composed into the proxy-uri included in the options part of the oscore message, which has value: o proxy-uri = "coap://example.com" see sections 6.1 and 12.6 of [rfc7252] for more details.
the block options block-wise [rfc7959] is an optional feature.
an implementation may support coap [rfc7252] and the oscore option without supporting block-wise transfers.
the block options (block1, block2, size1, size2), when inner message fields, provide secure message segmentation such that each segment can be verified.
the block options, when outer message fields, enable hop-by-hop fragmentation of the oscore message.
inner and outer block processing may have different performance properties depending on the underlying transport.
the end-to-end integrity of the message can be verified both in case of inner and outer block-wise transfers, provided all blocks are received.
inner block options the sending coap endpoint may fragment a coap message as defined in [rfc7959] before the message is processed by oscore.
in this case, the block options shall be processed by oscore as normal inner options (section 4.1.1).
the receiving coap endpoint shall process the oscore message before processing block-wise as defined in [rfc7959].
outer block options proxies may fragment an oscore message using [rfc7959] by introducing block option message fields that are outer (section 4.1.2).
note that the outer block options are neither encrypted nor integrity protected.
as a consequence, a proxy can maliciously inject block fragments indefinitely, since the receiving endpoint needs to receive the last block (see [rfc7959]) to be able to compose the oscore message and verify its integrity.
therefore, applications supporting oscore and [rfc7959] must specify a security policy defining aselander, et al.
maximum unfragmented message size (max_unfragmented_size) considering the maximum size of message that can be handled by the endpoints.
messages exceeding this size should be fragmented by the sending endpoint using inner block options (section 4.1.3.4.1).
an endpoint receiving an oscore message with an outer block option shall first process this option according to [rfc7959], until all blocks of the oscore message have been received or the cumulated message size of the blocks exceeds max_unfragmented_size.
in the former case, the processing of the oscore message continues as defined in this document.
in the latter case, the message shall be discarded.
because of encryption of uri-path and uri-query, messages to the same server may, from the point of view of a proxy, look like they also target the same resource.
a proxy should mitigate a potential mix-up of blocks from concurrent requests to the same server, for example, using the request-tag processing specified in section 3.3.2 of [coap-echo-req-tag].
observe observe [rfc7641] is an optional feature.
an implementation may support coap [rfc7252] and the oscore option without supporting [rfc7641], in which case the observe-related processing can be omitted.
the support for observe [rfc7641] with oscore targets the requirements on forwarding of section 2.2.1 of [coap-e2e-sec], i.e., that observations go through intermediary nodes, as illustrated in figure 8 of [rfc7641].
inner observe shall be used to protect the value of the observe option between the endpoints.
outer observe shall be used to support forwarding by intermediary nodes.
the server shall include a new partial iv (see section 5) in responses (with or without the observe option) to observe registrations, except for the first response where partial iv may be omitted.
for cancellations, section 3.6 of [rfc7641] specifies that all options must be identical to those in the registration request except for the observe option and the set of etag options.
for oscore messages, this matching is to be done to the options in the decrypted message.
[rfc7252] does not specify how the server should act upon receiving the same token in different requests.
when using oscore, the server should not remove an active observation just because it receives a request with the same token.
since post with the observe option is not defined, for messages with the observe option, the outer code must be set to 0.05 (fetch) for requests and to 2.05 (content) for responses (see section 4.2).
registrations and cancellations the inner and outer observe options in the request must contain the observe value of the original coap request; 0 (registration) or 1 (cancellation).
every time a client issues a new request with the observe option, a new partial iv must be used (see section 5), and so the payload and oscore option are changed.
the server uses the partial iv of the new request as the 'request_piv' of all associated notifications (see section 5.4).
intermediaries are not assumed to have access to the oscore security context used by the endpoints; thus, they cannot make requests or transform responses with the oscore option that pass verification (at the receiving endpoint) as having come from the other endpoint.
this has the following consequences and limitations for observe operations.
o an intermediary node removing the outer observe 0 option does not change the registration request to a request without the observe option (see section 2 of [rfc7641]).
instead other means for cancellation may be used as described in section 3.6 of [rfc7641].
o an intermediary node is not able to transform a normal response into an oscore-protected observe notification (see figure 7 of [rfc7641]) that verifies as coming from the server.
o an intermediary node is not able to initiate an oscore protected observe registration (observe option with value 0) that verifies as coming from the client.
an oscore-aware intermediary shall not initiate registrations of observations (see section 10).
if an oscore-unaware proxy resends an old registration message from a client, the replay protection mechanism in the server will be triggered.
to prevent this from resulting in the oscore-unaware proxy canceling the registration, a server may respond to a replayed registration request with a replay of a cached notification.
alternatively, the server may send a new notification.
o an intermediary node is not able to initiate an oscore-protected observe cancellation (observe option with value 1) that verifies as coming from the client.
an application may decide to allow intermediaries to cancel observe registrations, e.g., to send the observe option with value 1 (see section 3.6 of [rfc7641]); however, that can also be done with other methods, e.g., by sending a rst message.
this is out of scope for this specification.
notifications if the server accepts an observe registration, a partial iv must be included in all notifications (both successful and error), except for the first one where the partial iv may be omitted.
to protect against replay, the client shall maintain a notification number for each observation it registers.
the notification number is a non- negative integer containing the largest partial iv of the received notifications for the associated observe registration.
further details of replay protection of notifications are specified in section 7.4.1.
for notifications, the inner observe option value must be empty (see section 3.2 of [rfc7252]).
the outer observe option in a notification is needed for intermediary nodes to allow multiple responses to one request, and it may be set to the value of the observe option in the original coap message.
the client performs ordering of notifications and replay protection by comparing their partial ivs and shall ignore the outer observe option value.
if the client receives a response to an observe request without an inner observe option, then it verifies the response as a non-observe response, as specified in section 8.4.
if the client receives a response to a non-observe request with an inner observe option, then it stops processing the message, as specified in section 8.4.
a client must consider the notification with the highest partial iv as the freshest, regardless of the order of arrival.
in order to support existing observe implementations, the oscore client implementation may set the observe option value to the three least significant bytes of the partial iv.
implementations need to make sure that the notification without partial iv is considered the oldest.
no-response no-response [rfc7967] is an optional feature used by the client to communicate its disinterest in certain classes of responses to a particular request.
an implementation may support [rfc7252] and the oscore option without supporting [rfc7967].
if used, no-response must be inner.
the inner no-response shall be processed by oscore as specified in section 4.1.1.
the outer option should not be present.
the server shall ignore the outer no-response option.
the client may set the outer no-response value to 26 (suppress all known codes) if the inner value is set to 26.
the client must be prepared to receive and discard 5.04 (gateway timeout) error messages from intermediaries potentially resulting from destination time out due to no response.
oscore the oscore option is only defined to be present in oscore messages as an indication that oscore processing has been performed.
the content in the oscore option is neither encrypted nor integrity protected as a whole, but some part of the content of this option is protected (see section 5.4).
nested use of oscore is not supported: if oscore processing detects an oscore option in the original coap message, then processing shall be stopped.
coap header fields and payload a summary of how the coap header fields and payload are protected is shown in figure 6, including fields specific to coap over udp and coap over tcp (marked accordingly in the table).
most coap header fields (i.e., the message fields in the fixed 4-byte header) are required to be read and/or changed by coap proxies; thus, they cannot, in general, be protected end-to-end from one endpoint to the other.
as mentioned in section 1, oscore protects the coap request/response layer only and not the coap messaging layer (section 2 of [rfc7252]), so fields such as type and message id are not protected with oscore.
the coap header field code is protected by oscore.
code shall be encrypted and integrity protected (class e) to prevent an intermediary from eavesdropping on or manipulating it (e.g., changing from get to delete).
the sending endpoint shall write the code of the original coap message into the plaintext of the cose object (see section 5.3).
after that, the sending endpoint writes an outer code to the oscore message.
with one exception (see section 4.1.3.5), the outer code shall be set to 0.02 (post) for requests and to 2.04 (changed) for responses.
the receiving endpoint shall discard the outer code in the oscore message and write the code of the cose object plaintext (section 5.3) into the decrypted coap message.
the other currently defined coap header fields are unprotected (class u).
the sending endpoint shall write all other header fields of the original message into the header of the oscore message.
the receiving endpoint shall write the header fields from the received oscore message into the header of the decrypted coap message.
the coap payload, if present in the original coap message, shall be encrypted and integrity protected; thus, it is an inner message field.
the sending endpoint writes the payload of the original coap message into the plaintext (section 5.3) input to the cose object.
the receiving endpoint verifies and decrypts the cose object, and it recreates the payload of the original coap message.
signaling messages signaling messages (coap code 7.00-7.31) were introduced to exchange information related to an underlying transport connection in the specific case of coap over reliable transports [rfc8323].
oscore may be used to protect signaling if the endpoints for oscore coincide with the endpoints for the signaling message.
if oscore is used to protect signaling then: o to comply with [rfc8323], an initial empty capabilities and settings message (csm) shall be sent.
the subsequent signaling message shall be protected.
o signaling messages shall be protected as coap request messages, except in the case in which the signaling message is a response to a previous signaling message; then it shall be protected as a coap response message.
for example, 7.02 (ping) is protected as a coap request and 7.03 (pong) as a coap response.
o the outer code for signaling messages shall be set to 0.02 (post), unless it is a response to a previous signaling message, in which case it shall be set to 2.04 (changed).
o all signaling options, except the oscore option, shall be inner (class e).
note: option numbers for signaling messages are specific to the coap code (see section 5.2 of [rfc8323]).
if oscore is not used to protect signaling, signaling messages shall be unaltered by oscore.
the cose object this section defines how to use cose [rfc8152] to wrap and protect data in the original message.
oscore uses the untagged cose_encrypt0 structure (see section 5.2 of [rfc8152]) with an aead algorithm.
the aead key lengths, aead nonce length, and maximum sender sequence number are algorithm dependent.
the aead algorithm aes-ccm-16-64-128 defined in section 10.2 of [rfc8152] is mandatory to implement.
for aes-ccm-16-64-128, the length of sender key and recipient key is 128 bits; the length of aead nonce and common iv is 13 bytes.
the maximum sender sequence number is specified in section 12.
as specified in [rfc5116], plaintext denotes the data that is to be encrypted and integrity protected, and additional authenticated data (aad) denotes the data that is to be integrity protected only.
the cose object shall be a cose_encrypt0 object with fields defined as follows: o the 'protected' field is empty.
o the 'unprotected' field includes: * the 'partial iv' parameter.
the value is set to the sender sequence number.
all leading bytes of value zero shall be removed when encoding the partial iv, except in the case of partial iv value 0, which is encoded to the byte string 0x00.
this parameter shall be present in requests and will not typically be present in responses (for two exceptions, see observe notifications (section 4.1.3.5.2) and replay window synchronization (appendix b.1.2)).
* the 'kid' parameter.
the value is set to the sender id.
this parameter shall be present in requests and will not typically be present in responses.
an example where the sender id is included in a response is the extension of oscore to group communication [group-oscore].
* optionally, a 'kid context' parameter (see section 5.1).
this parameter may be present in requests and, if so, must contain an id context (see section 3.1).
this parameter should not be present in responses: an example of how 'kid context' can be used in responses is given in appendix b.2.
if 'kid context' is present in the request, then the server shall use a security context with that id context when verifying the request.
o the 'ciphertext' field is computed from the secret key (sender key or recipient key), aead nonce (see section 5.2), plaintext (see section 5.3), and the aad (see section 5.4) following section 5.2 of [rfc8152].
the encryption process is described in section 5.3 of [rfc8152].
id context and 'kid context' for certain use cases, e.g., deployments where the same sender id is used with multiple contexts, it is possible (and sometimes necessary, see section 3.3) for the client to use an id context to distinguish the security contexts (see section 3.1).
for example: o if the client has a unique identifier in some namespace, then that identifier can be used as id context.
o the id context may be used to add randomness into new sender and recipient contexts, see appendix b.2.
o in the case of group communication [group-oscore], a group identifier is used as id context to enable different security contexts for a server belonging to multiple groups.
the sender id and id context are used to establish the necessary input parameters and in the derivation of the security context (see section 3.2).
while the 'kid' parameter is used to transport the sender id, the new cose header parameter 'kid context' is used to transport the id context in requests, see figure 7.
note that since the error is unprotected, it may have been spoofed and the real response blocked by an on-path attacker.
aead nonce the high-level design of the aead nonce follows section 4.4 of [iv-gen].
note that in this specification, only aead algorithms that use nonces equal or greater than 7 bytes are supported.
the nonce construction with s, id_piv, and piv together with endpoint-unique ids and encryption keys makes it easy to verify that the nonces used with a specific key will be unique, see appendix d.4.
if the partial iv is not present in a response, the nonce from the request is used.
for responses that are not notifications (i.e., when there is a single response to a request), the request and the response should typically use the same nonce to reduce message overhead.
both alternatives provide all the required securityselander, et al.
properties, see section 7.4 and appendix d.4.
another non-observe scenario where a partial iv is included in a response is when the server is unable to perform replay protection, see appendix b.1.2.
for processing instructions see section 8.
the options are encoded as described in section 3.1 of [rfc7252], where the delta is the difference from the previously included instance of class e option; and o the payload of original coap message, if present, and in that case prefixed by the one-byte payload marker (0xff).
note: the plaintext contains all coap data that needs to be encrypted end-to-end between the endpoints.
additional authenticated data the external_aad shall be a cbor array wrapped in a bstr object as defined below, following the notation of [rfc8610] as summarized in appendix e: external_aad = bstr .cbor aad_array aad_array = [ oscore_version : uint, algorithms : [ alg_aead : int / tstr ], request_kid : bstr, request_piv : bstr, options : bstr, ] where: o oscore_version: contains the oscore version number.
implementations of this specification must set this field to 1.
other values are reserved for future versions.
o algorithms: contains (for extensibility) an array of algorithms, according to this specification only containing alg_aead.
o alg_aead: contains the aead algorithm from the security context used for the exchange (see section 3.1).
o request_kid: contains the value of the 'kid' in the cose object of the request (see section 5).
o request_piv: contains the value of the 'partial iv' in the cose object of the request (see section 5).
o options: contains the class i options (see section 4.1.2) present in the original coap message encoded as described in section 3.1 of [rfc7252], where the delta is the difference from the previously included instance of class i option.
the oscore_version and algorithms parameters are established out-of- band; thus, they are not transported in oscore, but the external_aad allows to verify that they are the same in both endpoints.
note: the format of the external_aad is, for simplicity, the same for requests and responses, although some parameters, e.g., request_kid, need not be integrity protected in all requests.
the aad is composed from the external_aad as described in section 5.3 of [rfc8152] (the notation follows [rfc8610] as summarized in appendix e): aad = enc_structure = [ "encrypt0", h'', external_aad ] the following is an example of aad constructed using aead algorithm = aes-ccm-16-64-128 (10), request_kid = 0x00, request_piv = 0x25 and no class i options: o oscore_version: 0x01 (1 byte) o algorithms: 0x810a (2 bytes) o request_kid: 0x00 (1 byte) o request_piv: 0x25 (1 byte) o options: 0x (0 bytes) o aad_array: 0x8501810a4100412540 (9 bytes) o external_aad: 0x498501810a4100412540 (10 bytes) o aad: 0x8368456e63727970743040498501810a4100412540 (21 bytes) note that the aad consists of a fixed string of 11 bytes concatenated with the external_aad.
oscore header compression the concise binary object representation (cbor) [rfc7049] combines very small message sizes with extensibility.
the cbor object signing and encryption (cose) [rfc8152] uses cbor to create compact encoding of signed and encrypted data.
however, cose is constructed toselander, et al.
support a large number of different stateless use cases and is not fully optimized for use as a stateful security protocol, leading to a larger than necessary message expansion.
in this section, we define a stateless header compression mechanism, simply removing redundant information from the cose objects, which significantly reduces the per-packet overhead.
the result of applying this mechanism to a cose object is called the "compressed cose object".
the cose_encrypt0 object used in oscore is transported in the oscore option and in the payload.
the payload contains the ciphertext of the cose object.
the headers of the cose object are compactly encoded as described in the next section.
the values n = 6 and n = 7 are reserved.
* the fourth least significant bit is the 'kid' flag, k. it is set to 1 if 'kid' is present in the compressed cose object.
* the fifth least significant bit is the 'kid context' flag, h. it is set to 1 if the compressed cose object contains a 'kid context' (see section 5.1).
* the sixth-to-eighth least significant bits are reserved for future use.
these bits shall be set to zero when not in use.
according to this specification, if any of these bits are set to 1, the message is considered to be malformed and decompression fails as specified in item 2 of section 8.2.
the flag bits are registered in the "oscore flag bits" registry specified in section 13.7. o the following n bytes encode the value of the partial iv, if the partial iv is present (n > 0).
o the following 1 byte encodes the length s of the 'kid context' (section 5.1), if the 'kid context' flag is set (h = 1).
o the following s bytes encode the 'kid context', if the 'kid context' flag is set (h = 1).
o the remaining bytes encode the value of the 'kid', if the 'kid' is present (k = 1).
note that the 'kid' must be the last field of the oscore option value, even in the case in which reserved bits are used and additional fields are added to it.
the length of the oscore option thus depends on the presence and length of partial iv, 'kid context', 'kid', as specified in this section, and on the presence and length of additional parameters, as defined in the future documents registering those parameters.
encoding of the oscore payload the payload of the oscore message shall encode the ciphertext of the cose object.
examples of compressed cose objects this section covers a list of oscore header compression examples for requests and responses.
the examples assume the cose_encrypt0 object is set (which means the coap message and cryptographic material is known).
note that the full coap unprotected message, as well as the full security context, is not reported in the examples, but only the input necessary to the compression mechanism, i.e., the cose_encrypt0 object.
the output is the compressed cose object as defined in section 6, divided into two parts, since the object is transported in two coap fields: the oscore option and payload.
request with ciphertext = 0xaea0155667924dff8a24e4cb35b9, kid = 0x25, and partial iv = 0x05 before compression (24 bytes): [ h'', { 4:h'25', 6:h'05' }, h'aea0155667924dff8a24e4cb35b9', ] after compression (17 bytes): flag byte: 0b00001001 = 0x09 (1 byte) option value: 0x090525 (3 bytes) payload: 0xaea0155667924dff8a24e4cb35b9 (14 bytes) 2.
request with ciphertext = 0xaea0155667924dff8a24e4cb35b9, kid = empty string, and partial iv = 0x00 before compression (23 bytes): [ h'', { 4:h'', 6:h'00' }, h'aea0155667924dff8a24e4cb35b9', ] after compression (16 bytes): flag byte: 0b00001001 = 0x09 (1 byte) option value: 0x0900 (2 bytes) payload: 0xaea0155667924dff8a24e4cb35b9 (14 bytes) 3.
request with ciphertext = 0xaea0155667924dff8a24e4cb35b9, kid = empty string, partial iv = 0x05, and kid context = 0x44616c656b before compression (30 bytes): [ h'', { 4:h'', 6:h'05', 10:h'44616c656b' }, h'aea0155667924dff8a24e4cb35b9', ]selander, et al.
after compression (22 bytes): flag byte: 0b00011001 = 0x19 (1 byte) option value: 0x19050544616c656b (8 bytes) payload: 0xae a0155667924dff8a24e4cb35b9 (14 bytes) 4.
response with ciphertext = 0xaea0155667924dff8a24e4cb35b9 and no partial iv before compression (18 bytes): [ h'', {}, h'aea0155667924dff8a24e4cb35b9', ] after compression (14 bytes): flag byte: 0b00000000 = 0x00 (1 byte) option value: 0x (0 bytes) payload: 0xaea0155667924dff8a24e4cb35b9 (14 bytes) 5.
response with ciphertext = 0xaea0155667924dff8a24e4cb35b9 and partial iv = 0x07 before compression (21 bytes): [ h'', { 6:h'07' }, h'aea0155667924dff8a24e4cb35b9', ] after compression (16 bytes): flag byte: 0b00000001 = 0x01 (1 byte) option value: 0x0107 (2 bytes) payload: 0xaea0155667924dff8a24e4cb35b9 (14 bytes)selander, et al.
message binding, sequence numbers, freshness, and replay protection7.1.
message binding in order to prevent response delay and mismatch attacks [coap-actuators] from on-path attackers and compromised intermediaries, oscore binds responses to the requests by including the 'kid' and partial iv of the request in the aad of the response.
therefore, the server needs to store the 'kid' and partial iv of the request until all responses have been sent.
sequence numbers an aead nonce must not be used more than once per aead key.
the uniqueness of (key, nonce) pairs is shown in appendix d.4, and in particular depends on a correct usage of partial ivs (which encode the sender sequence numbers, see section 5).
if messages are processed concurrently, the operation of reading and increasing the sender sequence number must be atomic.
maximum sequence number the maximum sender sequence number is algorithm dependent (see section 12) and shall be less than 2^40.
if the sender sequence number exceeds the maximum, the endpoint must not process any more messages with the given sender context.
if necessary, the endpoint should acquire a new security context before this happens.
the latter is out of scope of this document.
freshness for requests, oscore provides only the guarantee that the request is not older than the security context.
for applications having stronger demands on request freshness (e.g., control of actuators), oscore needs to be augmented with mechanisms providing freshness (for example, as specified in [coap-echo-req-tag]).
assuming an honest server (see appendix d), the message binding guarantees that a response is not older than its request.
for responses that are not notifications (i.e., when there is a single response to a request), this gives absolute freshness.
for notifications, the absolute freshness gets weaker with time, and it is recommended that the client regularly re-register the observation.
note that the message binding does not guarantee that a misbehaving server created the response before receiving the request, i.e., it does not verify server aliveness.
for requests and notifications, oscore also provides relative freshness in the sense that the received partial iv allows a recipient to determine the relative order of requests or responses.
replay protection in order to protect from replay of requests, the server's recipient context includes a replay window.
a server shall verify that the sender sequence number received in the 'partial iv' parameter of the cose object (see section 6.1) has not been received before.
if this verification fails, the server shall stop processing the message, and it may optionally respond with a 4.01 (unauthorized) error message.
also, the server may set an outer max-age option with value zero to inform any intermediary that the response is not to be cached.
the diagnostic payload may contain the string "replay detected".
the size and type of the replay window depends on the use case and the protocol with which the oscore message is transported.
in case of reliable and ordered transport from endpoint to endpoint, e.g., tcp, the server may just store the last received partial iv and require that newly received partial ivs equal the last received partial iv + 1.
however, in the case of mixed reliable and unreliable transports and where messages may be lost, such a replay mechanism may be too restrictive and the default replay window may be more suitable (see section 3.2.2).
responses (with or without partial iv) are protected against replay as they are bound to the request and the fact that only a single response is accepted.
in this case the partial iv is not used for replay protection of responses.
the operation of validating the partial iv and updating the replay protection must be atomic.
replay protection of notifications the following applies additionally when the observe option is supported.
the notification number (see section 4.1.3.5.2) is initialized to the partial iv of the first successfully verified notification in response to the registration request.
a client must only accept at most one observe notification without partial iv, and treat it as the oldest notification received.
a client receiving a notification containing a partial iv shall compare the partial iv with the notification number associated to that observe registration.
the client must stop processing notifications with a partial iv that hasselander, et al.
been previously received.
applications may decide that a client only processes notifications that have a greater partial iv than the notification number.
if the verification of the response succeeds, and the received partial iv was greater than the notification number, then the client shall overwrite the corresponding notification number with the received partial iv.
losing part of the context state to prevent reuse of an aead nonce with the same aead key or the acceptance of replayed messages, an endpoint needs to handle the situation of losing rapidly changing parts of the context, such as the sender sequence number and replay window.
these are typically stored in ram and therefore lost in the case of, e.g., an unplanned reboot.
there are different alternatives to recover, for example: 1.
the endpoints can reuse an existing security context after updating the mutable parts of the security context (sender sequence number and replay window).
this requires that the mutable parts of the security context are available throughout the lifetime of the device or that the device can establish a fresh security context after loss of mutable security context data.
examples are given based on careful use of nonvolatile memory, see appendix b.1.1 and the use of the echo option, see appendix b.1.2.
if an endpoint makes use of a partial security context stored in nonvolatile memory, it must not reuse a previous sender sequence number and must not accept previously received messages.
the endpoints can reuse an existing shared master secret and derive new sender and recipient contexts, see appendix b.2 for an example.
this typically requires a good source of randomness.
the endpoints can use a trusted third-party-assisted key establishment protocol such as [oscore-profile].
this requires the execution of a three-party protocol and may require a good source of randomness.
the endpoints can run a key exchange protocol providing forward secrecy resulting in a fresh master secret, from which an entirely new security context is derived.
this requires a good source of randomness, and additionally, the transmission and processing of the protocol may have a non-negligible cost, e.g., in terms of power consumption.
the endpoints need to be configured with information about which method is used.
the choice of method may depend on capabilities of the devices deployed and the solution architecture.
using a key exchange protocol is necessary for deployments that require forward secrecy.
processing this section describes the oscore message processing.
additional processing for observe or block-wise are described in subsections.
note that, analogously to [rfc7252] where the token and source/ destination pair are used to match a response with a request, both endpoints must keep the association (token, {security context, partial iv of the request}), in order to be able to find the security context and compute the aad to protect or verify the response.
the association may be forgotten after it has been used to successfully protect or verify the response, with the exception of observe processing, where the association must be kept as long as the observation is active.
the processing of the sender sequence number follows the procedure described in section 3 of [iv-gen].
protecting the request given a coap request, the client shall perform the following steps to create an oscore request: 1.
retrieve the sender context associated with the target resource.
compose the aad and the plaintext, as described in sections 5.3 and 5.4.
encode the partial iv (sender sequence number in network byte order) and increment the sender sequence number by one.
compute the aead nonce from the sender id, common iv, and partial iv as described in section 5.2.
encrypt the cose object using the sender key.
compress the cose object as specified in section 6.
format the oscore message according to section 4.
the oscore option is added (see section 4.1.2).
verifying the request a server receiving a request containing the oscore option shall perform the following steps: 1.
discard code and all class e options (marked in figure 5 with 'x' in column e) present in the received message.
for example, an if-match outer option is discarded, but an uri-host outer option is not discarded.
decompress the cose object (section 6) and retrieve the recipient context associated with the recipient id in the 'kid' parameter, additionally using the 'kid context', if present.
note that the recipient context may be retrieved by deriving a new security context, e.g.
as described in appendix b.2.
if either the decompression or the cose message fails to decode, or the server fails to retrieve a recipient context with recipient id corresponding to the 'kid' parameter received, then the server shall stop processing the request.
* if either the decompression or the cose message fails to decode, the server may respond with a 4.02 (bad option) error message.
the server may set an outer max-age option with value zero.
the diagnostic payload may contain the string "failed to decode cose".
* if the server fails to retrieve a recipient context with recipient id corresponding to the 'kid' parameter received, the server may respond with a 4.01 (unauthorized) error message.
the server may set an outer max-age option with value zero.
the diagnostic payload may contain the string "security context not found".
verify that the partial iv has not been received before using the replay window, as described in section 7.4.
compose the aad, as described in section 5.4.
compute the aead nonce from the recipient id, common iv, and the partial iv, received in the cose object.
decrypt the cose object using the recipient key, as per section 5.3 of [rfc8152].
(the decrypt operation includes the verification of the integrity.)
* if decryption fails, the server must stop processing the request and may respond with a 4.00 (bad request) error message.
the server may set an outer max-age option with value zero.
the diagnostic payload may contain the string "decryption failed".
* if decryption succeeds, update the replay window, as described in section 7.
add decrypted code, options, and payload to the decrypted request.
the oscore option is removed.
the decrypted coap request is processed according to [rfc7252].
supporting block-wise if block-wise is supported, insert the following step before any other: a.
if block-wise is present in the request, then process the outer block options according to [rfc7959], until all blocks of the request have been received (see section 4.1.3.4).
protecting the response if a coap response is generated in response to an oscore request, the server shall perform the following steps to create an oscore response.
note that coap error responses derived from coap processing (step 8 in section 8.2) are protected, as well as successful coap responses, while the oscore errors (steps 2, 3, and 6 in section 8.2) do not follow the processing below but are sent as simple coap responses, without oscore processing.
retrieve the sender context in the security context associated with the token.
compose the aad and the plaintext, as described in sections 5.3 and 5.4.
compute the aead nonce as described in section 5.2: * either use the aead nonce from the request, orselander, et al.
* encode the partial iv (sender sequence number in network byte order) and increment the sender sequence number by one.
compute the aead nonce from the sender id, common iv, and partial iv.
encrypt the cose object using the sender key.
compress the cose object as specified in section 6.
if the aead nonce was constructed from a new partial iv, this partial iv must be included in the message.
if the aead nonce from the request was used, the partial iv must not be included in the message.
format the oscore message according to section 4.
the oscore option is added (see section 4.1.2).
supporting observe if observe is supported, insert the following step between steps 2 and 3 of section 8.3: a.
if the response is an observe notification: o if the response is the first notification: * compute the aead nonce as described in section 5.2: + either use the aead nonce from the request, or + encode the partial iv (sender sequence number in network byte order) and increment the sender sequence number by one.
compute the aead nonce from the sender id, common iv, and partial iv.
then, go to 4. o if the response is not the first notification: * encode the partial iv (sender sequence number in network byte order) and increment the sender sequence number by one.
compute the aead nonce from the sender id, common iv, and partial iv, then go to 4.
verifying the response a client receiving a response containing the oscore option shall perform the following steps: 1.
discard code and all class e options (marked in figure 5 with 'x' in column e) present in the received message.
for example, etag outer option is discarded, as well as max-age outer option.
retrieve the recipient context in the security context associated with the token.
decompress the cose object (section 6).
if either the decompression or the cose message fails to decode, then go to 8.
compose the aad, as described in section 5.4.
compute the aead nonce * if the partial iv is not present in the response, the aead nonce from the request is used.
* if the partial iv is present in the response, compute the aead nonce from the recipient id, common iv, and the partial iv, received in the cose object.
decrypt the cose object using the recipient key, as per section 5.3 of [rfc8152].
(the decrypt operation includes the verification of the integrity.)
if decryption fails, then go to 8.
add decrypted code, options and payload to the decrypted request.
the oscore option is removed.
the decrypted coap response is processed according to [rfc7252].
in case any of the previous erroneous conditions apply: the client shall stop processing the response.
supporting block-wise if block-wise is supported, insert the following step before any other: a.
if block-wise is present in the response, then process the outer block options according to [rfc7959], until all blocks of the response have been received (see section 4.1.3.4).
supporting observe if observe is supported: insert the following step between step 5 and step 6: a.
if the request was an observe registration, then: o if the partial iv is not present in the response, and the inner observe option is present, and the aead nonce from the request was already used once, then go to 8. o if the partial iv is present in the response and the inner observe option is present, then follow the processing described in section 4.1.3.5.2 and section 7.4.1, then: * initialize the notification number (if first successfully verified notification), or * overwrite the notification number (if the received partial iv was greater than the notification number).
replace step 8 of section 8.4 with: b.
in case any of the previous erroneous conditions apply: the client shall stop processing the response.
an error condition occurring while processing a response to an observation request does not cancel the observation.
a client must not react to failure by re-registering the observation immediately.
web linking the use of oscore may be indicated by a target "osc" attribute in a web link [rfc8288] to a resource, e.g., using a link-format document [rfc6690] if the resource is accessible over coap.
the "osc" attribute is a hint indicating that the destination of that link is only accessible using oscore, and unprotected access to it is not supported.
note that this is simply a hint, it does not include any security context material or any other information required to run oscore.
a value must not be given for the "osc" attribute; any present value must be ignored by parsers.
the "osc" attribute must not appear more than once in a given link-value; occurrences after the first must be ignored by parsers.
the link-format notation (see section 5 of [rfc6690]) is used.
coap-to-coap forwarding proxy coap is designed for proxy operations (see section 5.7 of [rfc7252]).
oscore is designed to work with oscore-unaware coap proxies.
security requirements for forwarding are listed in section 2.2.1 of [coap-e2e-sec].
proxy processing of the (outer) proxy-uri option works as defined in [rfc7252].
proxy processing of the (outer) block options works as defined in [rfc7959].
however, not all coap proxy operations are useful: o since a coap response is only applicable to the original coap request, caching is in general not useful.
in support of existing proxies, oscore uses the outer max-age option, see section 4.1.3.1. o proxy processing of the (outer) observe option as defined in [rfc7641] is specified in section 4.1.3.5.
optionally, a coap proxy may detect oscore and act accordingly.
an oscore-aware coap proxy: o shall bypass caching for the request if the oscore option is present.
o should avoid caching responses to requests with an oscore option.
in the case of observe (see section 4.1.3.5), the oscore-aware coap proxy: o shall not initiate an observe registration.
o may verify the order of notifications using partial iv rather than the observe option.
http operations the coap request/response model may be mapped to http and vice versa as described in section 10 of [rfc7252].
the http-coap mapping is further detailed in [rfc8075].
this section defines the components needed to map and transport oscore messages over http hops.
by mapping between http and coap and by using cross-protocol proxies, oscore may be used end-to-end between, e.g., an http client and a coap server.
examples are provided in sections 11.5 and 11.6.
the http oscore header field the http oscore header field (see section 13.4) is used for carrying the content of the coap oscore option when transporting oscore messages over http hops.
the http oscore header field is only used in post requests and responses with http status code 200 (ok).
when used, the http header field content-type is set to 'application/oscore' (see section 13.5) indicating that the http body of this message contains the oscore payload (see section 6.2).
no additional semantics are provided by other message fields.
using the augmented backus-naur form (abnf) notation of [rfc5234], including the following core abnf syntax rules defined by that specification: alpha (letters) and digit (decimal digits), the http oscore header field value is as follows.
base64url-char = alpha / digit / "-" / "_" oscore = 2*base64url-char the http oscore header field is not appropriate to list in the connection header field (see section 6.1 of [rfc7230]) since it is not hop-by-hop.
oscore messages are generally not useful when served from cache (i.e., they will generally be marked cache-control: no- cache) and so interaction with vary is not relevant (section 7.1.4 of [rfc7231]).
since the http oscore header field is critical for message processing, moving it from headers to trailers renders the message unusable in case trailers are ignored (see section 4.1 of [rfc7230]).
in general, intermediaries are not allowed to insert, delete, or modify the oscore header.
in general, changes to the http oscore header field will violate the integrity of the oscore message resulting in an error.
for the same reason the http oscore header field is generally not preserved across redirects.
since redirects are not defined in the mappings between http and coap ([rfc8075] [rfc7252]), a number of conditions need to be fulfilled for redirects to work.
for coap-client-to-http-server redirects, such conditions include: o the coap-to-http proxy follows the redirect, instead of the coap client as in the http case.
o the coap-to-http proxy copies the http oscore header field and body to the new request.
o the target of the redirect has the necessary oscore security context required to decrypt and verify the message.
since oscore requires the http body to be preserved across redirects, the http server is recommended to reply with 307 (temporary redirect) or 308 (permanent redirect) instead of 301 (moved permanently) or 302 (found).
for the case of http-client-to-coap-server redirects, although redirect is not defined for coap servers [rfc7252], an http client receiving a redirect should generate a new oscore request for the server it was redirected to.
coap-to-http mapping section 10.1 of [rfc7252] describes the fundamentals of the coap-to- http cross-protocol mapping process.
the additional rules for oscore messages are as follows: o the http oscore header field value is set to: * aa if the coap oscore option is empty; otherwise, * the value of the coap oscore option (section 6.1) in base64url (section 5 of [rfc4648]) encoding without padding.
implementation notes for this encoding are given in appendix c of [rfc7515].
o the http content-type is set to 'application/oscore' (see section 13.5), independent of coap content-format.
http-to-coap mapping section 10.2 of [rfc7252] and [rfc8075] specify the behavior of an http-to-coap proxy.
the additional rules for http messages with the oscore header field are as follows.
o the coap oscore option is set as follows: * empty if the value of the http oscore header field is a single zero byte (0x00) represented by aa; otherwise, * the value of the http oscore header field decoded from base64url (section 5 of [rfc4648]) without padding.
implementation notes for this encoding are given in appendix c of [rfc7515].
o the coap content-format option is omitted, the content format for oscore (section 13.6) must not be used.
http endpoints restricted to subsets of http and coap supporting a bijective mapping, oscore can be originated or terminated in http endpoints.
the sending http endpoint uses [rfc8075] to translate the http message into a coap message.
the coap message is then processed with oscore as defined in this document.
the oscore message is then mapped to http as described in section 11.2 and sent in compliance with the rules in section 11.1.
the receiving http endpoint maps the http message to a coap message using [rfc8075] and section 11.3.
the resulting oscore message is processed as defined in this document.
if successful, the plaintext coap message is translated to http for normal processing in the endpoint.
example: http client and coap server this section gives an example of what a request and a response between an http client and a coap server could look like.
the example is not a test vector but intended as an illustration of how the message fields are translated in the different steps.
mapping and notation here is based on "simple form" (section 5.4.1 of [rfc8075]).
[http request -- before client object security processing] get http://proxy.url/hc/?target_uri=coap://server.url/orders http/1.1 [http request -- http client to proxy] post http://proxy.url/hc/?target_uri=coap://server.url/ http/1.1 content-type: application/oscore oscore: csu body: 09 07 01 13 61 f7 0f d2 97 b1 [binary] [coap request -- proxy to coap server] post coap://server.url/ oscore: 09 25 payload: 09 07 01 13 61 f7 0f d2 97 b1 [binary] [coap request -- after server object security processing] get coap://server.url/orders [coap response -- before server object security processing] 2.05 content content-format: 0 payload: exterminate!
exterminate!
[coap response -- coap server to proxy] 2.04 changed oscore: [empty] payload: 00 31 d1 fc f6 70 fb 0c 1d d5 ... [binary] [http response -- proxy to http client] http/1.1 200 ok content-type: application/oscore oscore: aa body: 00 31 d1 fc f6 70 fb 0c 1d d5 ... [binary] [http response -- after client object security processing] http/1.1 200 ok content-type: text/plain body: exterminate!
exterminate!
note that the http status code 200 (ok) in the next-to-last message is the mapping of coap code 2.04 (changed), whereas the http status code 200 (ok) in the last message is the mapping of the coap code 2.05 (content), which was encrypted within the compressed cose object carried in the body of the http response.
example: coap client and http server this section gives an example of what a request and a response between a coap client and an http server could look like.
the example is not a test vector but intended as an illustration of how the message fields are translated in the different steps.
[coap request -- before client object security processing] get coap://proxy.url/ proxy-uri=http://server.url/orders [coap request -- coap client to proxy] post coap://proxy.url/ proxy-uri=http://server.url/ oscore: 09 25 payload: 09 07 01 13 61 f7 0f d2 97 b1 [binary] [http request -- proxy to http server] post http://server.url/ http/1.1 content-type: application/oscore oscore: csu body: 09 07 01 13 61 f7 0f d2 97 b1 [binary] [http request -- after server object security processing] get http://server.url/orders http/1.1 [http response -- before server object security processing] http/1.1 200 ok content-type: text/plain body: exterminate!
exterminate!
[http response -- http server to proxy] http/1.1 200 ok content-type: application/oscore oscore: aa body: 00 31 d1 fc f6 70 fb 0c 1d d5 ... [binary]selander, et al.
[coap response -- proxy to coap client] 2.04 changed oscore: [empty] payload: 00 31 d1 fc f6 70 fb 0c 1d d5 ... [binary] [coap response -- after client object security processing] 2.05 content content-format: 0 payload: exterminate!
exterminate!
note that the http code 2.04 (changed) in the next-to-last message is the mapping of http status code 200 (ok), whereas the coap code 2.05 (content) in the last message is the value that was encrypted within the compressed cose object carried in the body of the http response.
security considerations an overview of the security properties is given in appendix d.12.1.
end-to-end protection in scenarios with intermediary nodes such as proxies or gateways, transport layer security such as (d)tls only protects data hop-by- hop.
as a consequence, the intermediary nodes can read and modify any information.
the trust model where all intermediary nodes are considered trustworthy is problematic, not only from a privacy perspective, but also from a security perspective, as the intermediaries are free to delete resources on sensors and falsify commands to actuators (such as "unlock door", "start fire alarm", "raise bridge").
even in the rare cases where all the owners of the intermediary nodes are fully trusted, attacks and data breaches make such an architecture brittle.
(d)tls protects hop-by-hop the entire message.
oscore protects end- to-end all information that is not required for proxy operations (see section 4).
(d)tls and oscore can be combined, thereby enabling end- to-end security of the message payload, in combination with hop-by- hop protection of the entire message, during transport between endpoint and intermediary node.
in particular, when oscore is used with http, the additional tls protection of http hops is recommended, e.g., between an http endpoint and a proxy translating between http and coap.
applications need to consider that certain message fields and messages types are not protected end-to-end and may be spoofed or manipulated.
the consequences of unprotected message fields are analyzed in appendix d.5.
security context establishment the use of cose_encrypt0 and aead to protect messages as specified in this document requires an established security context.
the method to establish the security context described in section 3.2 is based on a common master secret and unique sender ids.
the necessary input parameters may be preestablished or obtained using a key establishment protocol augmented with establishment of sender/ recipient id, such as a key exchange protocol or the oscore profile of the authentication and authorization for constrained environments (ace) framework [oscore-profile].
such a procedure must ensure that the requirements of the security context parameters for the intended use are complied with (see section 3.3) even in error situations.
while recipient ids are allowed to coincide between different security contexts (see section 3.3), this may cause a server to process multiple verifications before finding the right security context or rejecting a message.
considerations for deploying oscore with a fixed master secret are given in appendix b.
master secret oscore uses hkdf [rfc5869] and the established input parameters to derive the security context.
the required properties of the security context parameters are discussed in section 3.3; in this section, we focus on the master secret.
in this specification, hkdf denotes the composition of the expand and extract functions as defined in [rfc5869] and the master secret is used as input keying material (ikm).
informally, hkdf takes as source an ikm containing some good amount of randomness but not necessarily distributed uniformly (or for which an attacker has some partial knowledge) and derive from it one or more cryptographically strong secret keys [rfc5869].
therefore, the main requirement for the oscore master secret, in addition to being secret, is that it have a good amount of randomness.
the selected key establishment schemes must ensure that the necessary properties for the master secret are fulfilled.
for pre-shared key deployments and key transport solutions such as [oscore-profile], the master secret can be generated offline using a good random number generator.
randomness requirements for security are described in [rfc4086].
replay protection replay attacks need to be considered in different parts of the implementation.
most aead algorithms require a unique nonce for each message, for which the sender sequence numbers in the cose message field 'partial iv' is used.
if the recipient accepts any sequence number larger than the one previously received, then the problem of sequence number synchronization is avoided.
with reliable transport, it may be defined that only messages with sequence numbers that are equal to the previous sequence number + 1 are accepted.
an adversary may try to induce a device reboot for the purpose of replaying a message (see section 7.5).
note that sharing a security context between servers may open up for replay attacks, for example, if the replay windows are not synchronized.
client aliveness a verified oscore request enables the server to verify the identity of the entity who generated the message.
however, it does not verify that the client is currently involved in the communication, since the message may be a delayed delivery of a previously generated request, which now reaches the server.
to verify the aliveness of the client the server may use the echo option in the response to a request from the client (see [coap-echo-req-tag]).
cryptographic considerations the maximum sender sequence number is dependent on the aead algorithm.
the maximum sender sequence number is 2^40 - 1, or any algorithm-specific lower limit, after which a new security context must be generated.
the mechanism to build the aead nonce (section 5.2) assumes that the nonce is at least 56 bits, and the partial iv is at most 40 bits.
the mandatory-to-implement aead algorithm aes-ccm-16-64-128 is selected for compatibility with ccm*.
aead algorithms that require unpredictable nonces are not supported.
in order to prevent cryptanalysis when the same plaintext is repeatedly encrypted by many different users with distinct aead keys, the aead nonce is formed by mixing the sequence number with a secret per-context initialization vector (common iv) derived along with the keys (see section 3.1 of [rfc8152]), and by using a master salt in the key derivation (see [mf00] for an overview).
the master secret, sender key, recipient key, and common iv must be secret, the rest of the parameters may be public.
the master secret must have a good amount of randomness (see section 12.3).
the id context, sender id, and partial iv are always at least implicitly integrity protected, as manipulation leads to the wrong nonce or key being used and therefore results in decryption failure.
message segmentation the inner block options enable the sender to split large messages into oscore-protected blocks such that the receiving endpoint can verify blocks before having received the complete message.
the outer block options allow for arbitrary proxy fragmentation operations that cannot be verified by the endpoints but that can, by policy, be restricted in size since the inner block options allow for secure fragmentation of very large messages.
a maximum message size (above which the sending endpoint fragments the message and the receiving endpoint discards the message, if complying to the policy) may be obtained as part of normal resource discovery.
privacy considerations privacy threats executed through intermediary nodes are considerably reduced by means of oscore.
end-to-end integrity protection and encryption of the message payload and all options that are not used for proxy operations provide mitigation against attacks on sensor and actuator communication, which may have a direct impact on the personal sphere.
the unprotected options (figure 5) may reveal privacy-sensitive information, see appendix d.5.
coap headers sent in plaintext allow, for example, matching of con and ack (coap message identifier), matching of request and responses (token) and traffic analysis.
oscore does not provide protection for http header fields that are not both coap-mappable and class e. the http message fields that are visible to on-path entities are only used for the purpose of transporting the oscore message, whereas the application-layer message is encoded in coap and encrypted.
cose message fields, i.e., the oscore option, may reveal information about the communicating endpoints.
for example, 'kid' and 'kid context', which are intended to help the server find the right context, may reveal information about the client.
tracking 'kid' and 'kid context' to one server may be used for correlating requests from one client.
unprotected error messages reveal information about the security state in the communication between the endpoints.
unprotected signaling messages reveal information about the reliable transportselander, et al.
used on a leg of the path.
using the mechanisms described in section 7.5 may reveal when a device goes through a reboot.
this can be mitigated by the device storing the precise state of sender sequence number and replay window on a clean shutdown.
the length of message fields can reveal information about the message.
applications may use a padding scheme to protect against traffic analysis.
iana considerations13.1.
cose header parameters registry the 'kid context' parameter has been added to the "cose header parameters" registry: o name: kid context o label: 10 o value type: bstr o value registry: o description: identifies the context for the key identifier o reference: section 5.1 of this document13.2.
media type registration this section registers the 'application/oscore' media type in the "media types" registry.
this media type is used to indicate that the content is an oscore message.
the oscore body cannot be understood without the oscore header field value and the security context.
type name: application subtype name: oscore required parameters: n/a optional parameters: n/a encoding considerations: binary security considerations: see the security considerations section of [rfc8613].
interoperability considerations: n/a published specification: [rfc8613] applications that use this media type: iot applications sending security content over http(s) transports.
fragment identifier considerations: n/a additional information: * deprecated alias names for this type: n/a * magic number(s): n/a * file extension(s): n/a * macintosh file type code(s): n/aselander, et al.
person & email address to contact for further information: iesg <iesg@ietf.org> intended usage: common restrictions on usage: n/a author: goeran selander <goran.selander@ericsson.com> change controller: iesg provisional registration?
no13.6.
coap content-formats registry this section registers the media type 'application/oscore' media type in the "coap content-formats" registry.
this content-format for the oscore payload is defined for potential future use cases and shall not be used in the oscore message.
the oscore payload cannot be understood without the oscore option value and the security context.
oscore flag bits registry this document defines a subregistry for the oscore flag bits within the "core parameters" registry.
the name of the subregistry is "oscore flag bits".
the registry has been created with the expert review policy [rfc8126].
guidelines for the experts are provided in section 13.8.
the columns of the registry are as follows: o bit position: this indicates the position of the bit in the set of oscore flag bits, starting at 0 for the most significant bit.
the bit position must be an integer or a range of integers, in the range 0 to 63. o name: the name is present to make it easier to refer to and discuss the registration entry.
the value is not used in the protocol.
names are to be unique in the table.
o description: this contains a brief description of the use of the bit.
o reference: this contains a pointer to the specification defining the entry.
the initial contents of the registry are in the table below.
the reference column for all rows is this document.
the entries with bit position of 0 and 1 are marked as 'reserved'.
the entry with bit position of 1 will be specified in a future document and will be used to expand the space for the oscore flag bits in section 6.1, so that entries 8-63 of the registry are defined.
expert review instructions the expert reviewers for the registry defined in this document are expected to ensure that the usage solves a valid use case that could not be solved better in a different way, that it is not going to duplicate one that is already registered, and that the registered point is likely to be used in deployments.
they are furthermore expected to check the clarity of purpose and use of the requested code points.
experts should take into account the expected usage of entries when approving point assignment, and the length of the encoded value should be weighed against the number of code points left that encode to that size and the size of device it will be usedselander, et al.
on.
experts should block registration for entries 8-63 until these points are defined (i.e., until the mechanism for the oscore flag bits expansion via bit 1 is specified).

introduction the constrained application protocol (coap) [rfc7252] is a restful application-layer protocol for constrained environments [rfc7228].
in coap, clients (or intermediaries in the client role) make requests to servers (or intermediaries in the server role), which satisfy the requests by returning responses.
while a request is ongoing, a client typically needs to keep some state that it requires for processing the response when that arrives.
a client can opt into this by serializing (parts of) its state into the token itself and then recovering this state from the token in the response (figure 2).
(the term "stateless" is in quotes here, because it's a bit oversimplified.
such clients still need to maintain per-server state and other kinds of state.
so it would be more accurate to just say that the clients are avoiding per-request state.)
section 4 of this document extends the considerations for clients to intermediaries, which may want to avoid keeping state for not only the requests they send to servers but also the requests they receive from clients.
the serialization of state into tokens is limited by the fact that both coap over udp [rfc7252] and coap over reliable transports [rfc8323] restrict the maximum token length to 8 bytes.
to overcome this limitation, section 2 of this document introduces a coap protocol extension for extended token lengths.
while the use case (avoiding per-request state) and the mechanism (extended token lengths) presented in this document are closely related, each can be used independently of the other.
some implementations may be able to fit their state in just 8 bytes; some implementations may have other use cases for extended token lengths.
terminology in this document, the term "stateless" refers to an implementation strategy for a client (or intermediary in the client role) that does not require it to keep state for the individual requests it sends to a server (or intermediary in the server role).
the client still needs to keep state for each server it communicates with (e.g., for token generation, message retransmission, and congestion control).
the key words "must", "must not", "required", "shall", "shall not", "should", "should not", "recommended", "not recommended", "may", and "optional" in this document are to be interpreted as described in bcp 14 [rfc2119] [rfc8174] when, and only when, they appear in all capitals, as shown here.
extended tokens this document updates the message formats defined for coap over udp [rfc7252] and coap over tcp, tls, and websockets [rfc8323] with a new definition of the "tkl" field.
extended token length (tkl) field the definition of the "tkl" field is updated as follows: token length (tkl): 4-bit unsigned integer.
a value between 0 and 12, inclusive, indicates the length of the variable-length "token" field in bytes.
the other three values are reserved for special constructs: 13: an 8-bit unsigned integer directly precedes the "token" field and indicates the length of the "token" field minus 13.
14: a 16-bit unsigned integer in network byte order directly precedes the "token" field and indicates the length of the "token" field minus 269.
15: reserved.
this value must not be sent and must be processed as a message-format error.
all other fields retain their definitions.
the updated message formats are illustrated in appendix a.
the new definition of the "tkl" field increases the maximum token length that can be represented in a message to 65804 bytes.
however, the maximum token length that sender and recipient implementations support may be shorter.
for example, a constrained node of class 1 [rfc7228] might support extended token lengths only up to 32 bytes.
in coap over udp, it is often beneficial to keep coap messages small enough to avoid ip fragmentation.
the maximum practical token length may therefore also be influenced by the path mtu (pmtu).
see section 4.6 of [rfc7252] for details.
discovering support extended token lengths require support from server implementations.
support can be discovered by a client implementation in one of two ways: * where capabilities and settings messages (csms) are available, such as in coap over tcp, support can be discovered using the extended-token-length capability option defined in section 2.2.1.
* otherwise, such as in coap over udp, support can only be discovered by trial and error, as described in section 2.2.2.
extended-token-length capability option a server can use the elective extended-token-length capability option to indicate the maximum token length it can accept in requests.
the active value of the extended-token-length option is replaced each time the option is sent with a modified value.
its starting value is its base value.
the option value must not be less than 8 or greater than 65804.
if an option value less than 8 is received, the option must be ignored.
if an option value greater than 65804 is received, the option value must be set to 65804.
any option value greater than 8 implies support for the new definition of the "tkl" field specified in section 2.1.
indication of support by a server does not oblige a client to actually make use of token lengths greater than 8.
if a server receives a request with a token of a length greater than what it indicated in its extended-token-length option, it must handle the request as a message-format error.
if a server receives a request with a token of a length less than, or equal to, what it indicated in its extended-token-length option but is unwilling or unable to handle the token at that time, it must not handle the request as a message-format error.
instead, it should return a 5.03 (service unavailable) response.
the extended-token-length capability option does not apply to responses.
the sender of a request is simply expected not to use a token of a length greater than it is willing to accept in a response.
trial and error a server implementation that does not support the updated definition of the "tkl" field specified in section 2.1 will consider a request with a "tkl" field value outside the range 0 to 8 to be a message- format error and reject it (section 3 of [rfc7252]).
a client can therefore determine support by sending a request with an extended token length and checking whether or not it is rejected by the server.
in coap over udp, the way a request message is rejected depends on the message type.
a confirmable message with a message-format error is rejected with a reset message (section 4.2 of [rfc7252]).
a non- confirmable message with a message-format error is either rejected with a reset message or just silently ignored (section 4.3 of [rfc7252]).
to reliably get a reset message, it is therefore required that clients use a confirmable message for determining support.
as per rfc 7252, reset messages are empty and do not contain a token; they only return the message id (figure 3).
they also do not contain any indication of what caused a message-format error.
to avoid any ambiguity, it is therefore recommended that clients use a request that has no potential message-format error other than the extended token length.
any response with the same token echoed back indicates that tokens up to that length are supported by the server.
since network addresses may change, a client should not assume that extended token lengths are supported by a server for an unlimited duration.
unless additional information is available, the client should assume that addresses (and therefore extended token lengths) are valid for a minimum of 1800 s and a maximum of 86400 s (1 day).
a client may use additional forms of input into this determination.
for instance, a client may assume a server that is in the same subnet as the client has a similar address lifetime as the client.
the client may use dhcp lease times or router advertisements to set the limits.
for servers that are not local, if the server was looked up using dns, then the dns resource record will have a time to live (ttl), and the extended token length should be kept for only that amount of time.
if a server supports extended token lengths but receives a request with a token of a length it is unwilling or unable to handle, it must not reject the message, as that would imply that extended token lengths are not supported at all.
instead, if the server cannot handle the request at the time, it should return a 5.03 (service unavailable) response; if the server will never be able to handle the request (e.g., because the token is too large), it should return a 4.00 (bad request) response.
| design note: the requirement to return an error response when a | token cannot be handled might seem somewhat contradictory, as | returning the error response requires the server also to return | the token it cannot handle.
however, processing a request | usually involves a number of steps from receiving the message | to passing it to application logic.
the idea is that a server | implementing this extension supports large tokens at least in | its first few processing steps, enough to return an error | response rather than a reset message.
| design note: to prevent the trial-and-error-based discovery | from becoming too complicated, no effort is made to indicate | the maximum supported token length.
a client implementation | would probably already choose the shortest token possible for | the task (such as being stateless, as described in section 3), | so it would probably not be able to reduce the length any | further anyway should a server indicate a lower limit.
intermediaries tokens are a hop-by-hop feature: if there are one or more intermediaries between a client and a server, every token is scoped to the exchange between a node in the client role and the node in the server role that it is immediately interacting with.
when an intermediary receives a request, the only requirement is that it echoes the token back in any resulting response.
there is no requirement or expectation that an intermediary passes a client's token on to a server or that an intermediary uses extended token lengths itself in its request to satisfy a request with an extended token length.
discovery needs to be performed for each hop where extended token lengths are to be used.
stateless clients a client can be alleviated of keeping per-request state as follows: 1.
the client serializes (parts of) its per-request state into a sequence of bytes and sends those bytes as the token of its request to the server.
the server returns the token verbatim in the response to the client, which allows the client to recover the state and process the response as if it had kept the state locally.
as servers are just expected to return any token verbatim to the client, this implementation strategy for clients does not impact the interoperability of client and server implementations.
however, there are a number of significant, nonobvious implications (e.g., related to security and other coap protocol features) that client implementations need take into consideration.
the following subsections discuss some of these considerations.
serializing client state the format of the serialized state is generally an implementation detail of the client and opaque to the server.
however, serialized state information is an attractive target for both unwanted nodes (e.g., on-path attackers) and wanted nodes (e.g., any configured forward proxy) on the path.
the serialization format therefore needs to include security measures such as the following: * a client should protect the integrity of the state information serialized in a token.
* even when the integrity of the serialized state is protected, an attacker may still replay a response, making the client believe it sent the same request twice.
for this reason, the client should implement replay protection (e.g., by using sequence numbers and a replay window).
for replay protection, integrity protection is required.
* if processing a response without keeping request state is sensitive to the time elapsed since sending the request, then the client should include freshness information (e.g., a timestamp) in the serialized state and reject any response where the freshness information is insufficiently fresh.
* information in the serialized state may be privacy sensitive.
a client should encrypt the serialized state if it contains privacy- sensitive information that an attacker would not get otherwise.
* when a client changes the format of the serialized state, it should prevent false interoperability with the previous format (e.g., by changing the key used for integrity protection or changing a field in the serialized state).
using extended tokens a client that depends on support for extended token lengths (section 2) from the server to avoid keeping request state needs to perform a discovery of support (section 2.2) before it can be stateless.
this discovery must be performed in a stateful way, i.e., keeping state for the request (figure 4).
if the client was stateless from the start, and the server does not support extended tokens, then no error message could be processed, since the state would neither be present at the client nor returned in the reset message (figure 5).
an example for this is the constrained join protocol (cojp) in a 6tisch network [6tisch-min-sec], where support for extended tokens is required from all relevant parties.
transmitting messages in coap over udp [rfc7252], a client has the choice between confirmable and non-confirmable messages for requests.
when using non-confirmable messages, a client does not have to keep any message- exchange state, which can help in the goal of avoiding state.
when using confirmable messages, a client needs to keep message-exchange state for performing retransmissions and handling acknowledgement and reset messages, however.
non-confirmable messages are therefore better suited for avoiding state.
in any case, a client still needs to keep congestion-control state, i.e., maintain state for each node it communicates with and enforce limits like nstart.
as per section 5.2 of [rfc7252], a client must be prepared to receive a response as a piggybacked response, a separate response, or a non- confirmable response, regardless of the message type used for the request.
a stateless client must handle these response types as follows: * if a piggybacked response passes the checks for token integrity and freshness (section 3.1), the client processes the message as specified in rfc 7252; otherwise, it processes the acknowledgement portion of the message as specified in rfc 7252 and silently discards the response portion.
* if a separate response passes the checks for token integrity and freshness, the client processes the message as specified in rfc 7252; otherwise, it rejects the message as specified in section 4.2 of [rfc7252].
* if a non-confirmable response passes the checks for token integrity and freshness, the client processes the message as specified in rfc 7252; otherwise, it rejects the message as specified in section 4.3 of [rfc7252].
stateless intermediaries tokens are a hop-by-hop feature.
if a client makes a request to an intermediary, that intermediary needs to store the client's token (along with the client's transport address) while it makes its own request towards the origin server and waits for the response.
when the intermediary receives the response, it looks up the client's token and transport address for the received request and sends an appropriate response to the client.
an intermediary might want to be "stateless" not only in its role as a client but also in its role as a server, i.e., be alleviated of storing the client information for the requests it receives.
such an intermediary can be implemented by serializing the client information along with the request state into the token towards the origin server.
when the intermediary receives the response, it can recover the client information from the token and use it to satisfy the client's request; therefore, the intermediary doesn't need to store the information itself.
the following subsections discuss some considerations for this approach.
observing resources one drawback of the approach is that an intermediary, without keeping request state, is unable to aggregate multiple requests for the same target resource, which can significantly reduce efficiency.
in particular, when clients observe [rfc7641] the same resource, aggregating requests is required (section 3.1 of [rfc7641]).
this requirement cannot be satisfied without keeping request state.
furthermore, an intermediary that does not keep track of the clients observing a resource is not able to determine whether these clients are still interested in receiving further notifications (section 3.5 of [rfc7641]) or want to cancel an observation (section 3.6 of [rfc7641]).
therefore, an intermediary must not include an observe option in requests it sends without keeping both the request state for the requests it sends and the client information for the requests it receives.
block-wise transfers when using block-wise transfers [rfc7959], a server might not be able to distinguish blocks originating from different clients once they have been forwarded by an intermediary.
intermediaries need to ensure that this does not lead to inconsistent resource state by keeping distinct block-wise request operations on the same resource apart, e.g., utilizing the request-tag option [echo-request-tag].
gateway timeouts as per section 5.7.1 of [rfc7252], an intermediary is required to return a 5.04 (gateway timeout) response if it cannot obtain a response within a timeout.
however, if an intermediary does not keep the client information for the requests it receives, it cannot return such a response.
therefore, in this case, the gateway cannot return such a response and as such cannot implement such a timeout.
extended tokens a client may make use of extended token lengths in a request to an intermediary that wants to be "stateless".
this means that such an intermediary may have to serialize potentially very large client information into its token towards the origin server.
the tokens can grow even further when it progresses along a chain of intermediaries that all want to be "stateless".
intermediaries should limit the size of client information they are serializing into their own tokens.
an intermediary can do this, for example, by limiting the extended token lengths it accepts from its clients (see section 2.2) or by keeping the client information locally when the client information exceeds the limit (i.e., not being "stateless").
security considerations5.1.
extended tokens tokens significantly larger than the 8 bytes specified in rfc 7252 have implications -- in particular, for nodes with constrained memory size -- that need to be mitigated.
a node in the server role supporting extended token lengths may be vulnerable to a denial of service when an attacker (either on-path or a malicious client) sends large tokens to fill up the memory of the node.
implementations need to be prepared to handle such messages.
stateless clients and intermediaries transporting the state needed by a client to process a response as serialized state information in the token has several significant and nonobvious security and privacy implications that need to be mitigated; see section 3.1 for recommendations.
in addition to the format requirements outlined there, implementations need to ensure that they are not vulnerable to maliciously crafted, delayed, or replayed tokens.
it is generally expected that the use of encryption, integrity protection, and replay protection for serialized state is appropriate.
in the absence of integrity and replay protection, an on-path attacker or rogue server/intermediary could return a state (either one modified in a reply, or an unsolicited one) that could alter the internal state of the client.
it is for this reason that at least the use of integrity protection on the token is always recommended.
it may be that in some very specific cases, as a result of a careful and detailed analysis of any potential attacks, it is decided that such cryptographic protections do not add value.
the authors of this document have not found such a use case as yet, but this is a local decision.
it should further be emphasized that the encrypted state is created by the sending node and decrypted by the same node when receiving a response.
the key is not shared with any other system.
therefore, the choice of encryption scheme and the generation of the key for this system is purely a local matter.
when encryption is used, the use of aes-ccm [rfc3610] with a 64-bit tag is recommended, combined with a sequence number and a replay window.
this choice is informed by available hardware acceleration of on many constrained systems.
if a different algorithm is available accelerated on the sender, with similar or stronger strength, then it should be preferred.
where privacy of the state is not required, and encryption is not needed, hmac-sha-256 [rfc6234], combined with a sequence number and a replay window, may be used.
this size of the replay window depends upon the number of requests that need to be outstanding.
this can be determined from the rate at which new ones are made and the expected time period during which responses are expected.
for instance, given a coap max_transmit_wait of 93 s (section 4.8.2 of [rfc7252]), any request that is not answered within 93 s will be considered to have failed.
at a request rate of one request per 10 s, at most 10 (ceil(9.3)) requests can be outstanding at a time, and any convenient replay window larger than 20 will work.
as replay windows are often implemented with a sliding window and a bit, the use of a 32-bit window would be sufficient.
for use cases where requests are being relayed from another node, the request rate may be estimated by the total link capacity allocated for that kind of traffic.
an alternate view would consider how many ipv6 neighbor cache entries (nces) the system can afford to allocate for this use.
when using an encryption mode that depends on a nonce, such as aes- ccm, repeated use of the same nonce under the same key causes the cipher to fail catastrophically.
if a nonce is ever used for more than one encryption operation with the same key, then the same key stream gets used to encrypt both plaintexts, and the confidentiality guarantees are voided.
devices with low-quality entropy sources -- as is typical with constrained devices, which incidentally happen to be a natural candidate for the stateless mechanism described in this document -- need to carefully pick a nonce-generation mechanism that provides the above uniqueness guarantee.
[rfc8613], appendix b.1.1 ("sender sequence number") provides a model for how to maintain nonrepeating nonces without causing excessive wear of flash memory.
iana considerations6.1.
coap signaling option number the following entry has been added to the "coap signaling option numbers" registry within the "core parameters" registry.
