Introduction The use of web services (web APIs) on the Internet has become ubiquitous in most applications and depends on the fundamental Representational State Transfer [REST] architecture of the Web.
The work on Constrained RESTful Environments (CoRE) aims at realizing the REST architecture in a suitable form for the most constrained nodes (e.g., 8-bit microcontrollers with limited RAM and ROM) and networks (e.g., 6LoWPAN, [RFC4944]).
Constrained networks such as 6LoWPAN support the fragmentation of IPv6 packets into small link-layer frames; however, this causes significant reduction in packet delivery probability.
One design goal of CoAP has been to keep message overhead small, thus limiting the need for fragmentation.
One of the main goals of CoAP is to design a generic web protocol for the special requirements of this constrained environment, especially considering energy, building automation, and other machine-to-machine (M2M) applications.
The goal of CoAP is not to blindly compress HTTP [RFC2616], but rather to realize a subset of REST common with HTTP but optimized for M2M applications.
Although CoAP could be used for refashioning simple HTTP interfaces into a more compact protocol, more importantly it also offers features for M2M such as built-in discovery, multicast support, and asynchronous message exchanges.
This document specifies the Constrained Application Protocol (CoAP), which easily translates to HTTP for integration with the existing Web while meeting specialized requirements such as multicast support, very low overhead, and simplicity for constrained environments and M2M applications.
Features CoAP has the following main features: o Web protocol fulfilling M2M requirements in constrained environments o UDP [RFC0768] binding with optional reliability supporting unicast and multicast requests.
o Asynchronous message exchanges.
o Low header overhead and parsing complexity.
o URI and Content-type support.
o Simple proxy and caching capabilities.
o A stateless HTTP mapping, allowing proxies to be built providing access to CoAP resources via HTTP in a uniform way or for HTTP simple interfaces to be realized alternatively over CoAP.
o Security binding to Datagram Transport Layer Security (DTLS) [RFC6347].
Terminology The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT", "SHOULD", "SHOULD NOT", "RECOMMENDED", "NOT RECOMMENDED", "MAY", and "OPTIONAL" in this document are to be interpreted as described in [RFC2119] when they appear in ALL CAPS.
These words may also appear in this document in lowercase, absent their normative meanings.
This specification requires readers to be familiar with all the terms and concepts that are discussed in [RFC2616], including "resource", "representation", "cache", and "fresh".
(Having been completed before the updated set of HTTP RFCs, RFC 7230 to RFC 7235, became available, this specification specifically references the predecessor version --RFC 2616.)
In addition, this specification defines the following terminology: Endpoint An entity participating in the CoAP protocol.
Colloquially, an endpoint lives on a "Node", although "Host" would be more consistent with Internet standards usage, and is further identified by transport-layer multiplexing information that can include a UDP port number and a security association (Section 4.1).
Sender The originating endpoint of a message.
When the aspect of identification of the specific sender is in focus, also "source endpoint".
Recipient The destination endpoint of a message.
When the aspect of identification of the specific recipient is in focus, also "destination endpoint".
Client The originating endpoint of a request; the destination endpoint of a response.
Server The destination endpoint of a request; the originating endpoint of a response.
Origin Server The server on which a given resource resides or is to be created.
Intermediary A CoAP endpoint that acts both as a server and as a client towards an origin server (possibly via further intermediaries).
A common form of an intermediary is a proxy; several classes of such proxies are discussed in this specification.
Proxy An intermediary that mainly is concerned with forwarding requests and relaying back responses, possibly performing caching, namespace translation, or protocol translation in the process.
As opposed to intermediaries in the general sense, proxies generally do not implement specific application semantics.
Based on the position in the overall structure of the request forwarding, there are two common forms of proxy: forward-proxy and reverse-proxy.
In some cases, a single endpoint might act as an origin server, forward-proxy, or reverse-proxy, switching behavior based on the nature of each request.
Forward-Proxy An endpoint selected by a client, usually via local configuration rules, to perform requests on behalf of the client, doing any necessary translations.
Some translations are minimal, such as for proxy requests for "coap" URIs, whereas other requests might require translation to and from entirely different application-layer protocols.
Reverse-Proxy An endpoint that stands in for one or more other server(s) and satisfies requests on behalf of these, doing any necessary translations.
Unlike a forward-proxy, the client may not be aware that it is communicating with a reverse-proxy; a reverse-proxy receives requests as if it were the origin server for the target resource.
CoAP-to-CoAP Proxy A proxy that maps from a CoAP request to a CoAP request, i.e., uses the CoAP protocol both on the server and the client side.
Contrast to cross-proxy.
Cross-Proxy A cross-protocol proxy, or "cross-proxy" for short, is a proxy that translates between different protocols, such as a CoAP-to-HTTP proxy or an HTTP-to-CoAP proxy.
While this specification makes very specific demands of CoAP-to-CoAP proxies, there is more variation possible in cross-proxies.
Confirmable Message Some messages require an acknowledgement.
These messages are called "Confirmable".
When no packets are lost, each Confirmable message elicits exactly one return message of type Acknowledgement or type Reset.
Non-confirmable Message Some other messages do not require an acknowledgement.
This is particularly true for messages that are repeated regularly for application requirements, such as repeated readings from a sensor.
Acknowledgement Message An Acknowledgement message acknowledges that a specific Confirmable message arrived.
By itself, an Acknowledgement message does not indicate success or failure of any request encapsulated in the Confirmable message, but the Acknowledgement message may also carry a Piggybacked Response (see below).
Reset Message A Reset message indicates that a specific message (Confirmable or Non-confirmable) was received, but some context is missing to properly process it.
This condition is usually caused when the receiving node has rebooted and has forgotten some state that would be required to interpret the message.
Provoking a Reset message (e.g., by sending an Empty Confirmable message) is also useful as an inexpensive check of the liveness of an endpoint ("CoAP ping").
Piggybacked Response A piggybacked Response is included right in a CoAP Acknowledgement (ACK) message that is sent to acknowledge receipt of the Request for this Response (Section 5.2.1).
Separate Response When a Confirmable message carrying a request is acknowledged with an Empty message (e.g., because the server doesn't have the answer right away), a Separate Response is sent in a separate message exchange (Section 5.2.2).
Empty Message A message with a Code of 0.00; neither a request nor a response.
An Empty message only contains the 4-byte header.
Critical Option An option that would need to be understood by the endpoint ultimately receiving the message in order to properly process the message (Section 5.4.1).
Note that the implementation of critical options is, as the name "Option" implies, generally optional: unsupported critical options lead to an error response or summary rejection of the message.
Elective Option An option that is intended to be ignored by an endpoint that does not understand it.
Processing the message even without understanding the option is acceptable (Section 5.4.1).
Unsafe Option An option that would need to be understood by a proxy receiving the message in order to safely forward the message (Section 5.4.2).
Not every critical option is an unsafe option.
Safe-to-Forward Option An option that is intended to be safe for forwarding by a proxy that does not understand it.
Forwarding the message even without understanding the option is acceptable (Section 5.4.2).
Resource Discovery The process where a CoAP client queries a server for its list of hosted resources (i.e., links as defined in Section 7).
Content-Format The combination of an Internet media type, potentially with specific parameters given, and a content-coding (which is often the identity content-coding), identified by a numeric identifier defined by the "CoAP Content-Formats" registry.
When the focus is less on the numeric identifier than on the combination of these characteristics of a resource representation, this is also called "representation format".
Additional terminology for constrained nodes and constrained-node networks can be found in [RFC7228].
In this specification, the term "byte" is used in its now customary sense as a synonym for "octet".
All multi-byte integers in this protocol are interpreted in network byte order.
Where arithmetic is used, this specification uses the notation familiar from the programming language C, except that the operator "**" stands for exponentiation.
Constrained Application Protocol The interaction model of CoAP is similar to the client/server model of HTTP.
However, machine-to-machine interactions typically result in a CoAP implementation acting in both client and server roles.
A CoAP request is equivalent to that of HTTP and is sent by a client to request an action (using a Method Code) on a resource (identified by a URI) on a server.
The server then sends a response with a Response Code; this response may include a resource representation.
Unlike HTTP, CoAP deals with these interchanges asynchronously over a datagram-oriented transport such as UDP.
This is done logically using a layer of messages that supports optional reliability (with exponential back-off).
CoAP defines four types of messages: Confirmable, Non-confirmable, Acknowledgement, Reset.
Method Codes and Response Codes included in some of these messages make them carry requests or responses.
The basic exchanges of the four types of messages are somewhat orthogonal to the request/response interactions; requests can be carried in Confirmable and Non-confirmable messages, and responses can be carried in these as well as piggybacked in Acknowledgement messages.
One could think of CoAP logically as using a two-layer approach, a CoAP messaging layer used to deal with UDP and the asynchronous nature of the interactions, and the request/response interactions using Method and Response Codes (see Figure 1).
CoAP is however a single protocol, with messaging and request/response as just features of the CoAP header.
Messaging Model The CoAP messaging model is based on the exchange of messages over UDP between endpoints.
CoAP uses a short fixed-length binary header (4 bytes) that may be followed by compact binary options and a payload.
This message format is shared by requests and responses.
The CoAP message format is specified in Section 3.
Each message contains a Message ID used to detect duplicates and for optional reliability.
(The Message ID is compact; its 16-bit size enables up to about 250 messages per second from one endpoint to another with default protocol parameters.)
Reliability is provided by marking a message as Confirmable (CON).
A Confirmable message is retransmitted using a default timeout and exponential back-off between retransmissions, until the recipient sends an Acknowledgement message (ACK) with the same Message ID (in this example, 0x7d34) from the corresponding endpoint; see Figure 2.
When a recipient is not at all able to process a Confirmable message (i.e., not even able to provide a suitable error response), it replies with a Reset message (RST) instead of an Acknowledgement (ACK).
A message that does not require reliable transmission (for example, each single measurement out of a stream of sensor data) can be sent as a Non-confirmable message (NON).
These are not acknowledged, but still have a Message ID for duplicate detection (in this example, 0x01a0); see Figure 3.
When a recipient is not able to process a Non-confirmable message, it may reply with a Reset message (RST).
See Section 4 for details of CoAP messages.
As CoAP runs over UDP, it also supports the use of multicast IP destination addresses, enabling multicast CoAP requests.
Section 8 discusses the proper use of CoAP messages with multicast addresses and precautions for avoiding response congestion.
Several security modes are defined for CoAP in Section 9 ranging from no security to certificate-based security.
This document specifies a binding to DTLS for securing the protocol; the use of IPsec with CoAP is discussed in [IPsec-CoAP].
Request/Response Model CoAP request and response semantics are carried in CoAP messages, which include either a Method Code or Response Code, respectively.
Optional (or default) request and response information, such as the URI and payload media type are carried as CoAP options.
A Token is used to match responses to requests independently from the underlying messages (Section 5.3).
(Note that the Token is a concept separate from the Message ID.)
A request is carried in a Confirmable (CON) or Non-confirmable (NON) message, and, if immediately available, the response to a request carried in a Confirmable message is carried in the resulting Acknowledgement (ACK) message.
This is called a piggybacked response, detailed in Section 5.2.1.
(There is no need for separately acknowledging a piggybacked response, as the client will retransmit the request if the Acknowledgement message carrying the piggybacked response is lost.)
Two examples for a basic GET request with piggybacked response are shown in Figure 4, one successful, one resulting in a 4.04 (Not Found) response.
If the server is not able to respond immediately to a request carried in a Confirmable message, it simply responds with an Empty Acknowledgement message so that the client can stop retransmitting the request.
When the response is ready, the server sends it in a new Confirmable message (which then in turn needs to be acknowledged by the client).
This is called a "separate response", as illustrated in Figure 5 and described in more detail in Section 5.2.2.
If a request is sent in a Non-confirmable message, then the response is sent using a new Non-confirmable message, although the server may instead send a Confirmable message.
This type of exchange is illustrated in Figure 6.
Messages CoAP makes use of GET, PUT, POST, and DELETE methods in a similar manner to HTTP, with the semantics specified in Section 5.8.
(Note that the detailed semantics of CoAP methods are "almost, but not entirely unlike" [HHGTTG] those of HTTP methods: intuition taken from HTTP experience generally does apply well, but there are enough differences that make it worthwhile to actually read the present specification.)
Methods beyond the basic four can be added to CoAP in separate specifications.
New methods do not necessarily have to use requests and responses in pairs.
Even for existing methods, a single request may yield multiple responses, e.g., for a multicast request (Section 8) or with the Observe option [OBSERVE].
URI support in a server is simplified as the client already parses the URI and splits it into host, port, path, and query components, making use of default values for efficiency.
Response Codes relate to a small subset of HTTP status codes with a few CoAP-specific codes added, as defined in Section 5.9.
Intermediaries and Caching The protocol supports the caching of responses in order to efficiently fulfill requests.
Simple caching is enabled using freshness and validity information carried with CoAP responses.
A cache could be located in an endpoint or an intermediary.
Caching functionality is specified in Section 5.6.
Proxying is useful in constrained networks for several reasons, including to limit network traffic, to improve performance, to access resources of sleeping devices, and for security reasons.
The proxying of requests on behalf of another CoAP endpoint is supported in the protocol.
When using a proxy, the URI of the resource to request is included in the request, while the destination IP address is set to the address of the proxy.
See Section 5.7 for more information on proxy functionality.
As CoAP was designed according to the REST architecture [REST], and thus exhibits functionality similar to that of the HTTP protocol, it is quite straightforward to map from CoAP to HTTP and from HTTP to CoAP.
Such a mapping may be used to realize an HTTP REST interface using CoAP or to convert between HTTP and CoAP.
This conversion can be carried out by a cross-protocol proxy ("cross-proxy"), which converts the Method or Response Code, media type, and options to the corresponding HTTP feature.
Section 10 provides more detail about HTTP mapping.
Resource Discovery Resource discovery is important for machine-to-machine interactions and is supported using the CoRE Link Format [RFC6690] as discussed in Section 7.
Message Format CoAP is based on the exchange of compact messages that, by default, are transported over UDP (i.e., each CoAP message occupies the data section of one UDP datagram).
CoAP may also be used over Datagram Transport Layer Security (DTLS) (see Section 9.1).
It could also be used over other transports such as SMS, TCP, or SCTP, the specification of which is out of this document's scope.
(UDP-lite [RFC3828] and UDP zero checksum [RFC6936] are not supported by CoAP.)
CoAP messages are encoded in a simple binary format.
The message format starts with a fixed-size 4-byte header.
This is followed by a variable-length Token value, which can be between 0 and 8 bytes long.
Following the Token value comes a sequence of zero or more CoAP Options in Type-Length-Value (TLV) format, optionally followed by a payload that takes up the rest of the datagram.
The fields in the header are defined as follows: Version (Ver): 2-bit unsigned integer.
Indicates the CoAP version number.
Implementations of this specification MUST set this field to 1 (01 binary).
Other values are reserved for future versions.
Messages with unknown version numbers MUST be silently ignored.
Type (T): 2-bit unsigned integer.
Indicates if this message is of type Confirmable (0), Non-confirmable (1), Acknowledgement (2), or Reset (3).
The semantics of these message types are defined in Section 4.
Token Length (TKL): 4-bit unsigned integer.
Indicates the length of the variable-length Token field (0-8 bytes).
Lengths 9-15 are reserved, MUST NOT be sent, and MUST be processed as a message format error.
Code: 8-bit unsigned integer, split into a 3-bit class (most significant bits) and a 5-bit detail (least significant bits), documented as "c.dd" where "c" is a digit from 0 to 7 for the 3-bit subfield and "dd" are two digits from 00 to 31 for the 5-bit subfield.
The class can indicate a request (0), a success response (2), a client error response (4), or a server error response (5).
(All other class values are reserved.)
As a special case, Code 0.00 indicates an Empty message.
In case of a request, the Code field indicates the Request Method; in case of a response, a Response Code.
Possible values are maintained in the CoAP Code Registries (Section 12.1).
The semantics of requests and responses are defined in Section 5.
Message ID: 16-bit unsigned integer in network byte order.
Used to detect message duplication and to match messages of type Acknowledgement/Reset to messages of type Confirmable/Non-confirmable.
The rules for generating a Message ID and matching messages are defined in Section 4.
The header is followed by the Token value, which may be 0 to 8 bytes, as given by the Token Length field.
The Token value is used to correlate requests and responses.
The rules for generating a Token and correlating requests and responses are defined in Section 5.3.1.
Header and Token are followed by zero or more Options (Section 3.1).
An Option can be followed by the end of the message, by another Option, or by the Payload Marker and the payload.
Following the header, token, and options, if any, comes the optional payload.
If present and of non-zero length, it is prefixed by a fixed, one-byte Payload Marker (0xFF), which indicates the end of options and the start of the payload.
The payload data extends from after the marker to the end of the UDP datagram, i.e., the Payload Length is calculated from the datagram size.
The absence of the Payload Marker denotes a zero-length payload.
The presence of a marker followed by a zero-length payload MUST be processed as a message format error.
Implementation Note: The byte value 0xFF may also occur within an option length or value, so simple byte-wise scanning for 0xFF is not a viable technique for finding the payload marker.
The byte 0xFF has the meaning of a payload marker only where the beginning of another option could occur.
Option Format CoAP defines a number of options that can be included in a message.
Each option instance in a message specifies the Option Number of the defined CoAP option, the length of the Option Value, and the Option Value itself.
Instead of specifying the Option Number directly, the instances MUST appear in order of their Option Numbers and a delta encoding is used between them: the Option Number for each instance is calculated as the sum of its delta and the Option Number of the preceding instance in the message.
For the first instance in a message, a preceding option instance with Option Number zero is assumed.
Multiple instances of the same option can be included by using a delta of zero.
Option Numbers are maintained in the "CoAP Option Numbers" registry (Section 12.2).
See Section 5.4 for the semantics of the options defined in this document.
The fields in an option are defined as follows: Option Delta: 4-bit unsigned integer.
A value between 0 and 12 indicates the Option Delta.
Three values are reserved for special constructs: 13: An 8-bit unsigned integer follows the initial byte and indicates the Option Delta minus 13.
14: A 16-bit unsigned integer in network byte order follows the initial byte and indicates the Option Delta minus 269.
15: Reserved for the Payload Marker.
If the field is set to this value but the entire byte is not the payload marker, this MUST be processed as a message format error.
The resulting Option Delta is used as the difference between the Option Number of this option and that of the previous option (or zero for the first option).
In other words, the Option Number is calculated by simply summing the Option Delta values of this and all previous options before it.
Option Length: 4-bit unsigned integer.
A value between 0 and 12 indicates the length of the Option Value, in bytes.
Three values are reserved for special constructs: 13: An 8-bit unsigned integer precedes the Option Value and indicates the Option Length minus 13.
14: A 16-bit unsigned integer in network byte order precedes the Option Value and indicates the Option Length minus 269.
15: Reserved for future use.
If the field is set to this value, it MUST be processed as a message format error.
Value: A sequence of exactly Option Length bytes.
The length and format of the Option Value depend on the respective option, which MAY define variable-length values.
See Section 3.2 for the formats used in this document; options defined in other documents MAY make use of other option value formats.
Option Value Formats The options defined in this document make use of the following option value formats.
empty: A zero-length sequence of bytes.
opaque: An opaque sequence of bytes.
uint: A non-negative integer that is represented in network byte order using the number of bytes given by the Option Length field.
An option definition may specify a range of permissible numbers of bytes; if it has a choice, a sender SHOULD represent the integer with as few bytes as possible, i.e., without leading zero bytes.
For example, the number 0 is represented with an empty option value (a zero-length sequence of bytes) and the number 1 by a single byte with the numerical value of 1 (bit combination 00000001 in most significant bit first notation).
A recipient MUST be prepared to process values with leading zero bytes.
Implementation Note: The exceptional behavior permitted for the sender is intended for highly constrained, templated implementations (e.g., hardware implementations) that use fixed-size options in the templates.
string: A Unicode string that is encoded using UTF-8 [RFC3629] in Net-Unicode form [RFC5198].
Note that here, and in all other places where UTF-8 encoding is used in the CoAP protocol, the intention is that the encoded strings can be directly used and compared as opaque byte strings by CoAP protocol implementations.
There is no expectation and no need to perform normalization within a CoAP implementation (except where Unicode strings that are not known to be normalized are imported from sources outside the CoAP protocol).
Note also that ASCII strings (that do not make use of special control characters) are always valid UTF-8 Net-Unicode strings.
Message Transmission CoAP messages are exchanged asynchronously between CoAP endpoints.
They are used to transport CoAP requests and responses, the semantics of which are defined in Section 5.
As CoAP is bound to unreliable transports such as UDP, CoAP messages may arrive out of order, appear duplicated, or go missing without notice.
For this reason, CoAP implements a lightweight reliability mechanism, without trying to re-create the full feature set of a transport like TCP.
It has the following features: o Simple stop-and-wait retransmission reliability with exponential back-off for Confirmable messages.
o Duplicate detection for both Confirmable and Non-confirmable messages.
Messages and Endpoints A CoAP endpoint is the source or destination of a CoAP message.
The specific definition of an endpoint depends on the transport being used for CoAP.
For the transports defined in this specification, the endpoint is identified depending on the security mode used (see Section 9): With no security, the endpoint is solely identified by an IP address and a UDP port number.
With other security modes, the endpoint is identified as defined by the security mode.
There are different types of messages.
The type of a message is specified by the Type field of the CoAP Header.
Separate from the message type, a message may carry a request, a response, or be Empty.
This is signaled by the Request/Response Code field in the CoAP Header and is relevant to the request/response model.
Possible values for the field are maintained in the CoAP Code Registries (Section 12.1).
An Empty message has the Code field set to 0.00.
The Token Length field MUST be set to 0 and bytes of data MUST NOT be present after the Message ID field.
If there are any bytes, they MUST be processed as a message format error.
Messages Transmitted Reliably The reliable transmission of a message is initiated by marking the message as Confirmable in the CoAP header.
A Confirmable message always carries either a request or response, unless it is used only to elicit a Reset message, in which case it is Empty.
A recipient MUST either (a) acknowledge a Confirmable message with an Acknowledgement message or (b) reject the message if the recipient lacks context to process the message properly, including situations where the message is Empty, uses a code with a reserved class (1, 6, or 7), or has a message format error.
Rejecting a Confirmable message is effected by sending a matching Reset message and otherwise ignoring it.
The Acknowledgement message MUST echo the Message ID of the Confirmable message and MUST carry a response or be Empty (see Sections 5.2.1 and 5.2.2).
The Reset message MUST echo the Message ID of the Confirmable message and MUST be Empty.
Rejecting an Acknowledgement or Reset message (including the case where the Acknowledgement carries a request or a code with a reserved class, or the Reset message is not Empty) is effected by silently ignoring it.
More generally, recipients of Acknowledgement and Reset messages MUST NOT respond with either Acknowledgement or Reset messages.
The sender retransmits the Confirmable message at exponentially increasing intervals, until it receives an acknowledgement (or Reset message) or runs out of attempts.
Retransmission is controlled by two things that a CoAP endpoint MUST keep track of for each Confirmable message it sends while waiting for an acknowledgement (or reset): a timeout and a retransmission counter.
For a new Confirmable message, the initial timeout is set to a random duration (often not an integral number of seconds) between ACK_TIMEOUT and (ACK_TIMEOUT * ACK_RANDOM_FACTOR) (see Section 4.8), and the retransmission counter is set to 0.
When the timeout is triggered and the retransmission counter is less than MAX_RETRANSMIT, the message is retransmitted, the retransmission counter is incremented, and the timeout is doubled.
If the retransmission counter reaches MAX_RETRANSMIT on a timeout, or if the endpoint receives a Reset message, then the attempt to transmit the message is canceled and the application process informed of failure.
On the other hand, if the endpoint receives an acknowledgement in time, transmission is considered successful.
This specification makes no strong requirements on the accuracy of the clocks used to implement the above binary exponential back-off algorithm.
In particular, an endpoint may be late for a specific retransmission due to its sleep schedule and may catch up on the next one.
However, the minimum spacing before another retransmission is ACK_TIMEOUT, and the entire sequence of (re-)transmissions MUST stay in the envelope of MAX_TRANSMIT_SPAN (see Section 4.8.2), even if that means a sender may miss an opportunity to transmit.
A CoAP endpoint that sent a Confirmable message MAY give up in attempting to obtain an ACK even before the MAX_RETRANSMIT counter value is reached.
For example, the application has canceled the request as it no longer needs a response, or there is some other indication that the CON message did arrive.
In particular, a CoAP request message may have elicited a separate response, in which case it is clear to the requester that only the ACK was lost and a retransmission of the request would serve no purpose.
However, a responder MUST NOT in turn rely on this cross-layer behavior from a requester, i.e., it MUST retain the state to create the ACK for the request, if needed, even if a Confirmable response was already acknowledged by the requester.
Another reason for giving up retransmission MAY be the receipt of ICMP errors.
If it is desired to take account of ICMP errors, to mitigate potential spoofing attacks, implementations SHOULD take care to check the information about the original datagram in the ICMP message, including port numbers and CoAP header information such as message type and code, Message ID, and Token; if this is not possible due to limitations of the UDP service API, ICMP errors SHOULD be ignored.
Packet Too Big errors [RFC4443] ("fragmentation needed and DF set" for IPv4 [RFC0792]) cannot properly occur and SHOULD be ignored if the implementation note in Section 4.6 is followed; otherwise, they SHOULD feed into a path MTU discovery algorithm [RFC4821].
Source Quench and Time Exceeded ICMP messages SHOULD be ignored.
Host, network, port, or protocol unreachable errors or parameter problem errors MAY, after appropriate vetting, be used to inform the application of a failure in sending.
Messages Transmitted without Reliability Some messages do not require an acknowledgement.
This is particularly true for messages that are repeated regularly for application requirements, such as repeated readings from a sensor where eventual success is sufficient.
As a more lightweight alternative, a message can be transmitted less reliably by marking the message as Non-confirmable.
A Non-confirmable message always carries either a request or response and MUST NOT be Empty.
A Non-confirmable message MUST NOT be acknowledged by the recipient.
A recipient MUST reject the message if it lacks context to process the message properly, including the case where the message is Empty, uses a code with a reserved class (1, 6, or 7), or has a message format error.
Rejecting a Non-confirmable message MAY involve sending a matching Reset message, and apart from the Reset message the rejected message MUST be silently ignored.
At the CoAP level, there is no way for the sender to detect if a Non-confirmable message was received or not.
A sender MAY choose to transmit multiple copies of a Non-confirmable message within MAX_TRANSMIT_SPAN (limited by the provisions of Section 4.7, in particular, by PROBING_RATE if no response is received), or the network may duplicate the message in transit.
To enable the receiver to act only once on the message, Non-confirmable messages specify a Message ID as well.
(This Message ID is drawn from the same number space as the Message IDs for Confirmable messages.)
Summarizing Sections 4.2 and 4.3, the four message types can be used as in Table 1.
"*" means that the combination is not used in normal operation but only to elicit a Reset message ("CoAP ping").
Message Correlation An Acknowledgement or Reset message is related to a Confirmable message or Non-confirmable message by means of a Message ID along with additional address information of the corresponding endpoint.
The Message ID is a 16-bit unsigned integer that is generated by the sender of a Confirmable or Non-confirmable message and included in the CoAP header.
The Message ID MUST be echoed in the Acknowledgement or Reset message by the recipient.
The same Message ID MUST NOT be reused (in communicating with the same endpoint) within the EXCHANGE_LIFETIME (Section 4.8.2).
Implementation Note: Several implementation strategies can be employed for generating Message IDs.
In the simplest case, a CoAP endpoint generates Message IDs by keeping a single Message ID variable, which is changed each time a new Confirmable or Non-confirmable message is sent, regardless of the destination address or port.
Endpoints dealing with large numbers of transactions could keep multiple Message ID variables, for example, per prefix or destination address.
(Note that some receiving endpoints may not be able to distinguish unicast and multicast packets addressed to it, so endpoints generating Message IDs need to make sure these do not overlap.)
It is strongly recommended that the initial value of the variable (e.g., on startup) be randomized, in order to make successful off-path attacks on the protocol less likely.
For an Acknowledgement or Reset message to match a Confirmable or Non-confirmable message, the Message ID and source endpoint of the Acknowledgement or Reset message MUST match the Message ID and destination endpoint of the Confirmable or Non-confirmable message.
Message Deduplication A recipient might receive the same Confirmable message (as indicated by the Message ID and source endpoint) multiple times within the EXCHANGE_LIFETIME (Section 4.8.2), for example, when its Acknowledgement went missing or didn't reach the original sender before the first timeout.
The recipient SHOULD acknowledge each duplicate copy of a Confirmable message using the same Acknowledgement or Reset message but SHOULD process any request or response in the message only once.
This rule MAY be relaxed in case the Confirmable message transports a request that is idempotent (see Section 5.1) or can be handled in an idempotent fashion.
Examples for relaxed message deduplication: o A server might relax the requirement to answer all retransmissions of an idempotent request with the same response (Section 4.2), so that it does not have to maintain state for Message IDs.
For example, an implementation might want to process duplicate transmissions of a GET, PUT, or DELETE request as separate requests if the effort incurred by duplicate processing is less expensive than keeping track of previous responses would be.
o A constrained server might even want to relax this requirement for certain non-idempotent requests if the application semantics make this trade-off favorable.
For example, if the result of a POST request is just the creation of some short-lived state at the server, it may be less expensive to incur this effort multiple times for a request than keeping track of whether a previous transmission of the same request already was processed.
A recipient might receive the same Non-confirmable message (as indicated by the Message ID and source endpoint) multiple times within NON_LIFETIME (Section 4.8.2).
As a general rule that MAY be relaxed based on the specific semantics of a message, the recipient SHOULD silently ignore any duplicated Non-confirmable message and SHOULD process any request or response in the message only once.
Message Size While specific link layers make it beneficial to keep CoAP messages small enough to fit into their link-layer packets (see Section 1), this is a matter of implementation quality.
The CoAP specification itself provides only an upper bound to the message size.
Messages larger than an IP packet result in undesirable packet fragmentation.
A CoAP message, appropriately encapsulated, SHOULD fit within a single IP packet (i.e., avoid IP fragmentation) and (by fitting into one UDP payload) obviously needs to fit within a single IP datagram.
If the Path MTU is not known for a destination, an IP MTU of 1280 bytes SHOULD be assumed; if nothing is known about the size of the headers, good upper bounds are 1152 bytes for the message size and 1024 bytes for the payload size.
Implementation Note: CoAP's choice of message size parameters works well with IPv6 and with most of today's IPv4 paths.
(However, with IPv4, it is harder to absolutely ensure that there is no IP fragmentation.
If IPv4 support on unusual networks is a consideration, implementations may want to limit themselves to more conservative IPv4 datagram sizes such as 576 bytes; per [RFC0791], the absolute minimum value of the IP MTU for IPv4 is as low as 68 bytes, which would leave only 40 bytes minus security overhead for a UDP payload.
Implementations extremely focused on this problem set might also set the IPv4 DF bit and perform some form of path MTU discovery [RFC4821]; this should generally be unnecessary in realistic use cases for CoAP, however.)
A more important kind of fragmentation in many constrained networks is that on the adaptation layer (e.g., 6LoWPAN L2 packets are limited to 127 bytes including various overheads); this may motivate implementations to be frugal in their packet sizes and to move to block-wise transfers [BLOCK] when approaching three-digit message sizes.
Message sizes are also of considerable importance to implementations on constrained nodes.
Many implementations will need to allocate a buffer for incoming messages.
If an implementation is too constrained to allow for allocating the above-mentioned upper bound, it could apply the following implementation strategy for messages not using DTLS security: Implementations receiving a datagram into a buffer that is too small are usually able to determine if the trailing portion of a datagram was discarded and to retrieve the initial portion.
So, at least the CoAP header and options, if not all of the payload, are likely to fit within the buffer.
A server can thus fully interpret a request and return a 4.13 (Request Entity Too Large; see Section 5.9.2.9) Response Code if the payload was truncated.
A client sending an idempotent request and receiving a response larger than would fit in the buffer can repeat the request with a suitable value for the Block Option [BLOCK].
Congestion Control Basic congestion control for CoAP is provided by the exponential back-off mechanism in Section 4.2.
In order not to cause congestion, clients (including proxies) MUST strictly limit the number of simultaneous outstanding interactions that they maintain to a given server (including proxies) to NSTART.
An outstanding interaction is either a CON for which an ACK has not yet been received but is still expected (message layer) or a request for which neither a response nor an Acknowledgment message has yet been received but is still expected (which may both occur at the same time, counting as one outstanding interaction).
The default value of NSTART for this specification is 1.
Further congestion control optimizations and considerations are expected in the future, may for example provide automatic initialization of the CoAP transmission parameters defined in Section 4.8, and thus may allow a value for NSTART greater than one.
After EXCHANGE_LIFETIME, a client stops expecting a response to a Confirmable request for which no acknowledgment message was received.
The specific algorithm by which a client stops to "expect" a response to a Confirmable request that was acknowledged, or to a Non-confirmable request, is not defined.
Unless this is modified by additional congestion control optimizations, it MUST be chosen in such a way that an endpoint does not exceed an average data rate of PROBING_RATE in sending to another endpoint that does not respond.
Note: CoAP places the onus of congestion control mostly on the clients.
However, clients may malfunction or actually be attackers, e.g., to perform amplification attacks (Section 11.3).
To limit the damage (to the network and to its own energy resources), a server SHOULD implement some rate limiting for its response transmission based on reasonable assumptions about application requirements.
This is most helpful if the rate limit can be made effective for the misbehaving endpoints, only.
Changing the Parameters The values for ACK_TIMEOUT, ACK_RANDOM_FACTOR, MAX_RETRANSMIT, NSTART, DEFAULT_LEISURE (Section 8.2), and PROBING_RATE may be configured to values specific to the application environment (including dynamically adjusted values); however, the configuration method is out of scope of this document.
It is RECOMMENDED that an application environment use consistent values for these parameters; the specific effects of operating with inconsistent values in an application environment are outside the scope of the present specification.
The transmission parameters have been chosen to achieve a behavior in the presence of congestion that is safe in the Internet.
If a configuration desires to use different values, the onus is on the configuration to ensure these congestion control properties are not violated.
In particular, a decrease of ACK_TIMEOUT below 1 second would violate the guidelines of [RFC5405].
([RTO-CONSIDER] provides some additional background.)
CoAP was designed to enable implementations that do not maintain round-trip-time (RTT) measurements.
However, where it is desired to decrease the ACK_TIMEOUT significantly or increase NSTART, this can only be done safely when maintaining such measurements.
Configurations MUST NOT decrease ACK_TIMEOUT or increase NSTART without using mechanisms that ensure congestion control safety, either defined in the configuration or in future standards documents.
ACK_RANDOM_FACTOR MUST NOT be decreased below 1.0, and it SHOULD have a value that is sufficiently different from 1.0 to provide some protection from synchronization effects.
MAX_RETRANSMIT can be freely adjusted, but a value that is too small will reduce the probability that a Confirmable message is actually received, while a larger value than given here will require further adjustments in the time values (see Section 4.8.2).
If the choice of transmission parameters leads to an increase of derived time values (see Section 4.8.2), the configuration mechanism MUST ensure the adjusted value is also available to all the endpoints with which these adjusted values are to be used to communicate.
Time Values Derived from Transmission Parameters The combination of ACK_TIMEOUT, ACK_RANDOM_FACTOR, and MAX_RETRANSMIT influences the timing of retransmissions, which in turn influences how long certain information items need to be kept by an implementation.
To be able to unambiguously reference these derived time values, we give them names as follows: o MAX_TRANSMIT_SPAN is the maximum time from the first transmission of a Confirmable message to its last retransmission.
For the default transmission parameters, the value is (2+4+8+16)*1.5 = 45 seconds, or more generally: ACK_TIMEOUT * ((2 ** MAX_RETRANSMIT) -1) * ACK_RANDOM_FACTOR o MAX_TRANSMIT_WAIT is the maximum time from the first transmission of a Confirmable message to the time when the sender gives up on receiving an acknowledgement or reset.
For the default transmission parameters, the value is (2+4+8+16+32)*1.5 = 93 seconds, or more generally: ACK_TIMEOUT * ((2 ** (MAX_RETRANSMIT + 1)) -1) * ACK_RANDOM_FACTOR In addition, some assumptions need to be made on the characteristics of the network and the nodes.
o MAX_LATENCY is the maximum time a datagram is expected to take from the start of its transmission to the completion of its reception.
This constant is related to the MSL (Maximum Segment Lifetime) of [RFC0793], which is "arbitrarily defined to be 2 minutes" ([RFC0793] glossary, page 81).
Note that this is not necessarily smaller than MAX_TRANSMIT_WAIT, as MAX_LATENCY is not intended to describe a situation when the protocol works well, but the worst-case situation against which the protocol has to guard.
We, also arbitrarily, define MAX_LATENCY to be 100 seconds.
Apart from being reasonably realistic for the bulk of configurations as well as close to the historic choice for TCP, this value also allows Message ID lifetime timers to be represented in 8 bits (when measured in seconds).
In these calculations, there is no assumption that the direction of the transmission is irrelevant (i.e., that the network is symmetric); there is just the assumption that the same value can reasonably be used as a maximum value for both directions.
If that is not the case, the following calculations become only slightly more complex.
o PROCESSING_DELAY is the time a node takes to turn around a Confirmable message into an acknowledgement.
We assume the node will attempt to send an ACK before having the sender time out, so as a conservative assumption we set it equal to ACK_TIMEOUT.
o MAX_RTT is the maximum round-trip time, or: (2 * MAX_LATENCY) + PROCESSING_DELAY From these values, we can derive the following values relevant to the protocol operation: o EXCHANGE_LIFETIME is the time from starting to send a Confirmable message to the time when an acknowledgement is no longer expected, i.e., message-layer information about the message exchange can be purged.
EXCHANGE_LIFETIME includes a MAX_TRANSMIT_SPAN, a MAX_LATENCY forward, PROCESSING_DELAY, and a MAX_LATENCY for the way back.
Note that there is no need to consider MAX_TRANSMIT_WAIT if the configuration is chosen such that the last waiting period (ACK_TIMEOUT * (2 ** MAX_RETRANSMIT) or the difference between MAX_TRANSMIT_SPAN and MAX_TRANSMIT_WAIT) is less than MAX_LATENCY --which is a likely choice, as MAX_LATENCY is a worst-case value unlikely to be met in the real world.
In this case, EXCHANGE_LIFETIME simplifies to: MAX_TRANSMIT_SPAN + (2 * MAX_LATENCY) + PROCESSING_DELAY or 247 seconds with the default transmission parameters.
o NON_LIFETIME is the time from sending a Non-confirmable message to the time its Message ID can be safely reused.
If multiple transmission of a NON message is not used, its value is MAX_LATENCY, or 100 seconds.
However, a CoAP sender might send a NON message multiple times, in particular for multicast applications.
While the period of reuse is not bounded by the specification, an expectation of reliable detection of duplication at the receiver is on the timescales of MAX_TRANSMIT_SPAN.
Therefore, for this purpose, it is safer to use the value: MAX_TRANSMIT_SPAN + MAX_LATENCY or 145 seconds with the default transmission parameters; however, an implementation that just wants to use a single timeout value for retiring Message IDs can safely use the larger value for EXCHANGE_LIFETIME.
Table 3 lists the derived parameters introduced in this subsection.
with their default values.
Request/Response Semantics CoAP operates under a similar request/response model as HTTP: a CoAP endpoint in the role of a "client" sends one or more CoAP requests to a "server", which services the requests by sending CoAP responses.
Unlike HTTP, requests and responses are not sent over a previously established connection but are exchanged asynchronously over CoAP messages.
Requests A CoAP request consists of the method to be applied to the resource, the identifier of the resource, a payload and Internet media type (if any), and optional metadata about the request.
CoAP supports the basic methods of GET, POST, PUT, and DELETE, which are easily mapped to HTTP.
They have the same properties of safe (only retrieval) and idempotent (you can invoke it multiple times with the same effects) as HTTP (see SectionÂ 9.1 of [RFC2616]).
The GET method is safe; therefore, it MUST NOT take any other action on a resource other than retrieval.
The GET, PUT, and DELETE methods MUST be performed in such a way that they are idempotent.
POST is not idempotent, because its effect is determined by the origin server and dependent on the target resource; it usually results in a new resource being created or the target resource being updated.
A request is initiated by setting the Code field in the CoAP header of a Confirmable or a Non-confirmable message to a Method Code and including request information.
The methods used in requests are described in detail in Section 5.8.
Responses After receiving and interpreting a request, a server responds with a CoAP response that is matched to the request by means of a client-generated token (Section 5.3); note that this is different from the Message ID that matches a Confirmable message to its Acknowledgement.
A response is identified by the Code field in the CoAP header being set to a Response Code.
Similar to the HTTP Status Code, the CoAP Response Code indicates the result of the attempt to understand and satisfy the request.
These codes are fully defined in Section 5.9.
The Response Code numbers to be set in the Code field of the CoAP header are maintained in the CoAP Response Code Registry (Section 12.1.2).
The upper three bits of the 8-bit Response Code number define the class of response.
The lower five bits do not have any categorization role; they give additional detail to the overall class (Figure 9).
As a human-readable notation for specifications and protocol diagnostics, CoAP code numbers including the Response Code are documented in the format "c.dd", where "c" is the class in decimal, and "dd" is the detail as a two-digit decimal.
For example, "Forbidden" is written as 4.03 --indicating an 8-bit code value of hexadecimal 0x83 (4*0x20+3) or decimal 131 (4*32+3).
There are 3 classes of Response Codes: 2 -Success: The request was successfully received, understood, and accepted.
4 -Client Error: The request contains bad syntax or cannot be fulfilled.
5 -Server Error: The server failed to fulfill an apparently valid request.
The Response Codes are designed to be extensible: Response Codes in the Client Error or Server Error class that are unrecognized by an endpoint are treated as being equivalent to the generic Response Code of that class (4.00 and 5.00, respectively).
However, there is no generic Response Code indicating success, so a Response Code in the Success class that is unrecognized by an endpoint can only be used to determine that the request was successful without any further details.
The possible Response Codes are described in detail in Section 5.9.
Responses can be sent in multiple ways, which are defined in the following subsections.
Piggybacked In the most basic case, the response is carried directly in the Acknowledgement message that acknowledges the request (which requires that the request was carried in a Confirmable message).
This is called a "Piggybacked Response".
The response is returned in the Acknowledgement message, independent of whether the response indicates success or failure.
In effect, the response is piggybacked on the Acknowledgement message, and no separate message is required to return the response.
Implementation Note: The protocol leaves the decision whether to piggyback a response or not (i.e., send a separate response) to the server.
The client MUST be prepared to receive either.
On the quality-of-implementation level, there is a strong expectation that servers will implement code to piggyback whenever possible --saving resources in the network and both at the client and at the server.
Separate It may not be possible to return a piggybacked response in all cases.
For example, a server might need longer to obtain the representation of the resource requested than it can wait to send back the Acknowledgement message, without risking the client repeatedly retransmitting the request message (see also the discussion of PROCESSING_DELAY in Section 4.8.2).
The response to a request carried in a Non-confirmable message is always sent separately (as there is no Acknowledgement message).
One way to implement this in a server is to initiate the attempt to obtain the resource representation and, while that is in progress, time out an acknowledgement timer.
A server may also immediately send an acknowledgement if it knows in advance that there will be no piggybacked response.
In both cases, the acknowledgement effectively is a promise that the request will be acted upon later.
When the server finally has obtained the resource representation, it sends the response.
When it is desired that this message is not lost, it is sent as a Confirmable message from the server to the client and answered by the client with an Acknowledgement, echoing the new Message ID chosen by the server.
(It may also be sent as a Non-confirmable message; see Section 5.2.3.)
When the server chooses to use a separate response, it sends the Acknowledgement to the Confirmable request as an Empty message.
Once the server sends back an Empty Acknowledgement, it MUST NOT send back the response in another Acknowledgement, even if the client retransmits another identical request.
If a retransmitted request is received (perhaps because the original Acknowledgement was delayed), another Empty Acknowledgement is sent, and any response MUST be sent as a separate response.
If the server then sends a Confirmable response, the client's Acknowledgement to that response MUST also be an Empty message (one that carries neither a request nor a response).
The server MUST stop retransmitting its response on any matching Acknowledgement (silently ignoring any Response Code or payload) or Reset message.
Implementation Notes: Note that, as the underlying datagram transport may not be sequence-preserving, the Confirmable message carrying the response may actually arrive before or after the Acknowledgement message for the request; for the purposes of terminating the retransmission sequence, this also serves as an acknowledgement.
Note also that, while the CoAP protocol itself does not make any specific demands here, there is an expectation that the response will come within a time frame that is reasonable from an application point of view.
As there is no underlying transport protocol that could be instructed to run a keep-alive mechanism, the requester may want to set up a timeout that is unrelated to CoAP's retransmission timers in case the server is destroyed or otherwise unable to send the response.
Non-confirmable If the request message is Non-confirmable, then the response SHOULD be returned in a Non-confirmable message as well.
However, an endpoint MUST be prepared to receive a Non-confirmable response (preceded or followed by an Empty Acknowledgement message) in reply to a Confirmable request, or a Confirmable response in reply to a Non-confirmable request.
Request/Response Matching Regardless of how a response is sent, it is matched to the request by means of a token that is included by the client in the request, along with additional address information of the corresponding endpoint.
Token The Token is used to match a response with a request.
The token value is a sequence of 0 to 8 bytes.
(Note that every message carries a token, even if it is of zero length.)
Every request carries a client-generated token that the server MUST echo (without modification) in any resulting response.
A token is intended for use as a client-local identifier for differentiating between concurrent requests (see Section 5.3); it could have been called a "request ID".
The client SHOULD generate tokens in such a way that tokens currently in use for a given source/destination endpoint pair are unique.
(Note that a client implementation can use the same token for any request if it uses a different endpoint each time, e.g., a different source port number.)
An empty token value is appropriate e.g., when no other tokens are in use to a destination, or when requests are made serially per destination and receive piggybacked responses.
There are, however, multiple possible implementation strategies to fulfill this.
A client sending a request without using Transport Layer Security (Section 9) SHOULD use a nontrivial, randomized token to guard against spoofing of responses (Section 11.4).
This protective use of tokens is the reason they are allowed to be up to 8 bytes in size.
The actual size of the random component to be used for the Token depends on the security requirements of the client and the level of threat posed by spoofing of responses.
A client that is connected to the general Internet SHOULD use at least 32 bits of randomness, keeping in mind that not being directly connected to the Internet is not necessarily sufficient protection against spoofing.
(Note that the Message ID adds little in protection as it is usually sequentially assigned, i.e., guessable, and can be circumvented by spoofing a separate response.)
Clients that want to optimize the Token length may further want to detect the level of ongoing attacks (e.g., by tallying recent Token mismatches in incoming messages) and adjust the Token length upwards appropriately.
[RFC4086] discusses randomness requirements for security.
An endpoint receiving a token it did not generate MUST treat the token as opaque and make no assumptions about its content or structure.
Request/Response Matching Rules The exact rules for matching a response to a request are as follows: 1.
The source endpoint of the response MUST be the same as the destination endpoint of the original request.
In a piggybacked response, the Message ID of the Confirmable request and the Acknowledgement MUST match, and the tokens of the response and original request MUST match.
In a separate response, just the tokens of the response and original request MUST match.
In case a message carrying a response is unexpected (the client is not waiting for a response from the identified endpoint, at the endpoint addressed, and/or with the given token), the response is rejected (Sections 4.2 and 4.3).
Implementation Note: A client that receives a response in a CON message may want to clean up the message state right after sending the ACK.
If that ACK is lost and the server retransmits the CON, the client may no longer have any state to which to correlate this response, making the retransmission an unexpected message; the client will likely send a Reset message so it does not receive any more retransmissions.
This behavior is normal and not an indication of an error.
(Clients that are not aggressively optimized in their state memory usage will still have message state that will identify the second CON as a retransmission.
Clients that actually expect more messages from the server [OBSERVE] will have to keep state in any case.)
Options Both requests and responses may include a list of one or more options.
For example, the URI in a request is transported in several options, and metadata that would be carried in an HTTP header in HTTP is supplied as options as well.
CoAP defines a single set of options that are used in both requests and responses: o Content-Format o ETag o Location-Path o Location-Query o Max-Age o Proxy-Uri o Proxy-Scheme o Uri-Host o Uri-Path o Uri-Port o Uri-Query o Accept o If-Match o If-None-Match o Size1 The semantics of these options along with their properties are defined in detail in Section 5.10.
Not all options are defined for use with all methods and Response Codes.
The possible options for methods and Response Codes are defined in Sections 5.8 and 5.9, respectively.
In case an option is not defined for a Method or Response Code, it MUST NOT be included by a sender and MUST be treated like an unrecognized option by a recipient.
Critical/Elective Options fall into one of two classes: "critical" or "elective".
The difference between these is how an option unrecognized by an endpoint is handled: o Upon reception, unrecognized options of class "elective" MUST be silently ignored.
o Unrecognized options of class "critical" that occur in a Confirmable request MUST cause the return of a 4.02 (Bad Option) response.
This response SHOULD include a diagnostic payload describing the unrecognized option(s) (see Section 5.5.2).
o Unrecognized options of class "critical" that occur in a Confirmable response, or piggybacked in an Acknowledgement, MUST cause the response to be rejected (Section 4.2).
o Unrecognized options of class "critical" that occur in a Non-confirmable message MUST cause the message to be rejected (Section 4.3).
Note that, whether critical or elective, an option is never "mandatory" (it is always optional): these rules are defined in order to enable implementations to stop processing options they do not understand or implement.
Critical/elective rules apply to non-proxying endpoints.
A proxy processes options based on Unsafe/Safe-to-Forward classes as defined in Section 5.7.
Proxy Unsafe or Safe-to-Forward and NoCacheKey In addition to an option being marked as critical or elective, options are also classified based on how a proxy is to deal with the option if it does not recognize it.
For this purpose, an option can either be considered Unsafe to forward (UnSafe is set) or Safe-to-Forward (UnSafe is clear).
In addition, for an option that is marked Safe-to-Forward, the option number indicates whether or not it is intended to be part of the Cache-Key (Section 5.6) in a request.
If some of the NoCacheKey bits are 0, it is; if all NoCacheKey bits are 1, it is not (see Section 5.4.6).
Note: The Cache-Key indication is relevant only for proxies that do not implement the given option as a request option and instead rely on the Unsafe/Safe-to-Forward indication only.
For example, for ETag, actually using the request option as a part of the Cache-Key is grossly inefficient, but it is the best thing one can do if ETag is not implemented by a proxy, as the response is going to differ based on the presence of the request option.
A more useful proxy that does implement the ETag request option is not using ETag as a part of the Cache-Key.
NoCacheKey is indicated in three bits so that only one out of eight codepoints is qualified as NoCacheKey, leaving seven out of eight codepoints for what appears to be the more likely case.
Proxy behavior with regard to these classes is defined in Section 5.7.
Length Option values are defined to have a specific length, often in the form of an upper and lower bound.
If the length of an option value in a request is outside the defined range, that option MUST be treated like an unrecognized option (see Section 5.4.1).
Default Values Options may be defined to have a default value.
If the value of an option is intended to be this default value, the option SHOULD NOT be included in the message.
If the option is not present, the default value MUST be assumed.
Where a critical option has a default value, this is chosen in such a way that the absence of the option in a message can be processed properly both by implementations unaware of the critical option and by implementations that interpret this absence as the presence of the default value for the option.
Repeatable Options The definition of some options specifies that those options are repeatable.
An option that is repeatable MAY be included one or more times in a message.
An option that is not repeatable MUST NOT be included more than once in a message.
If a message includes an option with more occurrences than the option is defined for, each supernumerary option occurrence that appears subsequently in the message MUST be treated like an unrecognized option (see Section 5.4.1).
Option Numbers An Option is identified by an option number, which also provides some additional semantics information, e.g., odd numbers indicate a critical option, while even numbers indicate an elective option.
Note that this is not just a convention, it is a feature of the protocol: Whether an option is elective or critical is entirely determined by whether its option number is even or odd.
More generally speaking, an Option number is constructed with a bit mask to indicate if an option is Critical or Elective, Unsafe or Safe-to-Forward, and, in the case of Safe-to-Forward, to provide a Cache-Key indication as shown by the following figure.
In the following text, the bit mask is expressed as a single byte that is applied to the least significant byte of the option number in unsigned integer representation.
When bit 7 (the least significant bit) is 1, an option is Critical (and likewise Elective when 0).
When bit 6 is 1, an option is Unsafe (and likewise Safe-to-Forward when 0).
When bit 6 is 0, i.e., the option is not Unsafe, it is not a Cache-Key (NoCacheKey) if and only if bits 3-5 are all set to 1; all other bit combinations mean that it indeed is a Cache-Key.
These classes of options are explained in the next sections.
An endpoint may use an equivalent of the C code in Figure 11 to derive the characteristics of an option number "onum".
The option numbers for the options defined in this document are listed in the "CoAP Option Numbers" registry (Section 12.2).
Payloads and Representations Both requests and responses may include a payload, depending on the Method or Response Code, respectively.
If a Method or Response Code is not defined to have a payload, then a sender MUST NOT include one, and a recipient MUST ignore it.
Representation The payload of requests or of responses indicating success is typically a representation of a resource ("resource representation") or the result of the requested action ("action result").
Its format is specified by the Internet media type and content coding given by the Content-Format Option.
In the absence of this option, no default value is assumed, and the format will need to be inferred by the application (e.g., from the application context).
Payload "sniffing" SHOULD only be attempted if no content type is given.
Implementation Note: On a quality-of-implementation level, there is a strong expectation that a Content-Format indication will be provided with resource representations whenever possible.
This is not a "SHOULD" level requirement solely because it is not a protocol requirement, and it also would be difficult to outline exactly in what cases this expectation can be violated.
For responses indicating a client or server error, the payload is considered a representation of the result of the requested action only if a Content-Format Option is given.
In the absence of this option, the payload is a Diagnostic Payload (Section 5.5.2).
Diagnostic Payload If no Content-Format option is given, the payload of responses indicating a client or server error is a brief human-readable diagnostic message, explaining the error situation.
This diagnostic message MUST be encoded using UTF-8 [RFC3629], more specifically using Net-Unicode form [RFC5198].
The message is similar to the Reason-Phrase on an HTTP status line.
It is not intended for end users but for software engineers that during debugging need to interpret it in the context of the present, English-language specification; therefore, no mechanism for language tagging is needed or provided.
In contrast to what is usual in HTTP, the payload SHOULD be empty if there is no additional information beyond the Response Code.
Selected Representation Not all responses carry a payload that provides a representation of the resource addressed by the request.
It is, however, sometimes useful to be able to refer to such a representation in relation to a response, independent of whether it actually was enclosed.
We use the term "selected representation" to refer to the current representation of a target resource that would have been selected in a successful response if the corresponding request had used the method GET and excluded any conditional request options (Section 5.10.8).
Certain response options provide metadata about the selected representation, which might differ from the representation included in the message for responses to some state-changing methods.
Of the response options defined in this specification, only the ETag response option (Section 5.10.6) is defined as metadata about the selected representation.
Content Negotiation A server may be able to supply a representation for a resource in one of multiple representation formats.
Without further information from the client, it will provide the representation in the format it prefers.
By using the Accept Option (Section 5.10.4) in a request, the client can indicate which content-format it prefers to receive.
Caching CoAP endpoints MAY cache responses in order to reduce the response time and network bandwidth consumption on future, equivalent requests.
The goal of caching in CoAP is to reuse a prior response message to satisfy a current request.
In some cases, a stored response can be reused without the need for a network request, reducing latency and network round-trips; a "freshness" mechanism is used for this purpose (see Section 5.6.1).
Even when a new request is required, it is often possible to reuse the payload of a prior response to satisfy the request, thereby reducing network bandwidth usage; a "validation" mechanism is used for this purpose (see Section 5.6.2).
Unlike HTTP, the cacheability of CoAP responses does not depend on the request method, but it depends on the Response Code.
The cacheability of each Response Code is defined along the Response Code definitions in Section 5.9.
Response Codes that indicate success and are unrecognized by an endpoint MUST NOT be cached.
For a presented request, a CoAP endpoint MUST NOT use a stored response, unless: o the presented request method and that used to obtain the stored response match, o all options match between those in the presented request and those of the request used to obtain the stored response (which includes the request URI), except that there is no need for a match of any request options marked as NoCacheKey (Section 5.4) or recognized by the Cache and fully interpreted with respect to its specified cache behavior (such as the ETag request option described in Section 5.10.6; see also Section 5.4.2), and o the stored response is either fresh or successfully validated as defined below.
The set of request options that is used for matching the cache entry is also collectively referred to as the "Cache-Key".
For URI schemes other than coap and coaps, matching of those options that constitute the request URI may be performed under rules specific to the URI scheme.
Freshness Model When a response is "fresh" in the cache, it can be used to satisfy subsequent requests without contacting the origin server, thereby improving efficiency.
The mechanism for determining freshness is for an origin server to provide an explicit expiration time in the future, using the Max-Age Option (see Section 5.10.5).
The Max-Age Option indicates that the response is to be considered not fresh after its age is greater than the specified number of seconds.
The Max-Age Option defaults to a value of 60.
Thus, if it is not present in a cacheable response, then the response is considered not fresh after its age is greater than 60 seconds.
If an origin server wishes to prevent caching, it MUST explicitly include a Max-Age Option with a value of zero seconds.
If a client has a fresh stored response and makes a new request matching the request for that stored response, the new response invalidates the old response.
Validation Model When an endpoint has one or more stored responses for a GET request, but cannot use any of them (e.g., because they are not fresh), it can use the ETag Option (Section 5.10.6) in the GET request to give the origin server an opportunity both to select a stored response to be used, and to update its freshness.
This process is known as "validating" or "revalidating" the stored response.
When sending such a request, the endpoint SHOULD add an ETag Option specifying the entity-tag of each stored response that is applicable.
A 2.03 (Valid) response indicates the stored response identified by the entity-tag given in the response's ETag Option can be reused after updating it as described in Section 5.9.1.3.
Any other Response Code indicates that none of the stored responses nominated in the request is suitable.
Instead, the response SHOULD be used to satisfy the request and MAY replace the stored response.
Proxying A proxy is a CoAP endpoint that can be tasked by CoAP clients to perform requests on their behalf.
This may be useful, for example, when the request could otherwise not be made, or to service the response from a cache in order to reduce response time and network bandwidth or energy consumption.
In an overall architecture for a Constrained RESTful Environment, proxies can serve quite different purposes.
Proxies can be explicitly selected by clients, a role that we term "forward-proxy".
Proxies can also be inserted to stand in for origin servers, a role that we term "reverse-proxy".
Orthogonal to this distinction, a proxy can map from a CoAP request to a CoAP request (CoAP-to-CoAP proxy) or translate from or to a different protocol ("cross-proxy").
Full definitions of these terms are provided in Section 1.2.
Notes: The terminology in this specification has been selected to be culturally compatible with the terminology used in the wider web application environments, without necessarily matching it in every detail (which may not even be relevant to Constrained RESTful Environments).
Not too much semantics should be ascribed to the components of the terms (such as "forward", "reverse", or "cross").
HTTP proxies, besides acting as HTTP proxies, often offer a transport-protocol proxying function ("CONNECT") to enable end-to-end transport layer security through the proxy.
No such function is defined for CoAP-to-CoAP proxies in this specification, as forwarding of UDP packets is unlikely to be of much value in Constrained RESTful Environments.
See also Section 10.2.7 for the cross-proxy case.
When a client uses a proxy to make a request that will use a secure URI scheme (e.g., "coaps" or "https"), the request towards the proxy SHOULD be sent using DTLS except where equivalent lower-layer security is used for the leg between the client and the proxy.
Proxy Operation A proxy generally needs a way to determine potential request parameters for a request it places to a destination, based on the request it received from its client.
This way is fully specified for a forward-proxy but may depend on the specific configuration for a reverse-proxy.
In particular, the client of a reverse-proxy generally does not indicate a locator for the destination, necessitating some form of namespace translation in the reverse-proxy.
However, some aspects of the operation of proxies are common to all its forms.
If a proxy does not employ a cache, then it simply forwards the translated request to the determined destination.
Otherwise, if it does employ a cache but does not have a stored response that matches the translated request and is considered fresh, then it needs to refresh its cache according to Section 5.6.
For options in the request that the proxy recognizes, it knows whether the option is intended to act as part of the key used in looking up the cached value or not.
For example, since requests for different Uri-Path values address different resources, Uri-Path values are always part of the Cache-Key, while, e.g., Token values are never part of the Cache-Key.
For options that the proxy does not recognize but that are marked Safe-to-Forward in the option number, the option also indicates whether it is to be included in the Cache-Key (NoCacheKey is not all set) or not (NoCacheKey is all set).
(Options that are unrecognized and marked Unsafe lead to 4.02 Bad Option.)
If the request to the destination times out, then a 5.04 (Gateway Timeout) response MUST be returned.
If the request to the destination returns a response that cannot be processed by the proxy (e.g, due to unrecognized critical options or message format errors), then a 5.02 (Bad Gateway) response MUST be returned.
Otherwise, the proxy returns the response to the client.
If a response is generated out of a cache, the generated (or implied) Max-Age Option MUST NOT extend the max-age originally set by the server, considering the time the resource representation spent in the cache.
For example, the Max-Age Option could be adjusted by the proxy for each response using the formula: proxy-max-age = original-max-age -cache-age For example, if a request is made to a proxied resource that was refreshed 20 seconds ago and had an original Max-Age of 60 seconds, then that resource's proxied max-age is now 40 seconds.
Considering potential network delays on the way from the origin server, a proxy should be conservative in the max-age values offered.
All options present in a proxy request MUST be processed at the proxy.
Unsafe options in a request that are not recognized by the proxy MUST lead to a 4.02 (Bad Option) response being returned by the proxy.
A CoAP-to-CoAP proxy MUST forward to the origin server all Safe-to-Forward options that it does not recognize.
Similarly, Unsafe options in a response that are not recognized by the CoAP-to-CoAP proxy server MUST lead to a 5.02 (Bad Gateway) response.
Again, Safe-to-Forward options that are not recognized MUST be forwarded.
Additional considerations for cross-protocol proxying between CoAP and HTTP are discussed in Section 10.
Forward-Proxies CoAP distinguishes between requests made (as if) to an origin server and requests made through a forward-proxy.
CoAP requests to a forward-proxy are made as normal Confirmable or Non-confirmable requests to the forward-proxy endpoint, but they specify the request URI in a different way: The request URI in a proxy request is specified as a string in the Proxy-Uri Option (see Section 5.10.2), while the request URI in a request to an origin server is split into the Uri-Host, Uri-Port, Uri-Path, and Uri-Query Options (see Section 5.10.1).
Alternatively, the URI in a proxy request can be assembled from a Proxy-Scheme option and the split options mentioned.
When a proxy request is made to an endpoint and the endpoint is unwilling or unable to act as proxy for the request URI, it MUST return a 5.05 (Proxying Not Supported) response.
If the authority (host and port) is recognized as identifying the proxy endpoint itself (see Section 5.10.2), then the request MUST be treated as a local (non-proxied) request.
Unless a proxy is configured to forward the proxy request to another proxy, it MUST translate the request as follows: the scheme of the request URI defines the outgoing protocol and its details (e.g., CoAP is used over UDP for the "coap" scheme and over DTLS for the "coaps" scheme.)
For a CoAP-to-CoAP proxy, the origin server's IP address and port are determined by the authority component of the request URI, and the request URI is decoded and split into the Uri-Host, Uri-Port, Uri-Path and Uri-Query Options.
This consumes the Proxy-Uri or Proxy-Scheme option, which is therefore not forwarded to the origin server.
Reverse-Proxies Reverse-proxies do not make use of the Proxy-Uri or Proxy-Scheme options but need to determine the destination (next hop) of a request from information in the request and information in their configuration.
For example, a reverse-proxy might offer various resources as if they were its own resources, after having learned of their existence through resource discovery.
The reverse-proxy is free to build a namespace for the URIs that identify these resources.
A reverse-proxy may also build a namespace that gives the client more control over where the request goes, e.g., by embedding host identifiers and port numbers into the URI path of the resources offered.
In processing the response, a reverse-proxy has to be careful that ETag option values from different sources are not mixed up on one resource offered to its clients.
In many cases, the ETag can be forwarded unchanged.
If the mapping from a resource offered by the reverse-proxy to resources offered by its various origin servers is not unique, the reverse-proxy may need to generate a new ETag, making sure the semantics of this option are properly preserved.
Method Definitions In this section, each method is defined along with its behavior.
A request with an unrecognized or unsupported Method Code MUST generate a 4.05 (Method Not Allowed) piggybacked response.
GET The GET method retrieves a representation for the information that currently corresponds to the resource identified by the request URI.
If the request includes an Accept Option, that indicates the preferred content-format of a response.
If the request includes an ETag Option, the GET method requests that ETag be validated and that the representation be transferred only if validation failed.
Upon success, a 2.05 (Content) or 2.03 (Valid) Response Code SHOULD be present in the response.
The GET method is safe and idempotent.
POST The POST method requests that the representation enclosed in the request be processed.
The actual function performed by the POST method is determined by the origin server and dependent on the target resource.
It usually results in a new resource being created or the target resource being updated.
If a resource has been created on the server, the response returned by the server SHOULD have a 2.01 (Created) Response Code and SHOULD include the URI of the new resource in a sequence of one or more Location-Path and/or Location-Query Options (Section 5.10.7).
If the POST succeeds but does not result in a new resource being created on the server, the response SHOULD have a 2.04 (Changed) Response Code.
If the POST succeeds and results in the target resource being deleted, the response SHOULD have a 2.02 (Deleted) Response Code.
POST is neither safe nor idempotent.
PUT The PUT method requests that the resource identified by the request URI be updated or created with the enclosed representation.
The representation format is specified by the media type and content coding given in the Content-Format Option, if provided.
If a resource exists at the request URI, the enclosed representation SHOULD be considered a modified version of that resource, and a 2.04 (Changed) Response Code SHOULD be returned.
If no resource exists, then the server MAY create a new resource with that URI, resulting in a 2.01 (Created) Response Code.
If the resource could not be created or modified, then an appropriate error Response Code SHOULD be sent.
Further restrictions to a PUT can be made by including the If-Match (see Section 5.10.8.1) or If-None-Match (see Section 5.10.8.2) options in the request.
PUT is not safe but is idempotent.
DELETE The DELETE method requests that the resource identified by the request URI be deleted.
A 2.02 (Deleted) Response Code SHOULD be used on success or in case the resource did not exist before the request.
DELETE is not safe but is idempotent.
Response Code Definitions Each Response Code is described below, including any options required in the response.
Where appropriate, some of the codes will be specified in regards to related Response Codes in HTTP [RFC2616]; this does not mean that any such relationship modifies the HTTP mapping specified in Section 10.
Success 2.xx This class of Response Code indicates that the clients request was successfully received, understood, and accepted.
2.01 Created Like HTTP 201 "Created", but only used in response to POST and PUT requests.
The payload returned with the response, if any, is a representation of the action result.
If the response includes one or more Location-Path and/or Location-Query Options, the values of these options specify the location at which the resource was created.
Otherwise, the resource was created at the request URI.
A cache receiving this response MUST mark any stored response for the created resource as not fresh.
This response is not cacheable.
2.02 Deleted This Response Code is like HTTP 204 "No Content" but only used in response to requests that cause the resource to cease being available, such as DELETE and, in certain circumstances, POST.
The payload returned with the response, if any, is a representation of the action result.
This response is not cacheable.
However, a cache MUST mark any stored response for the deleted resource as not fresh.
2.03 Valid This Response Code is related to HTTP 304 "Not Modified" but only used to indicate that the response identified by the entity-tag identified by the included ETag Option is valid.
Accordingly, the response MUST include an ETag Option and MUST NOT include a payload.
When a cache that recognizes and processes the ETag response option receives a 2.03 (Valid) response, it MUST update the stored response with the value of the Max-Age Option included in the response (explicitly, or implicitly as a default value; see also Section 5.6.2).
For each type of Safe-to-Forward option present in the response, the (possibly empty) set of options of this type that are present in the stored response MUST be replaced with the set of options of this type in the response received.
(Unsafe options may trigger similar option-specific processing as defined by the option.)
2.04 Changed This Response Code is like HTTP 204 "No Content" but only used in response to POST and PUT requests.
The payload returned with the response, if any, is a representation of the action result.
This response is not cacheable.
However, a cache MUST mark any stored response for the changed resource as not fresh.
2.05 Content This Response Code is like HTTP 200 "OK" but only used in response to GET requests.
The payload returned with the response is a representation of the target resource.
This response is cacheable: Caches can use the Max-Age Option to determine freshness (see Section 5.6.1) and (if present) the ETag Option for validation (see Section 5.6.2).
Client Error 4.xx This class of Response Code is intended for cases in which the client seems to have erred.
These Response Codes are applicable to any request method.
The server SHOULD include a diagnostic payload under the conditions detailed in Section 5.5.2.
Responses of this class are cacheable: Caches can use the Max-Age Option to determine freshness (see Section 5.6.1).
They cannot be validated.
4.00 Bad Request This Response Code is Like HTTP 400 "Bad Request".
4.01 Unauthorized The client is not authorized to perform the requested action.
The client SHOULD NOT repeat the request without first improving its authentication status to the server.
Which specific mechanism can be used for this is outside this document's scope; see also Section 9.
4.02 Bad Option The request could not be understood by the server due to one or more unrecognized or malformed options.
The client SHOULD NOT repeat the request without modification.
4.03 Forbidden This Response Code is like HTTP 403 "Forbidden".
4.04 Not Found This Response Code is like HTTP 404 "Not Found".
4.05 Method Not Allowed This Response Code is like HTTP 405 "Method Not Allowed" but with no parallel to the "Allow" header field.
4.06 Not Acceptable This Response Code is like HTTP 406 "Not Acceptable", but with no response entity.
4.12 Precondition Failed This Response Code is like HTTP 412 "Precondition Failed".
4.13 Request Entity Too Large This Response Code is like HTTP 413 "Request Entity Too Large".
The response SHOULD include a Size1 Option (Section 5.10.9) to indicate the maximum size of request entity the server is able and willing to handle, unless the server is not in a position to make this information available.
4.15 Unsupported Content-Format This Response Code is like HTTP 415 "Unsupported Media Type".
Server Error 5.xx This class of Response Code indicates cases in which the server is aware that it has erred or is incapable of performing the request.
These Response Codes are applicable to any request method.
The server SHOULD include a diagnostic payload under the conditions detailed in Section 5.5.2.
Responses of this class are cacheable: Caches can use the Max-Age Option to determine freshness (see Section 5.6.1).
They cannot be validated.
5.00 Internal Server Error This Response Code is like HTTP 500 "Internal Server Error".
5.01 Not Implemented This Response Code is like HTTP 501 "Not Implemented".
5.02 Bad Gateway This Response Code is like HTTP 502 "Bad Gateway".
5.03 Service Unavailable This Response Code is like HTTP 503 "Service Unavailable" but uses the Max-Age Option in place of the "Retry-After" header field to indicate the number of seconds after which to retry.
5.04 Gateway Timeout This Response Code is like HTTP 504 "Gateway Timeout".
5.05 Proxying Not Supported The server is unable or unwilling to act as a forward-proxy for the URI specified in the Proxy-Uri Option or using Proxy-Scheme (see Section 5.10.2).
Option Definitions The individual CoAP options are summarized in Table 4 and explained in the subsections of this section.
In this table, the C, U, and N columns indicate the properties Critical, UnSafe, and NoCacheKey, respectively.
Since NoCacheKey only has a meaning for options that are Safe-to-Forward (not marked Unsafe), the column is filled with a dash for UnSafe options.
Uri-Host, Uri-Port, Uri-Path, and Uri-Query The Uri-Host, Uri-Port, Uri-Path, and Uri-Query Options are used to specify the target resource of a request to a CoAP origin server.
The options encode the different components of the request URI in a way that no percent-encoding is visible in the option values and that the full URI can be reconstructed at any involved endpoint.
The syntax of CoAP URIs is defined in Section 6.
The steps for parsing URIs into options is defined in Section 6.4.
These steps result in zero or more Uri-Host, Uri-Port, Uri-Path, and Uri-Query Options being included in a request, where each option holds the following values: o the Uri-Host Option specifies the Internet host of the resource being requested, o the Uri-Port Option specifies the transport-layer port number of the resource, o each Uri-Path Option specifies one segment of the absolute path to the resource, and o each Uri-Query Option specifies one argument parameterizing the resource.
Note: Fragments ([RFC3986], SectionÂ 3.5) are not part of the request URI and thus will not be transmitted in a CoAP request.
The default value of the Uri-Host Option is the IP literal representing the destination IP address of the request message.
Likewise, the default value of the Uri-Port Option is the destination UDP port.
The default values for the Uri-Host and Uri-Port Options are sufficient for requests to most servers.
Explicit Uri-Host and Uri-Port Options are typically used when an endpoint hosts multiple virtual servers.
The Uri-Path and Uri-Query Option can contain any character sequence.
No percent-encoding is performed.
The value of a Uri-Path Option MUST NOT be "."
or ".." (as the request URI must be resolved before parsing it into options).
The steps for constructing the request URI from the options are defined in Section 6.5.
Note that an implementation does not necessarily have to construct the URI; it can simply look up the target resource by examining the individual options.
Examples can be found in Appendix B.
Proxy-Uri and Proxy-Scheme The Proxy-Uri Option is used to make a request to a forward-proxy (see Section 5.7).
The forward-proxy is requested to forward the request or service it from a valid cache and return the response.
The option value is an absolute-URI ([RFC3986], SectionÂ 4.3).
Note that the forward-proxy MAY forward the request on to another proxy or directly to the server specified by the absolute-URI.
In order to avoid request loops, a proxy MUST be able to recognize all of its server names, including any aliases, local variations, and the numeric IP addresses.
An endpoint receiving a request with a Proxy-Uri Option that is unable or unwilling to act as a forward-proxy for the request MUST cause the return of a 5.05 (Proxying Not Supported) response.
The Proxy-Uri Option MUST take precedence over any of the Uri-Host, Uri-Port, Uri-Path or Uri-Query options (each of which MUST NOT be included in a request containing the Proxy-Uri Option).
As a special case to simplify many proxy clients, the absolute-URI can be constructed from the Uri-* options.
When a Proxy-Scheme Option is present, the absolute-URI is constructed as follows: a CoAP URI is constructed from the Uri-* options as defined in Section 6.5.
In the resulting URI, the initial scheme up to, but not including, the following colon is then replaced by the content of the Proxy-Scheme Option.
Note that this case is only applicable if the components of the desired URI other than the scheme component actually can be expressed using Uri-* options; for example, to represent a URI with a userinfo component in the authority, only Proxy-Uri can be used.
Content-Format The Content-Format Option indicates the representation format of the message payload.
The representation format is given as a numeric Content-Format identifier that is defined in the "CoAP Content-Formats" registry (Section 12.3).
In the absence of the option, no default value is assumed, i.e., the representation format of any representation message payload is indeterminate (Section 5.5).
Accept The CoAP Accept option can be used to indicate which Content-Format is acceptable to the client.
The representation format is given as a numeric Content-Format identifier that is defined in the "CoAP Content-Formats" registry (Section 12.3).
If no Accept option is given, the client does not express a preference (thus no default value is assumed).
The client prefers the representation returned by the server to be in the Content-Format indicated.
The server returns the preferred Content-Format if available.
If the preferred Content-Format cannot be returned, then a 4.06 "Not Acceptable" MUST be sent as a response, unless another error code takes precedence for this response.
Max-Age The Max-Age Option indicates the maximum time a response may be cached before it is considered not fresh (see Section 5.6.1).
The option value is an integer number of seconds between 0 and 2**32-1 inclusive (about 136.1 years).
A default value of 60 seconds is assumed in the absence of the option in a response.
The value is intended to be current at the time of transmission.
Servers that provide resources with strict tolerances on the value of Max-Age SHOULD update the value before each retransmission.
(See also Section 5.7.1.)
ETag An entity-tag is intended for use as a resource-local identifier for differentiating between representations of the same resource that vary over time.
It is generated by the server providing the resource, which may generate it in any number of ways including a version, checksum, hash, or time.
An endpoint receiving an entity-tag MUST treat it as opaque and make no assumptions about its content or structure.
(Endpoints that generate an entity-tag are encouraged to use the most compact representation possible, in particular in regards to clients and intermediaries that may want to store multiple ETag values.)
ETag as a Response Option The ETag Option in a response provides the current value (i.e., after the request was processed) of the entity-tag for the "tagged representation".
If no Location-* options are present, the tagged representation is the selected representation (Section 5.5.3) of the target resource.
If one or more Location-* options are present and thus a location URI is indicated (Section 5.10.7), the tagged representation is the representation that would be retrieved by a GET request to the location URI.
An ETag response option can be included with any response for which there is a tagged representation (e.g., it would not be meaningful in a 4.04 or 4.00 response).
The ETag Option MUST NOT occur more than once in a response.
There is no default value for the ETag Option; if it is not present in a response, the server makes no statement about the entity-tag for the tagged representation.
ETag as a Request Option In a GET request, an endpoint that has one or more representations previously obtained from the resource, and has obtained ETag response options with these, can specify an instance of the ETag Option for one or more of these stored responses.
A server can issue a 2.03 Valid response (Section 5.9.1.3) in place of a 2.05 Content response if one of the ETags given is the entity-tag for the current representation, i.e., is valid; the 2.03 Valid response then echoes this specific ETag in a response option.
In effect, a client can determine if any of the stored representations is current (see Section 5.6.2) without needing to transfer them again.
The ETag Option MAY occur zero, one, or multiple times in a request.
Location-Path and Location-Query The Location-Path and Location-Query Options together indicate a relative URI that consists either of an absolute path, a query string, or both.
A combination of these options is included in a 2.01 (Created) response to indicate the location of the resource created as the result of a POST request (see Section 5.8.2).
The location is resolved relative to the request URI.
If a response with one or more Location-Path and/or Location-Query Options passes through a cache that interprets these options and the implied URI identifies one or more currently stored responses, those entries MUST be marked as not fresh.
Each Location-Path Option specifies one segment of the absolute path to the resource, and each Location-Query Option specifies one argument parameterizing the resource.
The Location-Path and Location-Query Option can contain any character sequence.
No percent-encoding is performed.
The value of a Location-Path Option MUST NOT be "."
or "..".
The steps for constructing the location URI from the options are analogous to Section 6.5, except that the first five steps are skipped and the result is a relative URI-reference, which is then interpreted relative to the request URI.
Note that the relative URI-reference constructed this way always includes an absolute path (e.g., leaving out Location-Path but supplying Location-Query means the path component in the URI is "/").
The options that are used to compute the relative URI-reference are collectively called Location-* options.
Beyond Location-Path and Location-Query, more Location-* options may be defined in the future and have been reserved option numbers 128, 132, 136, and 140.
If any of these reserved option numbers occurs in addition to Location-Path and/or Location-Query and are not supported, then a 4.02 (Bad Option) error MUST be returned.
Conditional Request Options Conditional request options enable a client to ask the server to perform the request only if certain conditions specified by the option are fulfilled.
For each of these options, if the condition given is not fulfilled, then the server MUST NOT perform the requested method.
Instead, the server MUST respond with the 4.12 (Precondition Failed) Response Code.
If the condition is fulfilled, the server performs the request method as if the conditional request options were not present.
If the request would, without the conditional request options, result in anything other than a 2.xx or 4.12 Response Code, then any conditional request options MAY be ignored.
If-Match The If-Match Option MAY be used to make a request conditional on the current existence or value of an ETag for one or more representations of the target resource.
If-Match is generally useful for resource update requests, such as PUT requests, as a means for protecting against accidental overwrites when multiple clients are acting in parallel on the same resource (i.e., the "lost update" problem).
The value of an If-Match option is either an ETag or the empty string.
An If-Match option with an ETag matches a representation with that exact ETag.
An If-Match option with an empty value matches any existing representation (i.e., it places the precondition on the existence of any current representation for the target resource).
The If-Match Option can occur multiple times.
If any of the options match, then the condition is fulfilled.
If there is one or more If-Match Options, but none of the options match, then the condition is not fulfilled.
If-None-Match The If-None-Match Option MAY be used to make a request conditional on the nonexistence of the target resource.
If-None-Match is useful for resource creation requests, such as PUT requests, as a means for protecting against accidental overwrites when multiple clients are acting in parallel on the same resource.
The If-None-Match Option carries no value.
If the target resource does exist, then the condition is not fulfilled.
(It is not very useful to combine If-Match and If-None-Match options in one request, because the condition will then never be fulfilled.)
Size1 Option The Size1 option provides size information about the resource representation in a request.
The option value is an integer number of bytes.
Its main use is with block-wise transfers [BLOCK].
In the present specification, it is used in 4.13 responses (Section 5.9.2.9) to indicate the maximum size of request entity that the server is able and willing to handle.
CoAP URIs CoAP uses the "coap" and "coaps" URI schemes for identifying CoAP resources and providing a means of locating the resource.
Resources are organized hierarchically and governed by a potential CoAP origin server listening for CoAP requests ("coap") or DTLS-secured CoAP requests ("coaps") on a given UDP port.
The CoAP server is identified via the generic syntax's authority component, which includes a host component and optional UDP port number.
The remainder of the URI is considered to be identifying a resource that can be operated on by the methods defined by the CoAP protocol.
The "coap" and "coaps" URI schemes can thus be compared to the "http" and "https" URI schemes, respectively.
The syntax of the "coap" and "coaps" URI schemes is specified in this section in Augmented Backus-Naur Form (ABNF) [RFC5234].
The definitions of "host", "port", "path-abempty", "query", "segment", "IP-literal", "IPv4address", and "reg-name" are adopted from [RFC3986].
Implementation Note: Unfortunately, over time, the URI format has acquired significant complexity.
Implementers are encouraged to examine [RFC3986] closely.
For example, the ABNF for IPv6 addresses is more complicated than maybe expected.
Also, implementers should take care to perform the processing of percent-decoding or percent-encoding exactly once on the way from a URI to its decoded components or back.
Percent-encoding is crucial for data transparency but may lead to unusual results such as a slash character in a path component.
6.1. coap URI Scheme coap-URI = "coap:" "//" host [ ":" port ] path-abempty [ "?"
query ] If the host component is provided as an IP-literal or IPv4address, then the CoAP server can be reached at that IP address.
If host is a registered name, then that name is considered an indirect identifier and the endpoint might use a name resolution service, such as DNS, to find the address of that host.
The host MUST NOT be empty; if a URI is received with a missing authority or an empty host, then it MUST be considered invalid.
The port subcomponent indicates the UDP port at which the CoAP server is located.
If it is empty or not given, then the default port 5683 is assumed.
The path identifies a resource within the scope of the host and port.
It consists of a sequence of path segments separated by a slash character (U+002F SOLIDUS "/").
The query serves to further parameterize the resource.
It consists of a sequence of arguments separated by an ampersand character (U+0026 AMPERSAND "&").
An argument is often in the form of a "key=value" pair.
The "coap" URI scheme supports the path prefix "/.well-known/" defined by [RFC5785] for "well-known locations" in the namespace of a host.
This enables discovery of policy or other information about a host ("site-wide metadata"), such as hosted resources (see Section 7).
Application designers are encouraged to make use of short but descriptive URIs.
As the environments that CoAP is used in are usually constrained for bandwidth and energy, the trade-off between these two qualities should lean towards the shortness, without ignoring descriptiveness.
6.2. coaps URI Scheme coaps-URI = "coaps:" "//" host [ ":" port ] path-abempty [ "?"
query ] All of the requirements listed above for the "coap" scheme are also requirements for the "coaps" scheme, except that a default UDP port of 5684 is assumed if the port subcomponent is empty or not given, and the UDP datagrams MUST be secured through the use of DTLS as described in Section 9.1.
Considerations for caching of responses to "coaps" identified requests are discussed in Section 11.2.
Resources made available via the "coaps" scheme have no shared identity with the "coap" scheme even if their resource identifiers indicate the same authority (the same host listening to the same UDP port).
They are distinct namespaces and are considered to be distinct origin servers.
Normalization and Comparison Rules Since the "coap" and "coaps" schemes conform to the URI generic syntax, such URIs are normalized and compared according to the algorithm defined in [RFC3986], SectionÂ 6, using the defaults described above for each scheme.
If the port is equal to the default port for a scheme, the normal form is to elide the port subcomponent.
Likewise, an empty path component is equivalent to an absolute path of "/", so the normal form is to provide a path of "/" instead.
The scheme and host are case insensitive and normally provided in lowercase; IP-literals are in recommended form [RFC5952]; all other components are compared in a case-sensitive manner.
Characters other than those in the "reserved" set are equivalent to their percent-encoded bytes (see [RFC3986], SectionÂ 2.1): the normal form is to not encode them.
For example, the following three URIs are equivalent and cause the same options and option values to appear in the CoAP messages: coap://example.com:5683/~sensors/temp.xml coap://EXAMPLE.com/%7Esensors/temp.xml coap://EXAMPLE.com:/%7esensors/temp.xml6.4.
Decomposing URIs into Options The steps to parse a request's options from a string |url| are as follows.
These steps either result in zero or more of the Uri-Host, Uri-Port, Uri-Path, and Uri-Query Options being included in the request or they fail.
If the |url| string is not an absolute URI ([RFC3986]), then fail this algorithm.
Resolve the |url| string using the process of reference resolution defined by [RFC3986].
At this stage, the URL is in ASCII encoding [RFC0020], even though the decoded components will be interpreted in UTF-8 [RFC3629] after steps 5, 8, and 9.
NOTE: It doesn't matter what it is resolved relative to, since we already know it is an absolute URL at this point.
If |url| does not have a <scheme> component whose value, when converted to ASCII lowercase, is "coap" or "coaps", then fail this algorithm.
If |url| has a <fragment> component, then fail this algorithm.
If the <host> component of |url| does not represent the request's destination IP address as an IP-literal or IPv4address, include a Uri-Host Option and let that option's value be the value of the <host> component of |url|, converted to ASCII lowercase, and then convert all percent-encodings ("%" followed by two hexadecimal digits) to the corresponding characters.
NOTE: In the usual case where the request's destination IP address is derived from the host part, this ensures that a Uri-Host Option is only used for a <host> component of the form reg-name.
If |url| has a <port> component, then let |port| be that component's value interpreted as a decimal integer; otherwise, let |port| be the default port for the scheme.
If |port| does not equal the request's destination UDP port, include a Uri-Port Option and let that option's value be |port|.
If the value of the <path> component of |url| is empty or consists of a single slash character (U+002F SOLIDUS "/"), then move to the next step.
Otherwise, for each segment in the <path> component, include a Uri-Path Option and let that option's value be the segment (not including the delimiting slash characters) after converting each percent-encoding ("%" followed by two hexadecimal digits) to the corresponding byte.
If |url| has a <query> component, then, for each argument in the <query> component, include a Uri-Query Option and let that option's value be the argument (not including the question mark and the delimiting ampersand characters) after converting each percent-encoding to the corresponding byte.
Note that these rules completely resolve any percent-encoding.
Composing URIs from Options The steps to construct a URI from a request's options are as follows.
These steps either result in a URI or they fail.
In these steps, percent-encoding a character means replacing each of its (UTF-8-encoded) bytes by a "%" character followed by two hexadecimal digits representing the byte, where the digits A-F are in uppercase (as defined in SectionÂ 2.1 of [RFC3986]; to reduce variability, the hexadecimal notation for percent-encoding in CoAP URIs MUST use uppercase letters).
The definitions of "unreserved" and "sub-delims" are adopted from [RFC3986].
If the request is secured using DTLS, let |url| be the string "coaps://".
Otherwise, let |url| be the string "coap://".
If the request includes a Uri-Host Option, let |host| be that option's value, where any non-ASCII characters are replaced by their corresponding percent-encoding.
If |host| is not a valid reg-name or IP-literal or IPv4address, fail the algorithm.
If the request does not include a Uri-Host Option, let |host| be the IP-literal (making use of the conventions of [RFC5952]) or IPv4address representing the request's destination IP address.
Append |host| to |url|.
If the request includes a Uri-Port Option, let |port| be that option's value.
Otherwise, let |port| be the request's destination UDP port.
If |port| is not the default port for the scheme, then append a single U+003A COLON character (:) followed by the decimal representation of |port| to |url|.
Let |resource name| be the empty string.
For each Uri-Path Option in the request, append a single character U+002F SOLIDUS (/) followed by the option's value to |resource name|, after converting any character that is not either in the "unreserved" set, in the "sub-delims" set, a U+003A COLON (:) character, or a U+0040 COMMERCIAL AT (@) character to its percent-encoded form.
If |resource name| is the empty string, set it to a single character U+002F SOLIDUS (/).
For each Uri-Query Option in the request, append a single character U+003F QUESTION MARK (?)
(first option) or U+0026 AMPERSAND (&) (subsequent options) followed by the option's value to |resource name|, after converting any character that is not either in the "unreserved" set, in the "sub-delims" set (except U+0026 AMPERSAND (&)), a U+003A COLON (:), a U+0040 COMMERCIAL AT (@), a U+002F SOLIDUS (/), or a U+003F QUESTION MARK (?)
character to its percent-encoded form.
Append |resource name| to |url|.
Return |url|.
Note that these steps have been designed to lead to a URI in normal form (see Section 6.3).
Discovery7.1.
Service Discovery As a part of discovering the services offered by a CoAP server, a client has to learn about the endpoint used by a server.
A server is discovered by a client (knowing or) learning a URI that references a resource in the namespace of the server.
Alternatively, clients can use multicast CoAP (see Section 8) and the "All CoAP Nodes" multicast address to find CoAP servers.
Unless the port subcomponent in a "coap" or "coaps" URI indicates the UDP port at which the CoAP server is located, the server is assumed to be reachable at the default port.
The CoAP default port number 5683 MUST be supported by a server that offers resources for resource discovery (see Section 7.2 below) and SHOULD be supported for providing access to other resources.
The default port number 5684 for DTLS-secured CoAP MAY be supported by a server for resource discovery and for providing access to other resources.
In addition, other endpoints may be hosted at other ports, e.g., in the dynamic port space.
Implementation Note: When a CoAP server is hosted by a 6LoWPAN node, header compression efficiency is improved when it also supports a port number in the 61616-61631 compressed UDP port space defined in [RFC4944] and [RFC6282].
(Note that, as its UDP port differs from the default port, it is a different endpoint from the server at the default port.)
Resource Discovery The discovery of resources offered by a CoAP endpoint is extremely important in machine-to-machine applications where there are no humans in the loop and static interfaces result in fragility.
To maximize interoperability in a CoRE environment, a CoAP endpoint SHOULD support the CoRE Link Format of discoverable resources as described in [RFC6690], except where fully manual configuration is desired.
It is up to the server which resources are made discoverable (if any).
'ct' Attribute This section defines a new Web Linking [RFC5988] attribute for use with [RFC6690].
The Content-Format code "ct" attribute provides a hint about the Content-Formats this resource returns.
Note that this is only a hint, and it does not override the Content-Format Option of a CoAP response obtained by actually requesting the representation of the resource.
The value is in the CoAP identifier code format as a decimal ASCII integer and MUST be in the range of 0-65535 (16-bit unsigned integer).
For example, "application/xml" would be indicated as "ct=41".
If no Content-Format code attribute is present, then nothing about the type can be assumed.
The Content-Format code attribute MAY include a space-separated sequence of Content-Format codes, indicating that multiple content-formats are available.
The syntax of the attribute value is summarized in the production "ct-value" in Figure 12, where "cardinal", "SP", and "DQUOTE" are defined as in [RFC6690].
ct-value = cardinal / DQUOTE cardinal *( 1*SP cardinal ) DQUOTE Figure 12.
Multicast CoAP CoAP supports making requests to an IP multicast group.
This is defined by a series of deltas to unicast CoAP.
A more general discussion of group communication with CoAP is in [GROUPCOMM].
CoAP endpoints that offer services that they want other endpoints to be able to find using multicast service discovery join one or more of the appropriate all-CoAP-node multicast addresses (Section 12.8) and listen on the default CoAP port.
Note that an endpoint might receive multicast requests on other multicast addresses, including the all-nodes IPv6 address (or via broadcast on IPv4); an endpoint MUST therefore be prepared to receive such messages but MAY ignore them if multicast service discovery is not desired.
Messaging Layer A multicast request is characterized by being transported in a CoAP message that is addressed to an IP multicast address instead of a CoAP endpoint.
Such multicast requests MUST be Non-confirmable.
A server SHOULD be aware that a request arrived via multicast, e.g., by making use of modern APIs such as IPV6_RECVPKTINFO [RFC3542], if available.
To avoid an implosion of error responses, when a server is aware that a request arrived via multicast, it MUST NOT return a Reset message in reply to a Non-confirmable message.
If it is not aware, it MAY return a Reset message in reply to a Non-confirmable message as usual.
Because such a Reset message will look identical to one for a unicast message from the sender, the sender MUST avoid using a Message ID that is also still active from this endpoint with any unicast endpoint that might receive the multicast message.
At the time of writing, multicast messages can only be carried in UDP not in DTLS.
This means that the security modes defined for CoAP in this document are not applicable to multicast.
Request/Response Layer When a server is aware that a request arrived via multicast, the server MAY always ignore the request, in particular if it doesn't have anything useful to respond (e.g., if it only has an empty payload or an error response).
The decision for this may depend on the application.
(For example, in query filtering as described in [RFC6690], a server should not respond to a multicast request if the filter does not match.
More examples are in [GROUPCOMM].)
If a server does decide to respond to a multicast request, it should not respond immediately.
Instead, it should pick a duration for the period of time during which it intends to respond.
For the purposes of this exposition, we call the length of this period the Leisure.
The specific value of this Leisure may depend on the application or MAY be derived as described below.
The server SHOULD then pick a random point of time within the chosen leisure period to send back the unicast response to the multicast request.
If further responses need to be sent based on the same multicast address membership, a new leisure period starts at the earliest after the previous one finishes.
To compute a value for Leisure, the server should have a group size estimate G, a target data transfer rate R (which both should be chosen conservatively), and an estimated response size S; a rough lower bound for Leisure can then be computed as lb_Leisure = S * G / R For example, for a multicast request with link-local scope on a 2.4 GHz IEEE 802.15.4 (6LoWPAN) network, G could be (relatively conservatively) set to 100, S to 100 bytes, and the target rate to 8 kbit/s = 1 kB/s.
The resulting lower bound for the Leisure is 10 seconds.
If a CoAP endpoint does not have suitable data to compute a value for Leisure, it MAY resort to DEFAULT_LEISURE.
When matching a response to a multicast request, only the token MUST match; the source endpoint of the response does not need to (and will not) be the same as the destination endpoint of the original request.
For the purposes of interpreting the Location-* options and any links embedded in the representation, the request URI (i.e., the base URI relative to which the response is interpreted) is formed by replacing the multicast address in the Host component of the original request URI by the literal IP address of the endpoint actually responding.
Caching When a client makes a multicast request, it always makes a new request to the multicast group (since there may be new group members that joined meanwhile or ones that did not get the previous request).
It MAY update a cache with the received responses.
Then, it uses both cached-still-fresh and new responses as the result of the request.
A response received in reply to a GET request to a multicast group MAY be used to satisfy a subsequent request on the related unicast request URI.
The unicast request URI is obtained by replacing the authority part of the request URI with the transport-layer source address of the response message.
A cache MAY revalidate a response by making a GET request on the related unicast request URI.
A GET request to a multicast group MUST NOT contain an ETag option.
A mechanism to suppress responses the client already has is left for further study.
Proxying When a forward-proxy receives a request with a Proxy-Uri or URI constructed from Proxy-Scheme that indicates a multicast address, the proxy obtains a set of responses as described above and sends all responses (both cached-still-fresh and new) back to the original client.
This specification does not provide a way to indicate the unicast-modified request URI (base URI) in responses thus forwarded.
Proxying multicast requests is discussed in more detail in [GROUPCOMM]; one proposal to address the base URI issue can be found in Section 3 of [CoAP-MISC].
Securing CoAP This section defines the DTLS binding for CoAP.
During the provisioning phase, a CoAP device is provided with the security information that it needs, including keying materials and access control lists.
This specification defines provisioning for the RawPublicKey mode in Section 9.1.3.2.1.
At the end of the provisioning phase, the device will be in one of four security modes with the following information for the given mode.
The NoSec and RawPublicKey modes are mandatory to implement for this specification.
NoSec: There is no protocol-level security (DTLS is disabled).
Alternative techniques to provide lower-layer security SHOULD be used when appropriate.
The use of IPsec is discussed in [IPsec-CoAP].
Certain link layers in use with constrained nodes also provide link-layer security, which may be appropriate with proper key management.
PreSharedKey: DTLS is enabled, there is a list of pre-shared keys [RFC4279], and each key includes a list of which nodes it can be used to communicate with as described in Section 9.1.3.1.
At the extreme, there may be one key for each node this CoAP node needs to communicate with (1:1 node/key ratio).
Conversely, if more than two entities share a specific pre-shared key, this key only enables the entities to authenticate as a member of that group and not as a specific peer.
RawPublicKey: DTLS is enabled and the device has an asymmetric key pair without a certificate (a raw public key) that is validated using an out-of-band mechanism [RFC7250] as described in Section 9.1.3.2.
The device also has an identity calculated from the public key and a list of identities of the nodes it can communicate with.
Certificate: DTLS is enabled and the device has an asymmetric key pair with an X.509 certificate [RFC5280] that binds it to its subject and is signed by some common trust root as described in Section 9.1.3.3.
The device also has a list of root trust anchors that can be used for validating a certificate.
In the "NoSec" mode, the system simply sends the packets over normal UDP over IP and is indicated by the "coap" scheme and the CoAP default port.
The system is secured only by keeping attackers from being able to send or receive packets from the network with the CoAP nodes; see Section 11.5 for an additional complication with this approach.
The other three security modes are achieved using DTLS and are indicated by the "coaps" scheme and DTLS-secured CoAP default port.
The result is a security association that can be used to authenticate (within the limits of the security model) and, based on this authentication, authorize the communication partner.
CoAP itself does not provide protocol primitives for authentication or authorization; where this is required, it can either be provided by communication security (i.e., IPsec or DTLS) or by object security (within the payload).
Devices that require authorization for certain operations are expected to require one of these two forms of security.
Necessarily, where an intermediary is involved, communication security only works when that intermediary is part of the trust relationships.
CoAP does not provide a way to forward different levels of authorization that clients may have with an intermediary to further intermediaries or origin servers --it therefore may be required to perform all authorization at the first intermediary.
DTLS-Secured CoAP Just as HTTP is secured using Transport Layer Security (TLS) over TCP, CoAP is secured using Datagram TLS (DTLS) [RFC6347] over UDP (see Figure 13).
This section defines the CoAP binding to DTLS, along with the minimal mandatory-to-implement configurations appropriate for constrained environments.
The binding is defined by a series of deltas to unicast CoAP.
In practice, DTLS is TLS with added features to deal with the unreliable nature of the UDP transport.
In some constrained nodes (limited flash and/or RAM) and networks (limited bandwidth or high scalability requirements), and depending on the specific cipher suites in use, all modes of DTLS may not be applicable.
Some DTLS cipher suites can add significant implementation complexity as well as some initial handshake overhead needed when setting up the security association.
Once the initial handshake is completed, DTLS adds a limited per-datagram overhead of approximately 13 bytes, not including any initialization vectors/ nonces (e.g., 8 bytes with TLS_PSK_WITH_AES_128_CCM_8 [RFC6655]), integrity check values (e.g., 8 bytes with TLS_PSK_WITH_AES_128_CCM_8 [RFC6655]), and padding required by the cipher suite.
Whether the use of a given mode of DTLS is applicable for a CoAP-based application should be carefully weighed considering the specific cipher suites that may be applicable, whether the session maintenance makes it compatible with application flows, and whether sufficient resources are available on the constrained nodes and for the added network overhead.
(For some modes of using DTLS, this specification identifies a mandatory-to-implement cipher suite.
This is an implementation requirement to maximize interoperability in those cases where these cipher suites are indeed appropriate.
The specific security policies of an application may determine the actual set of cipher suites that can be used.)
DTLS is not applicable to group keying (multicast communication); however, it may be a component in a future group key management protocol.
Messaging Layer The endpoint acting as the CoAP client should also act as the DTLS client.
It should initiate a session to the server on the appropriate port.
When the DTLS handshake has finished, the client may initiate the first CoAP request.
All CoAP messages MUST be sent as DTLS "application data".
The following rules are added for matching an Acknowledgement message or Reset message to a Confirmable message, or a Reset message to a Non-confirmable message: The DTLS session MUST be the same, and the epoch MUST be the same.
A message is the same when it is sent within the same DTLS session and same epoch and has the same Message ID.
Note: When a Confirmable message is retransmitted, a new DTLS sequence_number is used for each attempt, even though the CoAP Message ID stays the same.
So a recipient still has to perform deduplication as described in Section 4.5.
Retransmissions MUST NOT be performed across epochs.
DTLS connections in RawPublicKey and Certificate mode are set up using mutual authentication so they can remain up and be reused for future message exchanges in either direction.
Devices can close a DTLS connection when they need to recover resources, but in general they should keep the connection up for as long as possible.
Closing the DTLS connection after every CoAP message exchange is very inefficient.
Request/Response Layer The following rules are added for matching a response to a request: The DTLS session MUST be the same, and the epoch MUST be the same.
This means the response to a DTLS secured request MUST always be DTLS secured using the same security session and epoch.
Any attempt to supply a NoSec response to a DTLS request simply does not match the request and therefore MUST be rejected (unless it does match an unrelated NoSec request).
Endpoint Identity Devices SHOULD support the Server Name Indication (SNI) to indicate their authority in the SNI HostName field as defined in SectionÂ 3 of [RFC6066].
This is needed so that when a host that acts as a virtual server for multiple Authorities receives a new DTLS connection, it knows which keys to use for the DTLS session.
Pre-Shared Keys When forming a connection to a new node, the system selects an appropriate key based on which nodes it is trying to reach and then forms a DTLS session using a PSK (Pre-Shared Key) mode of DTLS.
Implementations in these modes MUST support the mandatory-to-implement cipher suite TLS_PSK_WITH_AES_128_CCM_8 as specified in [RFC6655].
Depending on the commissioning model, applications may need to define an application profile for identity hints (as required and detailed in SectionÂ 5.2 of [RFC4279]) to enable the use of PSK identity hints.
The security considerations of SectionÂ 7 of [RFC4279] apply.
In particular, applications should carefully weigh whether or not they need Perfect Forward Secrecy (PFS) and select an appropriate cipher suite (SectionÂ 7.1 of [RFC4279]).
The entropy of the PSK must be sufficient to mitigate against brute-force and (where the PSK is not chosen randomly but by a human) dictionary attacks (SectionÂ 7.2 of [RFC4279]).
The cleartext communication of client identities may leak data or compromise privacy (SectionÂ 7.3 of [RFC4279]).
Raw Public Key Certificates In this mode, the device has an asymmetric key pair but without an X.509 certificate (called a raw public key); for example, the asymmetric key pair is generated by the manufacturer and installed on the device (see also Section 11.6).
A device MAY be configured with multiple raw public keys.
The type and length of the raw public key depends on the cipher suite used.
Implementations in RawPublicKey mode MUST support the mandatory-to-implement cipher suite TLS_ECDHE_ECDSA_WITH_AES_128_CCM_8 as specified in [RFC7251], [RFC5246], and [RFC4492].
The key used MUST be ECDSA capable.
The curve secp256r1 MUST be supported [RFC4492]; this curve is equivalent to the NIST P-256 curve.
The hash algorithm is SHA-256.
Implementations MUST use the Supported Elliptic Curves and Supported Point Formats Extensions [RFC4492]; the uncompressed point format MUST be supported; [RFC6090] can be used as an implementation method.
Some guidance relevant to the implementation of this cipher suite can be found in [W3CXMLSEC].
The mechanism for using raw public keys with TLS is specified in [RFC7250].
TLS_ECDHE_ECDSA_WITH_AES_128_CCM_89.1.3.2.1.
Provisioning The RawPublicKey mode was designed to be easily provisioned in M2M deployments.
It is assumed that each device has an appropriate asymmetric public key pair installed.
An identifier is calculated by the endpoint from the public key as described in SectionÂ 2 of [RFC6920].
All implementations that support checking RawPublicKey identities MUST support at least the sha-256-120 mode (SHA-256 truncated to 120 bits).
Implementations SHOULD also support longer length identifiers and MAY support shorter lengths.
Note that the shorter lengths provide less security against attacks, and their use is NOT RECOMMENDED.
Depending on how identifiers are given to the system that verifies them, support for URI, binary, and/or human-speakable format [RFC6920] needs to be implemented.
All implementations SHOULD support the binary mode, and implementations that have a user interface SHOULD also support the human-speakable format.
During provisioning, the identifier of each node is collected, for example, by reading a barcode on the outside of the device or by obtaining a pre-compiled list of the identifiers.
These identifiers are then installed in the corresponding endpoint, for example, an M2M data collection server.
The identifier is used for two purposes, to associate the endpoint with further device information and to perform access control.
During (initial and ongoing) provisioning, an access control list of identifiers with which the device may start DTLS sessions SHOULD also be installed and maintained.
X.509 Certificates Implementations in Certificate Mode MUST support the mandatory-to-implement cipher suite TLS_ECDHE_ECDSA_WITH_AES_128_CCM_8 as specified in [RFC7251], [RFC5246], and [RFC4492].
Namely, the certificate includes a SubjectPublicKeyInfo that indicates an algorithm of id-ecPublicKey with namedCurves secp256r1 [RFC5480]; the public key format is uncompressed [RFC5480]; the hash algorithm is SHA-256; if included, the key usage extension indicates digitalSignature.
Certificates MUST be signed with ECDSA using secp256r1, and the signature MUST use SHA-256.
The key used MUST be ECDSA capable.
The curve secp256r1 MUST be supported [RFC4492]; this curve is equivalent to the NIST P-256 curve.
The hash algorithm is SHA-256.
Implementations MUST use the Supported Elliptic Curves and Supported Point Formats Extensions [RFC4492]; the uncompressed point format MUST be supported; [RFC6090] can be used as an implementation method.
The subject in the certificate would be built out of a long-term unique identifier for the device such as the EUI-64 [EUI64].
The subject could also be based on the Fully Qualified Domain Name (FQDN) that was used as the Host part of the CoAP URI.
However, the device's IP address should not typically be used as the subject, as it would change over time.
The discovery process used in the system would build up the mapping between IP addresses of the given devices and the subject for each device.
Some devices could have more than one subject and would need more than a single certificate.
When a new connection is formed, the certificate from the remote device needs to be verified.
If the CoAP node has a source of absolute time, then the node SHOULD check that the validity dates of the certificate are within range.
The certificate MUST be validated as appropriate for the security requirements, using functionality equivalent to the algorithm specified in SectionÂ 6 of [RFC5280].
If the certificate contains a SubjectAltName, then the authority of the request URI MUST match at least one of the authorities of any CoAP URI found in a field of URI type in the SubjectAltName set.
If there is no SubjectAltName in the certificate, then the authority of the request URI MUST match the Common Name (CN) found in the certificate using the matching rules defined in [RFC3280] with the exception that certificates with wildcards are not allowed.
CoRE support for certificate status checking requires further study.
As a mapping of the Online Certificate Status Protocol (OCSP) [RFC6960] onto CoAP is not currently defined and OCSP may also not be easily applicable in all environments, an alternative approach may be using the TLS Certificate Status Request extension (SectionÂ 8 of [RFC6066]; also known as "OCSP stapling") or preferably the Multiple Certificate Status Extension ([RFC6961]), if available.
If the system has a shared key in addition to the certificate, then a cipher suite that includes the shared key such as TLS_ECDHE_PSK_WITH_AES_128_CBC_SHA [RFC5489] SHOULD be used.
Cross-Protocol Proxying between CoAP and HTTP CoAP supports a limited subset of HTTP functionality, and thus cross-protocol proxying to HTTP is straightforward.
There might be several reasons for proxying between CoAP and HTTP, for example, when designing a web interface for use over either protocol or when realizing a CoAP-HTTP proxy.
Likewise, CoAP could equally be proxied to other protocols such as XMPP [RFC6120] or SIP [RFC3264]; the definition of these mechanisms is out of scope for this specification.
There are two possible directions to access a resource via a forward-proxy: CoAP-HTTP Proxying: Enables CoAP clients to access resources on HTTP servers through an intermediary.
This is initiated by including the Proxy-Uri or Proxy-Scheme Option with an "http" or "https" URI in a CoAP request to a CoAP-HTTP proxy.
HTTP-CoAP Proxying: Enables HTTP clients to access resources on CoAP servers through an intermediary.
This is initiated by specifying a "coap" or "coaps" URI in the Request-Line of an HTTP request to an HTTP-CoAP proxy.
Either way, only the request/response model of CoAP is mapped to HTTP.
The underlying model of Confirmable or Non-confirmable messages, etc., is invisible and MUST have no effect on a proxy function.
The following sections describe the handling of requests to a forward-proxy.
Reverse-proxies are not specified, as the proxy function is transparent to the client with the proxy acting as if it were the origin server.
However, similar considerations apply to reverse-proxies as to forward-proxies, and there generally will be an expectation that reverse-proxies operate in a similar way forward-proxies would.
As an implementation note, HTTP client libraries may make it hard to operate an HTTP-CoAP forward-proxy by not providing a way to put a CoAP URI on the HTTP Request-Line; reverse-proxying may therefore lead to wider applicability of a proxy.
A separate specification may define a convention for URIs operating such an HTTP-CoAP reverse-proxy [MAPPING].
CoAP-HTTP Proxying If a request contains a Proxy-Uri or Proxy-Scheme Option with an 'http' or 'https' URI [RFC2616], then the receiving CoAP endpoint (called "the proxy" henceforth) is requested to perform the operation specified by the request method on the indicated HTTP resource and return the result to the client.
(See also Section 5.7 for how the request to the proxy is formulated, including security requirements.)
This section specifies for any CoAP request the CoAP response that the proxy should return to the client.
How the proxy actually satisfies the request is an implementation detail, although the typical case is expected to be that the proxy translates and forwards the request to an HTTP origin server.
Since HTTP and CoAP share the basic set of request methods, performing a CoAP request on an HTTP resource is not so different from performing it on a CoAP resource.
The meanings of the individual CoAP methods when performed on HTTP resources are explained in the subsections of this section.
If the proxy is unable or unwilling to service a request with an HTTP URI, a 5.05 (Proxying Not Supported) response is returned to the client.
If the proxy services the request by interacting with a third party (such as the HTTP origin server) and is unable to obtain a result within a reasonable time frame, a 5.04 (Gateway Timeout) response is returned; if a result can be obtained but is not understood, a 5.02 (Bad Gateway) response is returned.
GET The GET method requests the proxy to return a representation of the HTTP resource identified by the request URI.
Upon success, a 2.05 (Content) Response Code SHOULD be returned.
The payload of the response MUST be a representation of the target HTTP resource, and the Content-Format Option MUST be set accordingly.
The response MUST indicate a Max-Age value that is no greater than the remaining time the representation can be considered fresh.
If the HTTP entity has an entity-tag, the proxy SHOULD include an ETag Option in the response and process ETag Options in requests as described below.
A client can influence the processing of a GET request by including the following option: Accept: The request MAY include an Accept Option, identifying the preferred response content-format.
ETag: The request MAY include one or more ETag Options, identifying responses that the client has stored.
This requests the proxy to send a 2.03 (Valid) response whenever it would send a 2.05 (Content) response with an entity-tag in the requested set otherwise.
Note that CoAP ETags are always strong ETags in the HTTP sense; CoAP does not have the equivalent of HTTP weak ETags, and there is no good way to make use of these in a cross-proxy.
PUT The PUT method requests the proxy to update or create the HTTP resource identified by the request URI with the enclosed representation.
If a new resource is created at the request URI, a 2.01 (Created) response MUST be returned to the client.
If an existing resource is modified, a 2.04 (Changed) response MUST be returned to indicate successful completion of the request.
DELETE The DELETE method requests the proxy to delete the HTTP resource identified by the request URI at the HTTP origin server.
A 2.02 (Deleted) response MUST be returned to the client upon success or if the resource does not exist at the time of the request.
POST The POST method requests the proxy to have the representation enclosed in the request be processed by the HTTP origin server.
The actual function performed by the POST method is determined by the origin server and dependent on the resource identified by the request URI.
If the action performed by the POST method does not result in a resource that can be identified by a URI, a 2.04 (Changed) response MUST be returned to the client.
If a resource has been created on the origin server, a 2.01 (Created) response MUST be returned.
HTTP-CoAP Proxying If an HTTP request contains a Request-URI with a "coap" or "coaps" URI, then the receiving HTTP endpoint (called "the proxy" henceforth) is requested to perform the operation specified by the request method on the indicated CoAP resource and return the result to the client.
This section specifies for any HTTP request the HTTP response that the proxy should return to the client.
Unless otherwise specified, all the statements made are RECOMMENDED behavior; some highly constrained implementations may need to resort to shortcuts.
How the proxy actually satisfies the request is an implementation detail, although the typical case is expected to be that the proxy translates and forwards the request to a CoAP origin server.
The meanings of the individual HTTP methods when performed on CoAP resources are explained in the subsections of this section.
If the proxy is unable or unwilling to service a request with a CoAP URI, a 501 (Not Implemented) response is returned to the client.
If the proxy services the request by interacting with a third party (such as the CoAP origin server) and is unable to obtain a result within a reasonable time frame, a 504 (Gateway Timeout) response is returned; if a result can be obtained but is not understood, a 502 (Bad Gateway) response is returned.
OPTIONS and TRACE As the OPTIONS and TRACE methods are not supported in CoAP, a 501 (Not Implemented) error MUST be returned to the client.
GET The GET method requests the proxy to return a representation of the CoAP resource identified by the Request-URI.
Upon success, a 200 (OK) response is returned.
The payload of the response MUST be a representation of the target CoAP resource, and the Content-Type and Content-Encoding header fields MUST be set accordingly.
The response MUST indicate a max-age directive that indicates a value no greater than the remaining time the representation can be considered fresh.
If the CoAP response has an ETag option, the proxy should include an ETag header field in the response.
A client can influence the processing of a GET request by including the following options: Accept: The most-preferred media type of the HTTP Accept header field in a request is mapped to a CoAP Accept option.
HTTP Accept media-type ranges, parameters, and extensions are not supported by the CoAP Accept option.
If the proxy cannot send a response that is acceptable according to the combined Accept field value, then the proxy sends a 406 (Not Acceptable) response.
The proxy MAY then retry the request with further media types from the HTTP Accept header field.
Conditional GETs: Conditional HTTP GET requests that include an "If-Match" or "If-None-Match" request-header field can be mapped to a corresponding CoAP request.
The "If-Modified-Since" and "If-Unmodified-Since" request-header fields are not directly supported by CoAP but are implemented locally by a caching proxy.
HEAD The HEAD method is identical to GET except that the server MUST NOT return a message-body in the response.
Although there is no direct equivalent of HTTP's HEAD method in CoAP, an HTTP-CoAP proxy responds to HEAD requests for CoAP resources, and the HTTP headers are returned without a message-body.
Implementation Note: An HTTP-CoAP proxy may want to try using a block-wise transfer option [BLOCK] to minimize the amount of data actually transferred, but it needs to be prepared for the case that the origin server does not support block-wise transfers.
POST The POST method requests the proxy to have the representation enclosed in the request be processed by the CoAP origin server.
The actual function performed by the POST method is determined by the origin server and dependent on the resource identified by the request URI.
If the action performed by the POST method does not result in a resource that can be identified by a URI, a 200 (OK) or 204 (No Content) response MUST be returned to the client.
If a resource has been created on the origin server, a 201 (Created) response MUST be returned.
If any of the Location-* Options are present in the CoAP response, a Location header field constructed from the values of these options is returned.
PUT The PUT method requests the proxy to update or create the CoAP resource identified by the Request-URI with the enclosed representation.
If a new resource is created at the Request-URI, a 201 (Created) response is returned to the client.
If an existing resource is modified, either the 200 (OK) or 204 (No Content) Response Codes is sent to indicate successful completion of the request.
DELETE The DELETE method requests the proxy to delete the CoAP resource identified by the Request-URI at the CoAP origin server.
A successful response is 200 (OK) if the response includes an entity describing the status or 204 (No Content) if the action has been enacted but the response does not include an entity.
CONNECT This method cannot currently be satisfied by an HTTP-CoAP proxy function, as TLS to DTLS tunneling has not yet been specified.
For now, a 501 (Not Implemented) error is returned to the client.
Security Considerations This section analyzes the possible threats to the protocol.
It is meant to inform protocol and application developers about the security limitations of CoAP as described in this document.
As CoAP realizes a subset of the features in HTTP/1.1, the security considerations in SectionÂ 15 of [RFC2616] are also pertinent to CoAP.
This section concentrates on describing limitations specific to CoAP.
Parsing the Protocol and Processing URIs A network-facing application can exhibit vulnerabilities in its processing logic for incoming packets.
Complex parsers are well-known as a likely source of such vulnerabilities, such as the ability to remotely crash a node, or even remotely execute arbitrary code on it.
CoAP attempts to narrow the opportunities for introducing such vulnerabilities by reducing parser complexity, by giving the entire range of encodable values a meaning where possible, and by aggressively reducing complexity that is often caused by unnecessary choice between multiple representations that mean the same thing.
Much of the URI processing has been moved to the clients, further reducing the opportunities for introducing vulnerabilities into the servers.
Even so, the URI processing code in CoAP implementations is likely to be a large source of remaining vulnerabilities and should be implemented with special care.
CoAP access control implementations need to ensure they don't introduce vulnerabilities through discrepancies between the code deriving access control decisions from a URI and the code finally serving up the resource addressed by the URI.
The most complex parser remaining could be the one for the CoRE Link Format, although this also has been designed with a goal of reduced implementation complexity [RFC6690].
(See also SectionÂ 15.2 of [RFC2616].)
Proxying and Caching As mentioned in SectionÂ 15.7 of [RFC2616], proxies are by their very nature men-in-the-middle, breaking any IPsec or DTLS protection that a direct CoAP message exchange might have.
They are therefore interesting targets for breaking confidentiality or integrity of CoAP message exchanges.
As noted in [RFC2616], they are also interesting targets for breaking availability.
The threat to confidentiality and integrity of request/response data is amplified where proxies also cache.
Note that CoAP does not define any of the cache-suppressing Cache-Control options that HTTP/1.1 provides to better protect sensitive data.
For a caching implementation, any access control considerations that would apply to making the request that generated the cache entry also need to be applied to the value in the cache.
This is relevant for clients that implement multiple security domains, as well as for proxies that may serve multiple clients.
Also, a caching proxy MUST NOT make cached values available to requests that have lesser transport-security properties than those the proxy would require to perform request forwarding in the first place.
Unlike the "coap" scheme, responses to "coaps" identified requests are never "public" and thus MUST NOT be reused for shared caching, unless the cache is able to make equivalent access control decisions to the ones that led to the cached entry.
They can, however, be reused in a private cache if the message is cacheable by default in CoAP.
Finally, a proxy that fans out Separate Responses (as opposed to piggybacked Responses) to multiple original requesters may provide additional amplification (see Section 11.3).
Risk of Amplification CoAP servers generally reply to a request packet with a response packet.
This response packet may be significantly larger than the request packet.
An attacker might use CoAP nodes to turn a small attack packet into a larger attack packet, an approach known as amplification.
There is therefore a danger that CoAP nodes could become implicated in denial-of-service (DoS) attacks by using the amplifying properties of the protocol: an attacker that is attempting to overload a victim but is limited in the amount of traffic it can generate can use amplification to generate a larger amount of traffic.
This is particularly a problem in nodes that enable NoSec access, are accessible from an attacker, and can access potential victims (e.g., on the general Internet), as the UDP protocol provides no way to verify the source address given in the request packet.
An attacker need only place the IP address of the victim in the source address of a suitable request packet to generate a larger packet directed at the victim.
As a mitigating factor, many constrained networks will only be able to generate a small amount of traffic, which may make CoAP nodes less attractive for this attack.
However, the limited capacity of the constrained network makes the network itself a likely victim of an amplification attack.
Therefore, large amplification factors SHOULD NOT be provided in the response if the request is not authenticated.
A CoAP server can reduce the amount of amplification it provides to an attacker by using slicing/blocking modes of CoAP [BLOCK] and offering large resource representations only in relatively small slices.
For example, for a 1000-byte resource, a 10-byte request might result in an 80-byte response (with a 64-byte block) instead of a 1016-byte response, considerably reducing the amplification provided.
CoAP also supports the use of multicast IP addresses in requests, an important requirement for M2M.
Multicast CoAP requests may be the source of accidental or deliberate DoS attacks, especially over constrained networks.
This specification attempts to reduce the amplification effects of multicast requests by limiting when a response is returned.
To limit the possibility of malicious use, CoAP servers SHOULD NOT accept multicast requests that can not be authenticated in some way, cryptographically or by some multicast boundary limiting the potential sources.
If possible, a CoAP server SHOULD limit the support for multicast requests to the specific resources where the feature is required.
On some general-purpose operating systems providing a POSIX-style API [IEEE1003.1], it is not straightforward to find out whether a packet received was addressed to a multicast address.
While many implementations will know whether they have joined a multicast group, this creates a problem for packets addressed to multicast addresses of the form FF0x::1, which are received by every IPv6 node.
Implementations SHOULD make use of modern APIs such as IPV6_RECVPKTINFO [RFC3542], if available, to make this determination.
IP Address Spoofing Attacks Due to the lack of a handshake in UDP, a rogue endpoint that is free to read and write messages carried by the constrained network (i.e., NoSec or PreSharedKey deployments with a nodes/key ratio > 1:1), may easily attack a single endpoint, a group of endpoints, as well as the whole network, e.g., by: 1. spoofing a Reset message in response to a Confirmable message or Non-confirmable message, thus making an endpoint "deaf"; or 2. spoofing an ACK in response to a CON message, thus potentially preventing the sender of the CON message from retransmitting, and drowning out the actual response; or 3. spoofing the entire response with forged payload/options (this has different levels of impact: from single-response disruption, to much bolder attacks on the supporting infrastructure, e.g., poisoning proxy caches, or tricking validation/lookup interfaces in resource directories and, more generally, any component that stores global network state and uses CoAP as the messaging facility to handle setting or updating state is a potential target.
); or 4. spoofing a multicast request for a target node; this may result in network congestion/collapse, a DoS attack on the victim, or forced wake-up from sleeping; or 5. spoofing observe messages, etc.
Response spoofing by off-path attackers can be detected and mitigated even without transport layer security by choosing a nontrivial, randomized token in the request (Section 5.3.1).
[RFC4086] discusses randomness requirements for security.
In principle, other kinds of spoofing can be detected by CoAP only in case Confirmable message semantics is used, because of unexpected Acknowledgement or Reset messages coming from the deceived endpoint.
But this imposes keeping track of the used Message IDs, which is not always possible, and moreover detection becomes available usually after the damage is already done.
This kind of attack can be prevented using security modes other than NoSec.
With or without source address spoofing, a client can attempt to overload a server by sending requests, preferably complex ones, to a server; address spoofing makes tracing back, and blocking, this attack harder.
Given that the cost of a CON request is small, this attack can easily be executed.
Under this attack, a constrained node with limited total energy available may exhaust that energy much more quickly than planned (battery depletion attack).
Also, if the client uses a Confirmable message and the server responds with a Confirmable separate response to a (possibly spoofed) address that does not respond, the server will have to allocate buffer and retransmission logic for each response up to the exhaustion of MAX_TRANSMIT_SPAN, making it more likely that it runs out of resources for processing legitimate traffic.
The latter problem can be mitigated somewhat by limiting the rate of responses as discussed in Section 4.7.
An attacker could also spoof the address of a legitimate client; this might cause the server, if it uses separate responses, to block legitimate responses to that client because of NSTART=1.
All these attacks can be prevented using a security mode other than NoSec, thus leaving only attacks on the security protocol.
Cross-Protocol Attacks The ability to incite a CoAP endpoint to send packets to a fake source address can be used not only for amplification, but also for cross-protocol attacks against a victim listening to UDP packets at a given address (IP address and port).
This would occur as follows: o The attacker sends a message to a CoAP endpoint with the given address as the fake source address.
o The CoAP endpoint replies with a message to the given source address.
o The victim at the given address receives a UDP packet that it interprets according to the rules of a different protocol.
This may be used to circumvent firewall rules that prevent direct communication from the attacker to the victim but happen to allow communication from the CoAP endpoint (which may also host a valid role in the other protocol) to the victim.
Also, CoAP endpoints may be the victim of a cross-protocol attack generated through an endpoint of another UDP-based protocol such as DNS.
In both cases, attacks are possible if the security properties of the endpoints rely on checking IP addresses (and firewalling off direct attacks sent from outside using fake IP addresses).
In general, because of their lack of context, UDP-based protocols are relatively easy targets for cross-protocol attacks.
Finally, CoAP URIs transported by other means could be used to incite clients to send messages to endpoints of other protocols.
One mitigation against cross-protocol attacks is strict checking of the syntax of packets received, combined with sufficient difference in syntax.
As an example, it might help if it were difficult to incite a DNS server to send a DNS response that would pass the checks of a CoAP endpoint.
Unfortunately, the first two bytes of a DNS reply are an ID that can be chosen by the attacker and that map into the interesting part of the CoAP header, and the next two bytes are then interpreted as CoAP's Message ID (i.e., any value is acceptable).
The DNS count words may be interpreted as multiple instances of a (nonexistent but elective) CoAP option 0, or possibly as a Token.
The echoed query finally may be manufactured by the attacker to achieve a desired effect on the CoAP endpoint; the response added by the server (if any) might then just be interpreted as added payload.
In general, for any pair of protocols, one of the protocols can very well have been designed in a way that enables an attacker to cause the generation of replies that look like messages of the other protocol.
It is often much harder to ensure or prove the absence of viable attacks than to generate examples that may not yet completely enable an attack but might be further developed by more creative minds.
Cross-protocol attacks can therefore only be completely mitigated if endpoints don't authorize actions desired by an attacker just based on trusting the source IP address of a packet.
Conversely, a NoSec environment that completely relies on a firewall for CoAP security not only needs to firewall off the CoAP endpoints but also all other endpoints that might be incited to send UDP messages to CoAP endpoints using some other UDP-based protocol.
In addition to the considerations above, the security considerations for DTLS with respect to cross-protocol attacks apply.
For example, if the same DTLS security association ("connection") is used to carry data of multiple protocols, DTLS no longer provides protection against cross-protocol attacks between these protocols.
Constrained-Node Considerations Implementers on constrained nodes often find themselves without a good source of entropy [RFC4086].
If that is the case, the node MUST NOT be used for processes that require good entropy, such as key generation.
Instead, keys should be generated externally and added to the device during manufacturing or commissioning.
Due to their low processing power, constrained nodes are particularly susceptible to timing attacks.
Special care must be taken in implementation of cryptographic primitives.
Large numbers of constrained nodes will be installed in exposed environments and will have little resistance to tampering, including recovery of keying materials.
This needs to be considered when defining the scope of credentials assigned to them.
In particular, assigning a shared key to a group of nodes may make any single constrained node a target for subverting the entire group.
IANA Considerations12.1.
CoAP Code Registries This document defines two sub-registries for the values of the Code field in the CoAP header within the "Constrained RESTful Environments (CoRE) Parameters" registry, hereafter referred to as the "CoRE Parameters" registry.
Values in the two sub-registries are eight-bit values notated as three decimal digits c.dd separated by a period between the first and the second digit; the first digit c is between 0 and 7 and denotes the code class; the second and third digits dd denote a decimal number between 00 and 31 for the detail.
All Code values are assigned by sub-registries according to the following ranges: 0.00 Indicates an Empty message (see Section 4.1).
0.01-0.31 Indicates a request.
Values in this range are assigned by the "CoAP Method Codes" sub-registry (see Section 12.1.1).
1.00-1.31 Reserved 2.00-5.31 Indicates a response.
Values in this range are assigned by the "CoAP Response Codes" sub-registry (see Section 12.1.2).
6.00-7.31 Reserved12.1.1.
Method Codes The name of the sub-registry is "CoAP Method Codes".
Each entry in the sub-registry must include the Method Code in the range 0.01-0.31, the name of the method, and a reference to the method's documentation.
All other Method Codes are Unassigned.
The IANA policy for future additions to this sub-registry is "IETF Review or IESG Approval" as described in [RFC5226].
The documentation of a Method Code should specify the semantics of a request with that code, including the following properties: o The Response Codes the method returns in the success case.
o Whether the method is idempotent, safe, or both.
Response Codes The name of the sub-registry is "CoAP Response Codes".
Each entry in the sub-registry must include the Response Code in the range 2.00-5.31, a description of the Response Code, and a reference to the Response Code's documentation.
The Response Codes 3.00-3.31 are Reserved for future use.
All other Response Codes are Unassigned.
The IANA policy for future additions to this sub-registry is "IETF Review or IESG Approval" as described in [RFC5226].
The documentation of a Response Code should specify the semantics of a response with that code, including the following properties: o The methods the Response Code applies to.
o Whether payload is required, optional, or not allowed.
o The semantics of the payload.
For example, the payload of a 2.05 (Content) response is a representation of the target resource; the payload in an error response is a human-readable diagnostic payload.
o The format of the payload.
For example, the format in a 2.05 (Content) response is indicated by the Content-Format Option; the format of the payload in an error response is always Net-Unicode text.
o Whether the response is cacheable according to the freshness model.
o Whether the response is validatable according to the validation model.
o Whether the response causes a cache to mark responses stored for the request URI as not fresh.
CoAP Option Numbers Registry This document defines a sub-registry for the Option Numbers used in CoAP options within the "CoRE Parameters" registry.
The name of the sub-registry is "CoAP Option Numbers".
Each entry in the sub-registry must include the Option Number, the name of the option, and a reference to the option's documentation.
The IANA policy for future additions to this sub-registry is split into three tiers as follows.
The range of 0..255 is reserved for options defined by the IETF (IETF Review or IESG Approval).
The range of 256..2047 is reserved for commonly used options with public specifications (Specification Required).
The range of 2048..64999 is for all other options including private or vendor-specific ones, which undergo a Designated Expert review to help ensure that the option semantics are defined correctly.
The option numbers between 65000 and 65535 inclusive are reserved for experiments.
They are not meant for vendor-specific use of any kind and MUST NOT be used in operational deployments.
The documentation of an Option Number should specify the semantics of an option with that number, including the following properties: o The meaning of the option in a request.
o The meaning of the option in a response.
o Whether the option is critical or elective, as determined by the Option Number.
o Whether the option is Safe-to-Forward, and, if yes, whether it is part of the Cache-Key, as determined by the Option Number (see Section 5.4.2).
o The format and length of the option's value.
o Whether the option must occur at most once or whether it can occur multiple times.
o The default value, if any.
For a critical option with a default value, a discussion on how the default value enables processing by implementations that do not support the critical option (Section 5.4.4).
CoAP Content-Formats Registry Internet media types are identified by a string, such as "application/xml" [RFC2046].
In order to minimize the overhead of using these media types to indicate the format of payloads, this document defines a sub-registry for a subset of Internet media types to be used in CoAP and assigns each, in combination with a content-coding, a numeric identifier.
The name of the sub-registry is "CoAP Content-Formats", within the "CoRE Parameters" registry.
Each entry in the sub-registry must include the media type registered with IANA, the numeric identifier in the range 0-65535 to be used for that media type in CoAP, the content-coding associated with this identifier, and a reference to a document describing what a payload with that media type means semantically.
CoAP does not include a separate way to convey content-encoding information with a request or response, and for that reason the content-encoding is also specified for each identifier (if any).
If multiple content-encodings will be used with a media type, then a separate Content-Format identifier for each is to be registered.
Similarly, other parameters related to an Internet media type, such as level, can be defined for a CoAP Content-Format entry.
The identifiers between 65000 and 65535 inclusive are reserved for experiments.
They are not meant for vendor-specific use of any kind and MUST NOT be used in operational deployments.
The identifiers between 256 and 9999 are reserved for future use in IETF specifications (IETF Review or IESG Approval).
All other identifiers are Unassigned.
Because the namespace of single-byte identifiers is so small, the IANA policy for future additions in the range 0-255 inclusive to the sub-registry is "Expert Review" as described in [RFC5226].
The IANA policy for additions in the range 10000-64999 inclusive is "First Come First Served" as described in [RFC5226].
This is summarized in the following table.
In machine-to-machine applications, it is not expected that generic Internet media types such as text/plain, application/xml or application/octet-stream are useful for real applications in the long term.
It is recommended that M2M applications making use of CoAP request new Internet media types from IANA indicating semantic information about how to create or parse a payload.
For example, a Smart Energy application payload carried as XML might request a more specific type like application/se+xml or application/se-exi.
URI Scheme Registration This document contains the request for the registration of the Uniform Resource Identifier (URI) scheme "coap".
The registration request complies with [RFC4395].
URI scheme name.
coap Status.
Permanent.
URI scheme syntax.
Defined in SectionÂ 6.1 of [RFC7252].
URI scheme semantics.
The "coap" URI scheme provides a way to identify resources that are potentially accessible over the Constrained Application Protocol (CoAP).
The resources can be located by contacting the governing CoAP server and operated on by sending CoAP requests to the server.
This scheme can thus be compared to the "http" URI scheme [RFC2616].
See SectionÂ 6 of [RFC7252] for the details of operation.
Encoding considerations.
The scheme encoding conforms to the encoding rules established for URIs in [RFC3986], i.e., internationalized and reserved characters are expressed using UTF-8-based percent-encoding.
Applications/protocols that use this URI scheme name.
The scheme is used by CoAP endpoints to access CoAP resources.
Interoperability considerations.
None.
Security considerations.
See SectionÂ 11.1 of [RFC7252].
Contact.
IETF Chair <chair@ietf.org> Author/Change controller.
IESG <iesg@ietf.org> References.
[RFC7252]12.5.
Secure URI Scheme Registration This document contains the request for the registration of the Uniform Resource Identifier (URI) scheme "coaps".
The registration request complies with [RFC4395].
URI scheme name.
coaps Status.
Permanent.
URI scheme syntax.
Defined in SectionÂ 6.2 of [RFC7252].
URI scheme semantics.
The "coaps" URI scheme provides a way to identify resources that are potentially accessible over the Constrained Application Protocol (CoAP) using Datagram Transport Layer Security (DTLS) for transport security.
The resources can be located by contacting the governing CoAP server and operated on by sending CoAP requests to the server.
This scheme can thus be compared to the "https" URI scheme [RFC2616].
See SectionÂ 6 of [RFC7252] for the details of operation.
Encoding considerations.
The scheme encoding conforms to the encoding rules established for URIs in [RFC3986], i.e., internationalized and reserved characters are expressed using UTF-8-based percent-encoding.
Applications/protocols that use this URI scheme name.
The scheme is used by CoAP endpoints to access CoAP resources using DTLS.
Interoperability considerations.
None.
Security considerations.
See SectionÂ 11.1 of [RFC7252].
Contact.
IETF Chair <chair@ietf.org> Author/Change controller.
IESG <iesg@ietf.org> References.
[RFC7252]12.6.
Service Name and Port Number Registration One of the functions of CoAP is resource discovery: a CoAP client can ask a CoAP server about the resources offered by it (see Section 7).
To enable resource discovery just based on the knowledge of an IP address, the CoAP port for resource discovery needs to be standardized.
IANA has assigned the port number 5683 and the service name "coap", in accordance with [RFC6335].
Besides unicast, CoAP can be used with both multicast and anycast.
Service Name.
coap Transport Protocol.
udp Assignee.
IESG <iesg@ietf.org> Contact.
IETF Chair <chair@ietf.org> Description.
Constrained Application Protocol (CoAP) Reference.
[RFC7252] Port Number.
Secure Service Name and Port Number Registration CoAP resource discovery may also be provided using the DTLS-secured CoAP "coaps" scheme.
Thus, the CoAP port for secure resource discovery needs to be standardized.
IANA has assigned the port number 5684 and the service name "coaps", in accordance with [RFC6335].
Besides unicast, DTLS-secured CoAP can be used with anycast.
Service Name.
coaps Transport Protocol.
udp Assignee.
IESG <iesg@ietf.org> Contact.
IETF Chair <chair@ietf.org> Description.
DTLS-secured CoAP Reference.
[RFC7252] Port Number.
Multicast Address Registration Section 8, "Multicast CoAP", defines the use of multicast.
IANA has assigned the following multicast addresses for use by CoAP nodes: IPv4 --"All CoAP Nodes" address 224.0.1.187, from the "IPv4 Multicast Address Space Registry".
As the address is used for discovery that may span beyond a single network, it has come from the Internetwork Control Block (224.0.1.x, RFC 5771).
IPv6 --"All CoAP Nodes" address FF0X::FD, from the "IPv6 Multicast Address Space Registry", in the "Variable Scope Multicast Addresses" space (RFC 3307).
Note that there is a distinct multicast address for each scope that interested CoAP nodes should listen to; CoAP needs the Link-Local and Site-Local scopes only.

Introduction The work on Constrained RESTful Environments (CoRE) aims at realizing the Representational State Transfer (REST) architecture in a suitable form for the most constrained nodes (such as microcontrollers with limited RAM and ROM [RFC7228]) and networks (such as IPv6 over Low-Power Wireless Personal Area Networks (6LoWPANs) [RFC4944]) [RFC7252].
The CoAP protocol is intended to provide RESTful [REST] services not unlike HTTP [RFC7230], while reducing the complexity of implementation as well as the size of packets exchanged in order to make these services useful in a highly constrained network of highly constrained nodes.
This objective requires restraint in a number of sometimes conflicting ways: o reducing implementation complexity in order to minimize code size, o reducing message sizes in order to minimize the number of fragments needed for each message (to maximize the probability of delivery of the message), the amount of transmission power needed, and the loading of the limited-bandwidth channel, o reducing requirements on the environment such as stable storage, good sources of randomness, or user-interaction capabilities.
Because CoAP is based on datagram transports such as UDP or Datagram Transport Layer Security (DTLS), the maximum size of resource representations that can be transferred without too much fragmentation is limited.
In addition, not all resource representations will fit into a single link-layer packet of a constrained network, which may cause adaptation layer fragmentation even if IP-layer fragmentation is not required.
Using fragmentation (either at the adaptation layer or at the IP layer) for the transport of larger representations would be possible up to the maximum size of the underlying datagram protocol (such as UDP), but the fragmentation/reassembly process burdens the lower layers with conversation state that is better managed in the application layer.
The present specification defines a pair of CoAP options to enable block-wise access to resource representations.
The Block options provide a minimal way to transfer larger resource representations in a block-wise fashion.
The overriding objective is to avoid the need for creating conversation state at the server for block-wise GET requests.
(It is impossible to fully avoid creating conversation state for POST/PUT, if the creation/replacement of resources is to be atomic; where that property is not needed, there is no need to create server conversation state in this case, either.)
Block-wise transfers are realized as combinations of exchanges, each of which is performed according to the CoAP base protocol [RFC7252].
Each exchange in such a combination is governed by the specifications in [RFC7252], including the congestion control specifications (Section 4.7 of [RFC7252]) and the security considerations (Section 11 of [RFC7252]; additional security considerations then apply to the transfers as a whole, see Section 7).
The present specification minimizes the constraints it adds to those base exchanges; however, not all variants of using CoAP are very useful inside a block-wise transfer (e.g., using Non-confirmable requests within block-wise transfers outside the use case of Section 2.8 would escalate the overall non-delivery probability).
To be perfectly clear, the present specification also does not remove any of the constraints posed by the base specification it is strictly layered on top of.
For example, back-to-back packets are limited by the congestion control described in Section 4.7 of [RFC7252] (NSTART as a limit for initiating exchanges, PROBING_RATE as a limit for sending with no response); block-wise transfers cannot send/solicit more traffic than a client could be sending to / soliciting from the same server without the block-wise mode.
In some cases, the present specification will RECOMMEND that a client perform a sequence of block-wise transfers "without undue delay".
This cannot be phrased as an interoperability requirement, but is an expectation on implementation quality.
Conversely, the expectation is that servers will not have to go out of their way to accommodate clients that take considerable time to finish a block-wise transfer.
For example, for a block-wise GET, if the resource changes while this proceeds, the entity-tag (ETag) for a further block obtained may be different.
To avoid this happening all the time for a fast-changing resource, a server MAY try to keep a cache around for a specific client for a short amount of time.
The expectation here is that the lifetime for such a cache can be kept short, on the order of a few expected round-trip times, counting from the previous block transferred.
In summary, this specification adds a pair of Block options to CoAP that can be used for block-wise transfers.
Benefits of using these options include: o Transfers larger than what can be accommodated in constrained-network link-layer packets can be performed in smaller blocks.
o No hard-to-manage conversation state is created at the adaptation layer or IP layer for fragmentation.
o The transfer of each block is acknowledged, enabling individual retransmission if required.
o Both sides have a say in the block size that actually will be used.
o The resulting exchanges are easy to understand using packet analyzer tools, and thus quite accessible to debugging.
o If needed, the Block options can also be used (without changes) to provide random access to power-of-two sized blocks within a resource representation.
A CoAP implementation that does not support these options generally is limited in the size of the representations that can be exchanged, see Section 4.6 of [RFC7252].
Even though the options are Critical, a server may decide to start using them in an unsolicited way in a response.
No effort was expended to provide a capability indication mechanism supporting that decision: since the block-wise transfer mechanisms are so fundamental to the use of CoAP for representations larger than about a kilobyte, there is an expectation that they are very widely implemented.
The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT", "SHOULD", "SHOULD NOT", "RECOMMENDED", "NOT RECOMMENDED", "MAY", and "OPTIONAL" in this document are to be interpreted as described in RFC 2119, BCP 14 [RFC2119] and indicate requirement levels for compliant CoAP implementations.
In this document, the term "byte" is used in its now customary sense as a synonym for "octet".
Where bit arithmetic is explained, this document uses the notation familiar from the programming language C, except that the operator "**" stands for exponentiation.
Block-Wise Transfers As discussed in the introduction, there are good reasons to limit the size of datagrams in constrained networks: o by the maximum datagram size (~ 64 KiB for UDP) o by the desire to avoid IP fragmentation (MTU of 1280 for IPv6) o by the desire to avoid adaptation-layer fragmentation (60-80 bytes for 6LoWPAN [RFC4919]) When a resource representation is larger than can be comfortably transferred in the payload of a single CoAP datagram, a Block option can be used to indicate a block-wise transfer.
As payloads can be sent both with requests and with responses, this specification provides two separate options for each direction of payload transfer.
In naming these options (for block-wise transfers as well as in Section 4), we use the number 1 ("Block1", "Size1") to refer to the transfer of the resource representation that pertains to the request, and the number 2 ("Block2", "Size2") to refer to the transfer of the resource representation for the response.
In the following, the term "payload" will be used for the actual content of a single CoAP message, i.e., a single block being transferred, while the term "body" will be used for the entire resource representation that is being transferred in a block-wise fashion.
The Content-Format Option applies to the body, not to the payload; in particular, the boundaries between the blocks may be in places that are not separating whole units in terms of the structure, encoding, or content-coding used by the Content-Format.
(Similarly, the ETag Option defined in Section 5.10.6 of [RFC7252] applies to the whole representation of the resource, and thus to the body of the response.)
In most cases, all blocks being transferred for a body (except for the last one) will be of the same size.
(If the first request uses a bigger block size than the receiver prefers, subsequent requests will use the preferred block size.)
The block size is not fixed by the protocol.
To keep the implementation as simple as possible, the Block options support only a small range of power-of-two block sizes, from 2**4 (16) to 2**10 (1024) bytes.
As bodies often will not evenly divide into the power-of-two block size chosen, the size need not be reached in the final block (but even for the final block, the chosen power-of-two size will still be indicated in the block size field of the Block option).
Both Block1 and Block2 Options can be present in both the request and response messages.
In either case, the Block1 Option pertains to the request payload, and the Block2 Option pertains to the response payload.
Hence, for the methods defined in [RFC7252], Block1 is useful with the payload-bearing POST and PUT requests and their responses.
Block2 is useful with GET, POST, and PUT requests and their payload-bearing responses (2.01, 2.02, 2.04, and 2.05 --see Section 5.5 of [RFC7252]).
Where Block1 is present in a request or Block2 in a response (i.e., in that message to the payload of which it pertains) it indicates a block-wise transfer and describes how this specific block-wise payload forms part of the entire body being transferred ("descriptive usage").
Where it is present in the opposite direction, it provides additional control on how that payload will be formed or was processed ("control usage").
Implementation of either Block option is intended to be optional.
However, when it is present in a CoAP message, it MUST be processed (or the message rejected); therefore, it is identified as a Critical option.
Either Block option MUST NOT occur more than once in a single message.
Structure of a Block Option Three items of information may need to be transferred in a Block (Block1 or Block2) option: o the size of the block (SZX); o whether more blocks are following (M); o the relative number of the block (NUM) within a sequence of blocks with the given size.
The value of the Block option is a variable-size (0 to 3 byte) unsigned integer (uint, see Section 3.2 of [RFC7252]).
This integer value encodes these three fields, see Figure 1.
(Due to the CoAP uint-encoding rules, when all of NUM, M, and SZX happen to be zero, a zero-byte integer will be sent.)
The block size is encoded using a three-bit unsigned integer (0 for 2**4 bytes to 6 for 2**10 bytes), which we call the "SZX" ("size exponent"); the actual block size is then "2**(SZX + 4)".
SZX is transferred in the three least significant bits of the option value (i.e., "val & 7" where "val" is the value of the option).
The fourth least significant bit, the M or "more" bit ("val & 8"), indicates whether more blocks are following or if the current block-wise transfer is the last block being transferred.
The option value divided by sixteen (the NUM field) is the sequence number of the block currently being transferred, starting from zero.
The current transfer is, therefore, about the "size" bytes starting at byte "NUM << (SZX + 4)".
Implementation note: As an implementation convenience, "(val & ~0xF) << (val & 7)", i.e., the option value with the last 4 bits masked out, shifted to the left by the value of SZX, gives the byte position of the first byte of the block being transferred.
More specifically, within the option value of a Block1 or Block2 Option, the meaning of the option fields is defined as follows: NUM: Block Number, indicating the block number being requested or provided.
Block number 0 indicates the first block of a body (i.e., starting with the first byte of the body).
M: More Flag ("not last block").
For descriptive usage, this flag, if unset, indicates that the payload in this message is the last block in the body; when set, it indicates that there are one or more additional blocks available.
When a Block2 Option is used in a request to retrieve a specific block number ("control usage"), the M bit MUST be sent as zero and ignored on reception.
(In a Block1 Option in a response, the M flag is used to indicate atomicity, see below.)
SZX: Block Size.
The block size is represented as a three-bit unsigned integer indicating the size of a block to the power of two.
Thus, block size = 2**(SZX + 4).
The allowed values of SZX are 0 to 6, i.e., the minimum block size is 2**(0+4) = 16 and the maximum is 2**(6+4) = 1024.
The value 7 for SZX (which would indicate a block size of 2048) is reserved, i.e., MUST NOT be sent and MUST lead to a 4.00 Bad Request response code upon reception in a request.
There is no default value for the Block1 and Block2 Options.
Absence of one of these options is equivalent to an option value of 0 with respect to the value of NUM and M that could be given in the option, i.e., it indicates that the current block is the first and only block of the transfer (block number 0, M bit not set).
However, in contrast to the explicit value 0, which would indicate an SZX of 0 and thus a size value of 16 bytes, there is no specific explicit size implied by the absence of the option --the size is left unspecified.
(As for any uint, the explicit value 0 is efficiently indicated by a zero-length option; this, therefore, is different in semantics from the absence of the option.)
Block Options in Requests and Responses The Block options are used in one of three roles: o In descriptive usage, i.e., a Block2 Option in a response (such as a 2.05 response for GET), or a Block1 Option in a request (a PUT or POST): * The NUM field in the option value describes what block number is contained in the payload of this message.
* The M bit indicates whether further blocks need to be transferred to complete the transfer of that body.
* The block size implied by SZX MUST match the size of the payload in bytes, if the M bit is set.
(SZX does not govern the payload size if M is unset).
For Block2, if the request suggested a larger value of SZX, the next request MUST move SZX down to the size given in the response.
(The effect is that, if the server uses the smaller of (1) its preferred block size and (2) the block size requested, all blocks for a body use the same block size.)
o A Block2 Option in control usage in a request (e.g., GET): * The NUM field in the Block2 Option gives the block number of the payload that is being requested to be returned in the response.
* In this case, the M bit has no function and MUST be set to zero.
* The block size given (SZX) suggests a block size (in the case of block number 0) or repeats the block size of previous blocks received (in the case of a non-zero block number).
o A Block1 Option in control usage in a response (e.g., a 2.xx response for a PUT or POST request): * The NUM field of the Block1 Option indicates what block number is being acknowledged.
* If the M bit was set in the request, the server can choose whether to act on each block separately, with no memory, or whether to handle the request for the entire body atomically, or any mix of the two.
+ If the M bit is also set in the response, it indicates that this response does not carry the final response code to the request, i.e., the server collects further blocks from the same endpoint and plans to implement the request atomically (e.g., acts only upon reception of the last block of payload).
In this case, the response MUST NOT carry a Block2 Option.
+ Conversely, if the M bit is unset even though it was set in the request, it indicates the block-wise request was enacted now specifically for this block, and the response carries the final response to this request (and to any previous ones with the M bit set in the response's Block1 Option in this sequence of block-wise transfers); the client is still expected to continue sending further blocks, the request method for which may or may not also be enacted per-block.
(Note that the resource is now in a partially updated state; this approach is only appropriate where exposing such an intermediate state is acceptable.
The client can reduce the window by quickly continuing to update the resource, or, in case of failure, restarting the update.)
* Finally, the SZX block size given in a control Block1 Option indicates the largest block size preferred by the server for transfers toward the resource that is the same or smaller than the one used in the initial exchange; the client SHOULD use this block size or a smaller one in all further requests in the transfer sequence, even if that means changing the block size (and possibly scaling the block number accordingly) from now on.
Using one or both Block options, a single REST operation can be split into multiple CoAP message exchanges.
As specified in [RFC7252], each of these message exchanges uses their own CoAP Message ID.
The Content-Format Option sent with the requests or responses MUST reflect the Content-Format of the entire body.
If blocks of a response body arrive with different Content-Format Options, it is up to the client how to handle this error (it will typically abort any ongoing block-wise transfer).
If blocks of a request arrive at a server with mismatching Content-Format Options, the server MUST NOT assemble them into a single request; this usually leads to a 4.08 (Request Entity Incomplete, Section 2.9.2) error response on the mismatching block.
Using the Block2 Option When a request is answered with a response carrying a Block2 Option with the M bit set, the requester may retrieve additional blocks of the resource representation by sending further requests with the same options as the initial request and a Block2 Option giving the block number and block size desired.
In a request, the client MUST set the M bit of a Block2 Option to zero and the server MUST ignore it on reception.
To influence the block size used in a response, the requester MAY also use the Block2 Option on the initial request, giving the desired size, a block number of zero and an M bit of zero.
A server MUST use the block size indicated or a smaller size.
Any further block-wise requests for blocks beyond the first one MUST indicate the same block size that was used by the server in the response for the first request that gave a desired size using a Block2 Option.
Once the Block2 Option is used by the requester and a first response has been received with a possibly adjusted block size, all further requests in a single block-wise transfer will ultimately converge on using the same size, except that there may not be enough content to fill the last block (the one returned with the M bit not set).
(Note that the client may start using the Block2 Option in a second request after a first request without a Block2 Option resulted in a Block2 Option in the response.)
The server uses the block size indicated in the request option or a smaller size, but the requester MUST take note of the actual block size used in the response it receives to its initial request and proceed to use it in subsequent requests.
The server behavior MUST ensure that this client behavior results in the same block size for all responses in a sequence (except for the last one with the M bit not set, and possibly the first one if the initial request did not contain a Block2 Option).
Block-wise transfers can be used to GET resources whose representations are entirely static (not changing over time at all, such as in a schema describing a device), or for dynamically changing resources.
In the latter case, the Block2 Option SHOULD be used in conjunction with the ETag Option ([RFC7252], Section 5.10.6), to ensure that the blocks being reassembled are from the same version of the representation: The server SHOULD include an ETag Option in each response.
If an ETag Option is available, the client, when reassembling the representation from the blocks being exchanged, MUST compare ETag Options.
If the ETag Options do not match in a GET transfer, the requester has the option of attempting to retrieve fresh values for the blocks it retrieved first.
To minimize the resulting inefficiency, the server MAY cache the current value of a representation for an ongoing sequence of requests.
(The server may identify the sequence by the combination of the requesting endpoint and the URI being the same in each block-wise request.)
Note well that this specification makes no requirement for the server to establish any state; however, servers that offer quickly changing resources may thereby make it impossible for a client to ever retrieve a consistent set of blocks.
Clients that want to retrieve all blocks of a resource SHOULD strive to do so without undue delay.
Servers can fully expect to be free to discard any cached state after a period of EXCHANGE_LIFETIME ([RFC7252], Section 4.8.2) after the last access to the state, however, there is no requirement to always keep the state for as long.
The Block2 Option provides no way for a single endpoint to perform multiple concurrently proceeding block-wise response payload transfer (e.g., GET) operations to the same resource.
This is rarely a requirement, but as a workaround, a client may vary the cache key (e.g., by using one of several URIs accessing resources with the same semantics, or by varying a proxy-safe elective option).
Using the Block1 Option In a request with a request payload (e.g., PUT or POST), the Block1 Option refers to the payload in the request (descriptive usage).
In response to a request with a payload (e.g., a PUT or POST transfer), the block size given in the Block1 Option indicates the block size preference of the server for this resource (control usage).
Obviously, at this point the first block has already been transferred by the client without benefit of this knowledge.
Still, the client SHOULD heed the preference indicated and, for all further blocks, use the block size preferred by the server or a smaller one.
Note that any reduction in the block size may mean that the second request starts with a block number larger than one, as the first request already transferred multiple blocks as counted in the smaller size.
To counter the effects of adaptation-layer fragmentation on packet-delivery probability, a client may want to give up retransmitting a request with a relatively large payload even before MAX_RETRANSMIT has been reached, and try restating the request as a block-wise transfer with a smaller payload.
Note that this new attempt is then a new message-layer transaction and requires a new Message ID.
(Because of the uncertainty about whether the request or the acknowledgement was lost, this strategy is useful mostly for idempotent requests.)
In a block-wise transfer of a request payload (e.g., a PUT or POST) that is intended to be implemented in an atomic fashion at the server, the actual creation/replacement takes place at the time the final block, i.e., a block with the M bit unset in the Block1 Option, is received.
In this case, all success responses to non-final blocks carry the response code 2.31 (Continue, Section 2.9.1).
If not all previous blocks are available at the server at the time of processing the final block, the transfer fails and error code 4.08 (Request Entity Incomplete, Section 2.9.2) MUST be returned.
A server MAY also return a 4.08 error code for any (final or non-final) Block1 transfer that is not in sequence; therefore, clients that do not have specific mechanisms to handle this case SHOULD always start with block zero and send the following blocks in order.
One reason that a client might encounter a 4.08 error code is that the server has already timed out and discarded the partial request body being assembled.
Clients SHOULD strive to send all blocks of a request without undue delay.
Servers can fully expect to be free to discard any partial request body when a period of EXCHANGE_LIFETIME ([RFC7252], Section 4.8.2) has elapsed after the most recent block was transferred; however, there is no requirement on a server to always keep the partial request body for as long.
The error code 4.13 (Request Entity Too Large) can be returned at any time by a server that does not currently have the resources to store blocks for a block-wise request payload transfer that it would intend to implement in an atomic fashion.
(Note that a 4.13 response to a request that does not employ Block1 is a hint for the client to try sending Block1, and a 4.13 response with a smaller SZX in its Block1 Option than requested is a hint to try a smaller SZX.)
A block-wise transfer of a request payload that is implemented in a stateless fashion at the server is likely to leave the resource being operated on in an inconsistent state while the transfer is still ongoing or when the client does not complete the transfer.
This characteristic is closer to that of remote file systems than to that of HTTP, where state is always kept on the server during a transfer.
Techniques well known from shared file access (e.g., client-specific temporary resources) can be used to mitigate this difference from HTTP.
The Block1 Option provides no way for a single endpoint to perform multiple concurrently proceeding block-wise request payload transfer (e.g., PUT or POST) operations to the same resource.
Starting a new block-wise sequence of requests to the same resource (before an old sequence from the same endpoint was finished) simply overwrites the context the server may still be keeping.
(This is probably exactly what one wants in this case --the client may simply have restarted and lost its knowledge of the previous sequence.)
Combining Block-Wise Transfers with the Observe Option The Observe option provides a way for a client to be notified about changes over time of a resource [RFC7641].
Resources observed by clients may be larger than can be comfortably processed or transferred in one CoAP message.
The following rules apply to the combination of block-wise transfers with notifications.
Observation relationships always apply to an entire resource; the Block2 Option does not provide a way to observe a single block of a resource.
As with basic GET transfers, the client can indicate its desired block size in a Block2 Option in the GET request establishing or renewing the observation relationship.
If the server supports block-wise transfers, it SHOULD take note of the block size and apply it as a maximum size to all notifications/responses resulting from the GET request (until the client is removed from the list of observers or the entry in that list is updated by the server receiving a new GET request for the resource from the client).
When sending a 2.05 (Content) notification, the server only sends the first block of the representation.
The client retrieves the rest of the representation as if it had caused this first response by a GET request, i.e., by using additional GET requests with Block2 Options containing NUM values greater than zero.
(This results in the transfer of the entire representation, even if only some of the blocks have changed with respect to a previous notification.)
As with other dynamically changing resources, to ensure that the blocks being reassembled are from the same version of the representation, the server SHOULD include an ETag Option in each response, and the reassembling client MUST compare the ETag Options (Section 2.4).
Even more so than for the general case of Block2, clients that want to retrieve all blocks of a resource they have been notified about with a first block SHOULD strive to do so without undue delay.
See Section 3.4 for examples.
Combining Block1 and Block2 In PUT and particularly in POST exchanges, both the request body and the response body may be large enough to require the use of block-wise transfers.
First, the Block1 transfer of the request body proceeds as usual.
In the exchange of the last slice of this block-wise transfer, the response carries the first slice of the Block2 transfer (NUM is zero).
To continue this Block2 transfer, the client continues to send requests similar to the requests in the Block1 phase, but leaves out the Block1 Options and includes a Block2 request option with non-zero NUM.
Block2 transfers that retrieve the response body for a request that used Block1 MUST be performed in sequential order.
Combining Block2 with Multicast A client can use the Block2 Option in a multicast GET request with NUM = 0 to aid in limiting the size of the response.
Similarly, a response to a multicast GET request can use a Block2 Option with NUM = 0 if the representation is large, or to further limit the size of the response.
In both cases, the client retrieves any further blocks using unicast exchanges; in the unicast requests, the client SHOULD heed any block size preferences indicated by the server in the response to the multicast request.
Other uses of the Block options in conjunction with multicast messages are for further study.
Response Codes Beyond the response codes defined in [RFC7252], this specification defines two response codes and extends the meaning of one.
2.31 Continue This new success status code indicates that the transfer of this block of the request body was successful and that the server encourages sending further blocks, but that a final outcome of the whole block-wise request cannot yet be determined.
No payload is returned with this response code.
4.08 Request Entity Incomplete This new client error status code indicates that the server has not received the blocks of the request body that it needs to proceed.
The client has not sent all blocks, not sent them in the order required by the server, or has sent them long enough ago that the server has already discarded them.
(Note that one reason for not having the necessary blocks at hand may be a Content-Format mismatch, see Section 2.3.
Implementation note: A server can reject a Block1 transfer with this code when NUM != 0 and a different Content-Format is indicated than expected from the current state of the resource.
If it implements the transfer in a stateless fashion, it can match up the Content-Format of the block against that of the existing resource.
If it implements the transfer in an atomic fashion, it can match up the block against the partially reassembled piece of representation that is going to replace the state of the resource.)
4.13 Request Entity Too Large In Section 5.9.2.9 of [RFC7252], the response code 4.13 (Request Entity Too Large) is defined to be like HTTP 413 "Request Entity Too Large".
[RFC7252] also recommends that this response SHOULD include a Size1 Option (Section 4) to indicate the maximum size of request entity the server is able and willing to handle, unless the server is not in a position to make this information available.
The present specification allows the server to return this response code at any time during a Block1 transfer to indicate that it does not currently have the resources to store blocks for a transfer that it would intend to implement in an atomic fashion.
It also allows the server to return a 4.13 response to a request that does not employ Block1 as a hint for the client to try sending Block1.
Finally, a 4.13 response to a request with a Block1 Option (control usage, see Section 2.3) where the response carries a smaller SZX in its Block1 Option is a hint to try that smaller SZX.
Caching Considerations This specification attempts to leave a variety of implementation strategies open for caches, in particular those in caching proxies.
For example, a cache is free to cache blocks individually, but also could wait to obtain the complete representation before it serves parts of it.
Partial caching may be more efficient in a cross-proxy (equivalent to a streaming HTTP proxy).
A cached block (partial cached response) can be used in place of a complete response to satisfy a block-wise request that is presented to a cache.
Note that different blocks can have different Max-Age values, as they are transferred at different times.
A response with a block updates the freshness of the complete representation.
Individual blocks can be validated, and validating a single block validates the complete representation.
A response with a Block1 Option in control usage with the M bit set invalidates cached responses for the target URI.
A cache or proxy that combines responses (e.g., to split blocks in a request or increase the block size in a response, or a cross-proxy) may need to combine 2.31 and 2.01/2.04 responses; a stateless server may be responding with 2.01 only on the first Block1 block transferred, which dominates any 2.04 responses for later blocks.
If-None-Match only works correctly on Block1 requests with (NUM=0) and MUST NOT be used on Block1 requests with NUM != 0.
Examples This section gives a number of short examples with message flows for a block-wise GET, and for a PUT or POST.
These examples demonstrate the basic operation, the operation in the presence of retransmissions, and examples for the operation of the block size negotiation.
In all these examples, a Block option is shown in a decomposed way indicating the kind of Block option (1 or 2) followed by a colon, and then the block number (NUM), more bit (M), and block size exponent (2**(SZX+4)) separated by slashes.
For example, a Block2 Option value of 33 would be shown as 2:2/0/32) and a Block1 Option value of 59 would be shown as 1:3/1/128.
As in [RFC7252], "MID" is used as an abbreviation for "Message ID".
Block2 Examples The first example (Figure 2) shows a GET request that is split into three blocks.
The server proposes a block size of 128, and the client agrees.
The first two ACKs contain a payload of 128 bytes each, and the third ACK contains a payload between 1 and 128 bytes.
In the second example (Figure 3), the client anticipates the block-wise transfer (e.g., because of a size indication in the link-format description [RFC6690]) and sends a block size proposal.
All ACK messages except for the last carry 64 bytes of payload; the last one carries between 1 and 64 bytes.
In the third example (Figure 4), the client is surprised by the need for a block-wise transfer, and unhappy with the size chosen unilaterally by the server.
As it did not send a size proposal initially, the negotiation only influences the size from the second message exchange onward.
Since the client already obtained both the first and second 64-byte block in the first 128-byte exchange, it goes on requesting the third 64-byte block ("2/0/64").
None of this is (or needs to be) understood by the server, which simply responds to the requests as it best can.
In all these (and the following) cases, retransmissions are handled by the CoAP message exchange layer, so they don't influence the block operations (Figures 5 and 6).
Block1 Examples The following examples demonstrate a PUT exchange; a POST exchange looks the same, with different requirements on atomicity/idempotence.
Note that, similar to GET, the responses to the requests that have a more bit in the request Block1 Option are provisional and carry the response code 2.31 (Continue); only the final response tells the client that the PUT succeeded.
A stateless server that simply builds/updates the resource in place (statelessly) may indicate this by not setting the more bit in the response (Figure 8); in this case, the response codes are valid separately for each block being updated.
This is of course only an acceptable behavior of the server if the potential inconsistency present during the run of the message exchange sequence does not lead to problems, e.g., because the resource being created or changed is not yet or not currently in use.
Finally, a server receiving a block-wise PUT or POST may want to indicate a smaller block size preference (Figure 9).
In this case, the client SHOULD continue with a smaller block size; if it does, it MUST adjust the block number to properly count in that smaller size.
Combining Block1 and Block2 Block options may be used in both directions of a single exchange.
The following example demonstrates a block-wise POST request, resulting in a separate block-wise response.
This model does provide for early negotiation input to the Block2 block-wise transfer, as shown below.
Early Negotiation3.4.
Combining Observe and Block2 In the following example, the server first sends a direct response (Observe sequence number 62350) to the initial GET request (the resulting block-wise transfer is as in Figure 4 and has therefore been left out).
The second transfer is started by a 2.05 notification that contains just the first block (Observe sequence number 62354); the client then goes on to obtain the rest of the blocks.
(Note that the choice of token 0xfc in this example is arbitrary; tokens are just shown in this example to illustrate that the requests for additional blocks cannot make use of the token of the Observation relationship.
As a general comment on tokens, there is no other mention of tokens in this document, as block-wise transfers handle tokens like any other CoAP exchange.
As usual, the client is free to choose tokens for each exchange as it likes.)
In the following example, the client also uses early negotiation to limit the block size to 64 bytes.
The Size2 and Size1 Options In many cases when transferring a large resource representation block by block, it is advantageous to know the total size early in the process.
Some indication may be available from the maximum size estimate attribute "sz" provided in a resource description [RFC6690].
However, the size may vary dynamically, so a more up-to-date indication may be useful.
This specification defines two CoAP options, Size1 for indicating the size of the representation transferred in requests, and Size2 for indicating the size of the representation transferred in responses.
(Size1 has already been defined in Section 5.10.9 of [RFC7252] to provide "size information about the resource representation in a request"; however, that section only details the narrow case of indicating in 4.13 responses the maximum size of request payload that the server is able and willing to handle.
The present specification provides details about its use as a request option as well.)
The Size2 Option may be used for two purposes: o In a request, to ask the server to provide a size estimate along with the usual response ("size request").
For this usage, the value MUST be set to 0. o In a response carrying a Block2 Option, to indicate the current estimate the server has of the total size of the resource representation, measured in bytes ("size indication").
Similarly, the Size1 Option may be used for two purposes: o In a request carrying a Block1 Option, to indicate the current estimate the client has of the total size of the resource representation, measured in bytes ("size indication").
o In a 4.13 response, to indicate the maximum size that would have been acceptable [RFC7252], measured in bytes.
Apart from conveying/asking for size information, the Size options have no other effect on the processing of the request or response.
If the client wants to minimize the size of the payload in the resulting response, it should add a Block2 Option to the request with a small block size (e.g., setting SZX=0).
The Size options are "elective", i.e., a client MUST be prepared for the server to ignore the size estimate request.
Either Size option MUST NOT occur more than once in a single message.
Implementation Notes: o As a quality of implementation consideration, block-wise transfers for which the total size considerably exceeds the size of one block are expected to include size indications, whenever those can be provided without undue effort (preferably with the first block exchanged).
If the size estimate does not change, the indication does not need to be repeated for every block.
o The end of a block-wise transfer is governed by the M bits in the Block options, _not_ by exhausting the size estimates exchanged.
o As usual for an option of type uint, the value 0 is best expressed as an empty option (0 bytes).
There is no default value for either Size option.
o The Size options are neither critical nor unsafe, and are marked as No-Cache-Key.
HTTP-Mapping Considerations In this subsection, we give some brief examples of the influence that the Block options might have on intermediaries that map between CoAP and HTTP.
For mapping CoAP requests to HTTP, the intermediary may want to map the sequence of block-wise transfers into a single HTTP transfer.
For example, for a GET request, the intermediary could perform the HTTP request once the first block has been requested and could then fulfill all further block requests out of its cache.
A constrained implementation may not be able to cache the entire object and may use a combination of TCP flow control and (in particular if timeouts occur) HTTP range requests to obtain the information necessary for the next block transfer at the right time.
For PUT or POST requests, historically there was more variation in how HTTP servers might implement ranges; recently, [RFC7233] has defined that Range header fields received with a request method other than GET are not to be interpreted.
So, in general, the CoAP-to-HTTP intermediary will have to try sending the payload of all the blocks of a block-wise transfer for these other methods within one HTTP request.
If enough buffering is available, this request can be started when the last CoAP block is received.
A constrained implementation may want to relieve its buffering by already starting to send the HTTP request at the time the first CoAP block is received; any HTTP 408 status code that indicates that the HTTP server became impatient with the resulting transfer can then be mapped into a CoAP 4.08 response code (similarly, 413 maps to 4.13).
For mapping HTTP to CoAP, the intermediary may want to map a single HTTP transfer into a sequence of block-wise transfers.
If the HTTP client is too slow delivering a request body on a PUT or POST, the CoAP server might time out and return a 4.08 response code, which in turn maps well to an HTTP 408 status code (again, 4.13 maps to 413).
HTTP range requests received on the HTTP side may be served out of a cache and/or mapped to GET requests that request a sequence of blocks that cover the range.
(Note that, while the semantics of CoAP 4.08 and HTTP 408 differ, this difference is largely due to the different way the two protocols are mapped to transport.
HTTP has an underlying TCP connection, which supplies connection state, so an HTTP 408 status code can immediately be used to indicate that a timeout occurred during transmitting a request through that active TCP connection.
The CoAP 4.08 response code indicates one or more missing blocks, which may be due to timeouts or resource constraints; as there is no connection state, there is no way to deliver such a response immediately; instead, it is delivered on the next block transfer.
Still, HTTP 408 is probably the best mapping back to HTTP, as the timeout is the most likely cause for a CoAP 4.08.
Note that there is no way to distinguish a timeout from a missing block for a server without creating additional state, the need for which we want to avoid.)
Security Considerations Providing access to blocks within a resource may lead to surprising vulnerabilities.
Where requests are not implemented atomically, an attacker may be able to exploit a race condition or confuse a server by inducing it to use a partially updated resource representation.
Partial transfers may also make certain problematic data invisible to Intrusion Detection Systems (IDSs); it is RECOMMENDED that an IDS that analyzes resource representations transferred by CoAP implement the Block options to gain access to entire resource representations.
Still, approaches such as transferring even-numbered blocks on one path and odd-numbered blocks on another path, or even transferring blocks multiple times with different content and obtaining a different interpretation of temporal order at the IDS than at the server, may prevent an IDS from seeing the whole picture.
These kinds of attacks are well understood from IP fragmentation and TCP segmentation; CoAP does not add fundamentally new considerations.
Where access to a resource is only granted to clients making use of specific security associations, all blocks of that resource MUST be subject to the same security checks; it MUST NOT be possible for unprotected exchanges to influence blocks of an otherwise protected resource.
As a related consideration, where object security is employed, PUT/POST should be implemented in the atomic fashion, unless the object security operation is performed on each access and the creation of unusable resources can be tolerated.
Future end-to-end security mechanisms that may be added to CoAP itself may have related security considerations, this includes considerations about caching of blocks in clients and in proxies (see Sections 2.10 and 5 for different strategies in performing this caching); these security considerations will need to be described in the specifications of those mechanisms.
A stateless server might be susceptible to an attack where the adversary sends a Block1 (e.g., PUT) block with a high block number: A naive implementation might exhaust its resources by creating a huge resource representation.
Misleading size indications may be used by an attacker to induce buffer overflows in poor implementations, for which the usual considerations apply.
Mitigating Resource Exhaustion Attacks Certain block-wise requests may induce the server to create state, e.g., to create a snapshot for the block-wise GET of a fast-changing resource to enable consistent access to the same version of a resource for all blocks, or to create temporary resource representations that are collected until pressed into service by a final PUT or POST with the more bit unset.
All mechanisms that induce a server to create state that cannot simply be cleaned up create opportunities for denial-of-service attacks.
Servers SHOULD avoid being subject to resource exhaustion based on state created by untrusted sources.
But even if this is done, the mitigation may cause a denial-of-service to a legitimate request when it is drowned out by other state-creating requests.
Wherever possible, servers should therefore minimize the opportunities to create state for untrusted sources, e.g., by using stateless approaches.
Performing segmentation at the application layer is almost always better in this respect than at the transport layer or lower (IP fragmentation, adaptation-layer fragmentation), for instance, because there are application-layer semantics that can be used for mitigation or because lower layers provide security associations that can prevent attacks.
However, it is less common to apply timeouts and keepalive mechanisms at the application layer than at lower layers.
Servers MAY want to clean up accumulated state by timing it out (cf.
response code 4.08), and clients SHOULD be prepared to run block-wise transfers in an expedient way to minimize the likelihood of running into such a timeout.
Mitigating Amplification Attacks [RFC7252] discusses the susceptibility of CoAP endpoints for use in amplification attacks.
A CoAP server can reduce the amount of amplification it provides to an attacker by offering large resource representations only in relatively small blocks.
With this, e.g., for a 1000-byte resource, a 10-byte request might result in an 80-byte response (with a 64-byte block) instead of a 1016-byte response, considerably reducing the amplification provided.

Introduction The Constrained Application Protocol (CoAP) [RFC7252] is a web transfer protocol designed for constrained nodes and networks [RFC7228]; CoAP may be mapped from HTTP [RFC8075].
CoAP specifies the use of proxies for scalability and efficiency and references DTLS [RFC6347] for security.
CoAP-to-CoAP, HTTP-to-CoAP, and CoAP-to-HTTP proxies require DTLS or TLS [RFC8446] to be terminated at the proxy.
Therefore, the proxy not only has access to the data required for performing the intended proxy functionality, but is also able to eavesdrop on, or manipulate any part of, the message payload and metadata in transit between the endpoints.
The proxy can also inject, delete, or reorder packets since they are no longer protected by (D)TLS.
This document defines the Object Security for Constrained RESTful Environments (OSCORE) security protocol, protecting CoAP and CoAP-mappable HTTP requests and responses end-to-end across intermediary nodes such as CoAP forward proxies and cross-protocol translators including HTTP-to-CoAP proxies [RFC8075].
In addition to the core CoAP features defined in [RFC7252], OSCORE supports the Observe [RFC7641], Block-wise [RFC7959], and No-Response [RFC7967] options, as well as the PATCH and FETCH methods [RFC8132].
An analysis of end-to-end security for CoAP messages through some types of intermediary nodes is performed in [CoAP-E2E-Sec].
OSCORE essentially protects the RESTful interactions: the request method, the requested resource, the message payload, etc.
(see Section 4), where "RESTful" refers to the Representational State Transfer (REST) Architecture [REST].
OSCORE protects neither the CoAP messaging layer nor the CoAP Token, which may change between the endpoints; therefore, those are processed as defined in [RFC7252].
Additionally, since the message formats for CoAP over unreliable transport [RFC7252] and for CoAP over reliable transport [RFC8323] differ only in terms of CoAP messaging layer, OSCORE can be applied to both unreliable and reliable transports (see Figure 1).
OSCORE works in very constrained nodes and networks, thanks to its small message size and the restricted code and memory requirements in addition to what is required by CoAP.
Examples of the use of OSCORE are given in Appendix A. OSCORE may be used over any underlying layer, such as UDP or TCP, and with non-IP transports (e.g., [CoAP-802.15.4]).
OSCORE may also be used in different ways with HTTP.
OSCORE messages may be transported in HTTP, and OSCORE may also be used to protect CoAP-mappable HTTP messages, as described below.
OSCORE is designed to protect as much information as possible while still allowing CoAP proxy operations (Section 10).
It works with existing CoAP-to-CoAP forward proxies [RFC7252], but an OSCORE-aware proxy will be more efficient.
HTTP-to-CoAP proxies [RFC8075] and CoAP-to-HTTP proxies can also be used with OSCORE, as specified in Section 11.
OSCORE may be used together with TLS or DTLS over one or more hops in the end-to-end path, e.g., transported with HTTPS in one hop and with plain CoAP in another hop.
The use of OSCORE does not affect the URI scheme; therefore, OSCORE can be used with any URI scheme defined for CoAP or HTTP.
The application decides the conditions for which OSCORE is required.
OSCORE uses pre-shared keys that may have been established out-of-band or with a key establishment protocol (see Section 3.2).
The technical solution builds on CBOR Object Signing and Encryption (COSE) [RFC8152], providing end-to-end encryption, integrity, replay protection, and binding of response to request.
A compressed version of COSE is used, as specified in Section 6.
The use of OSCORE is signaled in CoAP with a new option (Section 2), and in HTTP with a new header field (Section 11.1) and content type (Section 13.5).
The solution transforms a CoAP/HTTP message into an "OSCORE message" before sending, and vice versa after receiving.
The OSCORE message is a CoAP/HTTP message related to the original message in the following way: the original CoAP/HTTP message is translated to CoAP (if not already in CoAP) and protected in a COSE object.
The encrypted message fields of this COSE object are transported in the CoAP payload/HTTP body of the OSCORE message, and the OSCORE option/ header field is included in the message.
A sketch of an exchange of OSCORE messages, in the case of the original message being CoAP, is provided in Figure 2.
The use of OSCORE with HTTP is detailed in Section 11.
An implementation supporting this specification MAY implement only the client part, MAY implement only the server part, or MAY implement only one of the proxy parts.
Terminology The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT", "SHOULD", "SHOULD NOT", "RECOMMENDED", "NOT RECOMMENDED", "MAY", and "OPTIONAL" in this document are to be interpreted as described in BCP 14 [RFC2119] [RFC8174] when, and only when, they appear in all capitals, as shown here.
Readers are expected to be familiar with the terms and concepts described in CoAP [RFC7252], COSE [RFC8152], Concise Binary Object Representation (CBOR) [RFC7049], Concise Data Definition Language (CDDL) [RFC8610] as summarized in Appendix E, and constrained environments [RFC7228].
Additional optional features include Observe [RFC7641], Block-wise [RFC7959], No-Response [RFC7967] and CoAP over reliable transport [RFC8323].
The term "hop" is used to denote a particular leg in the end-to-end path.
The concept "hop-by-hop" (as in "hop-by-hop encryption" or "hop-by-hop fragmentation") opposed to "end-to-end", is used in this document to indicate that the messages are processed accordingly in the intermediaries, rather than just forwarded to the next node.
The term "stop processing" is used throughout the document to denote that the message is not passed up to the CoAP request/response layer (see Figure 1).
The terms Common Context, Sender Context, Recipient Context, Master Secret, Master Salt, Sender ID, Sender Key, Recipient ID, Recipient Key, ID Context, and Common IV are defined in Section 3.1.
The OSCORE option is critical, safe to forward, part of the cache key, and not repeatable.
The OSCORE option includes the OSCORE flag bits (Section 6), the Sender Sequence Number, the Sender ID, and the ID Context when these fields are present (Section 3).
The detailed format and length is specified in Section 6.
If the OSCORE flag bits are all zero (0x00), the option value SHALL be empty (Option Length = 0).
An endpoint receiving a CoAP message without payload that also contains an OSCORE option SHALL treat it as malformed and reject it.
A successful response to a request with the OSCORE option SHALL contain the OSCORE option.
Whether error responses contain the OSCORE option depends on the error type (see Section 8).
For CoAP proxy operations, see Section 10.
The Security Context OSCORE requires that client and server establish a shared security context used to process the COSE objects.
OSCORE uses COSE with an Authenticated Encryption with Associated Data (AEAD, [RFC5116]) algorithm for protecting message data between a client and a server.
In this section, we define the security context and how it is derived in client and server based on a shared secret and a key derivation function.
Security Context Definition The security context is the set of information elements necessary to carry out the cryptographic operations in OSCORE.
For each endpoint, the security context is composed of a "Common Context", a "Sender Context", and a "Recipient Context".
The endpoints protect messages to send using the Sender Context and verify messages received using the Recipient Context; both contexts being derived from the Common Context and other data.
Clients and servers need to be able to retrieve the correct security context to use.
An endpoint uses its Sender ID (SID) to derive its Sender Context; the other endpoint uses the same ID, now called Recipient ID (RID), to derive its Recipient Context.
In communication between two endpoints, the Sender Context of one endpoint matches the Recipient Context of the other endpoint, and vice versa.
Thus, the two security contexts identified by the same IDs in the two endpoints are not the same, but they are partly mirrored.
Retrieval and use of the security context are shown in Figure 4.
The Common Context contains the following parameters: o AEAD Algorithm.
The COSE AEAD algorithm to use for encryption.
o HKDF Algorithm.
An HMAC-based key derivation function (HKDF, [RFC5869]) used to derive the Sender Key, Recipient Key, and Common IV.
o Master Secret.
Variable length, random byte string (see Section 12.3) used to derive AEAD keys and Common IV.
o Master Salt.
Optional variable-length byte string containing the salt used to derive AEAD keys and Common IV.
o ID Context.
Optional variable-length byte string providing additional information to identify the Common Context and to derive AEAD keys and Common IV.
The use of ID Context is described in Section 5.1. o Common IV.
Byte string derived from the Master Secret, Master Salt, and ID Context.
Used to generate the AEAD nonce (see Section 5.2).
Same length as the nonce of the AEAD Algorithm.
The Sender Context contains the following parameters: o Sender ID.
Byte string used to identify the Sender Context, to derive AEAD keys and Common IV, and to contribute to the uniqueness of AEAD nonces.
Maximum length is determined by the AEAD Algorithm.
o Sender Key.
Byte string containing the symmetric AEAD key to protect messages to send.
Derived from Common Context and Sender ID.
Length is determined by the AEAD Algorithm.
o Sender Sequence Number.
Non-negative integer used by the sender to enumerate requests and certain responses, e.g., Observe notifications.
Used as "Partial IV" [RFC8152] to generate unique AEAD nonces.
Maximum value is determined by the AEAD Algorithm.
Initialization is described in Section 3.2.2.
The Recipient Context contains the following parameters: o Recipient ID.
Byte string used to identify the Recipient Context, to derive AEAD keys and Common IV, and to contribute to the uniqueness of AEAD nonces.
Maximum length is determined by the AEAD Algorithm.
o Recipient Key.
Byte string containing the symmetric AEAD key to verify messages received.
Derived from Common Context and Recipient ID.
Length is determined by the AEAD Algorithm.
o Replay Window (Server only).
The replay window used to verify requests received.
Replay protection is described in Section 7.4 and Section 3.2.2.
All parameters except Sender Sequence Number and Replay Window are immutable once the security context is established.
An endpoint may free up memory by not storing the Common IV, Sender Key, and Recipient Key, deriving them when needed.
Alternatively, an endpoint may free up memory by not storing the Master Secret and Master Salt after the other parameters have been derived.
Endpoints MAY operate as both client and server and use the same security context for those roles.
Independent of being client or server, the endpoint protects messages to send using its Sender Context, and verifies messages received using its Recipient Context.
The endpoints MUST NOT change the Sender/Recipient ID when changing roles.
In other words, changing the roles does not change the set of AEAD keys to be used.
Establishment of Security Context Parameters Each endpoint derives the parameters in the security context from a small set of input parameters.
The following input parameters SHALL be preestablished: o Master Secret o Sender ID o Recipient ID The following input parameters MAY be preestablished.
In case any of these parameters is not preestablished, the default value indicated below is used: o AEAD Algorithm * Default is AES-CCM-16-64-128 (COSE algorithm encoding: 10) o Master Salt * Default is the empty byte string o HKDF Algorithm * Default is HKDF SHA-256 o Replay Window * The default mechanism is an anti-replay sliding window (see Section 4.1.2.6 of [RFC6347] with a window size of 32 All input parameters need to be known and agreed on by both endpoints, but the Replay Window may be different in the two endpoints.
The way the input parameters are preestablished is application specific.
Considerations of security context establishment are given in Section 12.2 and examples of deploying OSCORE in Appendix B.
Derivation of Sender Key, Recipient Key, and Common IV The HKDF MUST be one of the HMAC-based HKDF [RFC5869] algorithms defined for COSE [RFC8152].
HKDF SHA-256 is mandatory to implement.
The security context parameters Sender Key, Recipient Key, and Common IV SHALL be derived from the input parameters using the HKDF, which consists of the composition of the HKDF-Extract and HKDF-Expand steps [RFC5869]: output parameter = HKDF(salt, IKM, info, L) where: o salt is the Master Salt as defined above o IKM is the Master Secret as defined above o info is the serialization of a CBOR array consisting of (the notation follows [RFC8610] as summarized in Appendix E): info = [ id : bstr, id_context : bstr / nil, alg_aead : int / tstr, type : tstr, L : uint, ] where: o id is the Sender ID or Recipient ID when deriving Sender Key and Recipient Key, respectively, and the empty byte string when deriving the Common IV.
o id_context is the ID Context, or nil if ID Context is not provided.
o alg_aead is the AEAD Algorithm, encoded as defined in [RFC8152].
o type is "Key" or "IV".
The label is an ASCII string and does not include a trailing NUL byte.
o L is the size of the key/nonce for the AEAD Algorithm used, in bytes.
For example, if the algorithm AES-CCM-16-64-128 (see Section 10.2 in [RFC8152]) is used, the integer value for alg_aead is 10, the value for L is 16 for keys and 13 for the Common IV.
Assuming use of the default algorithms HKDF SHA-256 and AES-CCM-16-64-128, the extract phase of HKDF produces a pseudorandom key (PRK) as follows: PRK = HMAC-SHA-256(Master Salt, Master Secret) and as L is smaller than the hash function output size, the expand phase of HKDF consists of a single HMAC invocation; therefore, the Sender Key, Recipient Key, and Common IV are the first 16 or 13 bytes of output parameter = HMAC-SHA-256(PRK, info || 0x01) where different values of info are used for each derived parameter and where || denotes byte string concatenation.
Note that [RFC5869] specifies that if the salt is not provided, it is set to a string of zeros.
For implementation purposes, not providing the salt is the same as setting the salt to the empty byte string.
OSCORE sets the salt default value to empty byte string, which is converted to a string of zeroes (see Section 2.2 of [RFC5869]).
Initial Sequence Numbers and Replay Window The Sender Sequence Number is initialized to 0.
The supported types of replay protection and replay window size is application specific and depends on how OSCORE is transported (see Section 7.4).
The default mechanism is the anti-replay window of received messages used by IPsec AH/ESP and DTLS (see Section 4.1.2.6 of [RFC6347]) with a window size of 32.
Requirements on the Security Context Parameters To ensure unique Sender Keys, the quartet (Master Secret, Master Salt, ID Context, Sender ID) MUST be unique, i.e., the pair (ID Context, Sender ID) SHALL be unique in the set of all security contexts using the same Master Secret and Master Salt.
This means that Sender ID SHALL be unique in the set of all security contexts using the same Master Secret, Master Salt, and ID Context; such a requirement guarantees unique (key, nonce) pairs for the AEAD.
Different methods can be used to assign Sender IDs: a protocol that allows the parties to negotiate locally unique identifiers, a trusted third party (e.g., [ACE-OAuth]), or the identifiers can be assigned out-of-band.
The Sender IDs can be very short (note that the empty string is a legitimate value).
The maximum length of Sender ID in bytes equals the length of the AEAD nonce minus 6, see Section 5.2.
For AES-CCM-16-64-128 the maximum length of Sender ID is 7 bytes.
To simplify retrieval of the right Recipient Context, the Recipient ID SHOULD be unique in the sets of all Recipient Contexts used by an endpoint.
If an endpoint has the same Recipient ID with different Recipient Contexts, i.e., the Recipient Contexts are derived from different Common Contexts, then the endpoint may need to try multiple times before verifying the right security context associated to the Recipient ID.
The ID Context is used to distinguish between security contexts.
The methods used for assigning Sender ID can also be used for assigning the ID Context.
Additionally, the ID Context can be used to introduce randomness into new Sender and Recipient Contexts (see Appendix B.2).
ID Context can be arbitrarily long.
Protected Message Fields OSCORE transforms a CoAP message (which may have been generated from an HTTP message) into an OSCORE message, and vice versa.
OSCORE protects as much of the original message as possible while still allowing certain proxy operations (see Sections 10 and 11).
This section defines how OSCORE protects the message fields and transfers them end-to-end between client and server (in any direction).
The remainder of this section and later sections focus on the behavior in terms of CoAP messages.
If HTTP is used for a particular hop in the end-to-end path, then this section applies to the conceptual CoAP message that is mappable to/from the original HTTP message as discussed in Section 11.
That is, an HTTP message is conceptually transformed to a CoAP message and then to an OSCORE message, and similarly in the reverse direction.
An actual implementation might translate directly from HTTP to OSCORE without the intervening CoAP representation.
Protection of signaling messages (Section 5 of [RFC8323]) is specified in Section 4.3.
The other parts of this section target request/response messages.
Message fields of the CoAP message may be protected end-to-end between CoAP client and CoAP server in different ways: o Class E: encrypted and integrity protected, o Class I: integrity protected only, or o Class U: unprotected.
The sending endpoint SHALL transfer Class E message fields in the ciphertext of the COSE object in the OSCORE message.
The sending endpoint SHALL include Class I message fields in the AAD of the AEAD algorithm, allowing the receiving endpoint to detect if the value has changed in transfer.
Class U message fields SHALL NOT be protected in transfer.
Class I and Class U message field values are transferred in the header or options part of the OSCORE message, which is visible to proxies.
Message fields not visible to proxies, i.e., transported in the ciphertext of the COSE object, are called "Inner" (Class E).
Message fields transferred in the header or options part of the OSCORE message, which is visible to proxies, are called "Outer" (Class I or Class U).
There are currently no Class I options defined.
An OSCORE message may contain both an Inner and an Outer instance of a certain CoAP message field.
Inner message fields are intended for the receiving endpoint, whereas Outer message fields are used to enable proxy operations.
CoAP Options A summary of how options are protected is shown in Figure 5.
Note that some options may have both Inner and Outer message fields, which are protected accordingly.
Certain options require special processing as is described in Section 4.1.3.
Options that are unknown or for which OSCORE processing is not defined SHALL be processed as Class E (and no special processing).
Specifications of new CoAP options SHOULD define how they are processed with OSCORE.
A new COAP option SHOULD be of Class E unless it requires proxy processing.
If a new CoAP option is of class U, the potential issues with the option being unprotected SHOULD be documented (see Appendix D.5).
Inner Options Inner option message fields (Class E) are used to communicate directly with the other endpoint.
The sending endpoint SHALL write the Inner option message fields present in the original CoAP message into the plaintext of the COSE object (Section 5.3) and then remove the Inner option message fields from the OSCORE message.
The processing of Inner option message fields by the receiving endpoint is specified in Sections 8.2 and 8.4.
Outer Options Outer option message fields (Class U or I) are used to support proxy operations, see Appendix D.2.
The sending endpoint SHALL include the Outer option message field present in the original message in the options part of the OSCORE message.
All Outer option message fields, including the OSCORE option, SHALL be encoded as described in Section 3.1 of [RFC7252], where the delta is the difference from the previously included instance of Outer option message field.
The processing of Outer options by the receiving endpoint is specified in Sections 8.2 and 8.4.
A procedure for integrity-protection-only of Class I option message fields is specified in Section 5.4.
Specifications that introduce repeatable Class I options MUST specify that proxies MUST NOT change the order of the instances of such an option in the CoAP message.
Note: There are currently no Class I option message fields defined.
Special Options Some options require special processing as specified in this section.
Max-Age An Inner Max-Age message field is used to indicate the maximum time a response may be cached by the client (as defined in [RFC7252]), end-to-end from the server to the client, taking into account that the option is not accessible to proxies.
The Inner Max-Age SHALL be processed by OSCORE as a normal Inner option, specified in Section 4.1.1.
An Outer Max-Age message field is used to avoid unnecessary caching of error responses caused by OSCORE processing at OSCORE-unaware intermediary nodes.
A server MAY set a Class U Max-Age message field with value zero to such error responses, described in Sections 7.4, 8.2, and 8.4, since these error responses are cacheable, but subsequent OSCORE requests would never create a hit in the intermediary node caching it.
Setting the Outer Max-Age to zero relieves the intermediary from uselessly caching responses.
Successful OSCORE responses do not need to include an Outer Max-Age option.
Except when the Observe option (see Section 4.1.3.5) is used, responses appear to the OSCORE-unaware intermediary as 2.04 (Changed) responses, which are non-cacheable (see Section 4.2).
For Observe responses, which are cacheable, an Outer Max-Age option with value 0 may be used to avoid unnecessary proxy caching.
The Outer Max-Age message field is processed according to Section 4.1.2.
Uri-Host and Uri-Port When the Uri-Host and Uri-Port are set to their default values (see Section 5.10.1 [RFC7252]), they are omitted from the message (Section 5.4.4 of [RFC7252]), which is favorable both for overhead and privacy.
In order to support forward proxy operations, Proxy-Scheme, Uri-Host, and Uri-Port need to be Class U.
For the use of Proxy-Uri, see Section 4.1.3.3.
Manipulation of unprotected message fields (including Uri-Host, Uri-Port, destination IP/port or request scheme) MUST NOT lead to an OSCORE message becoming verified by an unintended server.
Different servers SHALL have different security contexts.
Proxy-Uri When Proxy-Uri is present, the client SHALL first decompose the Proxy-Uri value of the original CoAP message into the Proxy-Scheme, Uri-Host, Uri-Port, Uri-Path, and Uri-Query options according to Section 6.4 of [RFC7252].
Uri-Path and Uri-Query are Class E options and SHALL be protected and processed as Inner options (Section 4.1.1).
The Proxy-Uri option of the OSCORE message SHALL be set to the composition of Proxy-Scheme, Uri-Host, and Uri-Port options as specified in Section 6.5 of [RFC7252] and processed as an Outer option of Class U (Section 4.1.2).
Note that replacing the Proxy-Uri value with the Proxy-Scheme and Uri-* options works by design for all CoAP URIs (see Section 6 of [RFC7252]).
OSCORE-aware HTTP servers should not use the userinfo component of the HTTP URI (as defined in Section 3.2.1 of [RFC3986]), so that this type of replacement is possible in the presence of CoAP-to-HTTP proxies (see Section 11.2).
In future specifications of cross-protocol proxying behavior using different URI structures, it is expected that the authors will create Uri-* options that allow decomposing the Proxy-Uri, and specifying the OSCORE processing.
An example of how Proxy-Uri is processed is given here.
Assume that the original CoAP message contains: o Proxy-Uri = "coap://example.com/resource?q=1" During OSCORE processing, Proxy-Uri is split into: o Proxy-Scheme = "coap" o Uri-Host = "example.com" o Uri-Port = "5683" (default) o Uri-Path = "resource" o Uri-Query = "q=1" Uri-Path and Uri-Query follow the processing defined in Section 4.1.1; thus, they are encrypted and transported in the COSE object: o Uri-Path = "resource" o Uri-Query = "q=1" The remaining options are composed into the Proxy-Uri included in the options part of the OSCORE message, which has value: o Proxy-Uri = "coap://example.com" See Sections 6.1 and 12.6 of [RFC7252] for more details.
The Block Options Block-wise [RFC7959] is an optional feature.
An implementation MAY support CoAP [RFC7252] and the OSCORE option without supporting block-wise transfers.
The Block options (Block1, Block2, Size1, Size2), when Inner message fields, provide secure message segmentation such that each segment can be verified.
The Block options, when Outer message fields, enable hop-by-hop fragmentation of the OSCORE message.
Inner and Outer block processing may have different performance properties depending on the underlying transport.
The end-to-end integrity of the message can be verified both in case of Inner and Outer Block-wise transfers, provided all blocks are received.
Inner Block Options The sending CoAP endpoint MAY fragment a CoAP message as defined in [RFC7959] before the message is processed by OSCORE.
In this case, the Block options SHALL be processed by OSCORE as normal Inner options (Section 4.1.1).
The receiving CoAP endpoint SHALL process the OSCORE message before processing Block-wise as defined in [RFC7959].
Outer Block Options Proxies MAY fragment an OSCORE message using [RFC7959] by introducing Block option message fields that are Outer (Section 4.1.2).
Note that the Outer Block options are neither encrypted nor integrity protected.
As a consequence, a proxy can maliciously inject block fragments indefinitely, since the receiving endpoint needs to receive the last block (see [RFC7959]) to be able to compose the OSCORE message and verify its integrity.
Therefore, applications supporting OSCORE and [RFC7959] MUST specify a security policy defining a maximum unfragmented message size (MAX_UNFRAGMENTED_SIZE) considering the maximum size of message that can be handled by the endpoints.
Messages exceeding this size SHOULD be fragmented by the sending endpoint using Inner Block options (Section 4.1.3.4.1).
An endpoint receiving an OSCORE message with an Outer Block option SHALL first process this option according to [RFC7959], until all blocks of the OSCORE message have been received or the cumulated message size of the blocks exceeds MAX_UNFRAGMENTED_SIZE.
In the former case, the processing of the OSCORE message continues as defined in this document.
In the latter case, the message SHALL be discarded.
Because of encryption of Uri-Path and Uri-Query, messages to the same server may, from the point of view of a proxy, look like they also target the same resource.
A proxy SHOULD mitigate a potential mix-up of blocks from concurrent requests to the same server, for example, using the Request-Tag processing specified in Section 3.3.2 of [CoAP-ECHO-REQ-TAG].
Observe Observe [RFC7641] is an optional feature.
An implementation MAY support CoAP [RFC7252] and the OSCORE option without supporting [RFC7641], in which case the Observe-related processing can be omitted.
The support for Observe [RFC7641] with OSCORE targets the requirements on forwarding of Section 2.2.1 of [CoAP-E2E-Sec], i.e., that observations go through intermediary nodes, as illustrated in Figure 8 of [RFC7641]..
Inner Observe SHALL be used to protect the value of the Observe option between the endpoints.
Outer Observe SHALL be used to support forwarding by intermediary nodes.
The server SHALL include a new Partial IV (see Section 5) in responses (with or without the Observe option) to Observe registrations, except for the first response where Partial IV MAY be omitted.
For cancellations, Section 3.6 of [RFC7641] specifies that all options MUST be identical to those in the registration request except for the Observe option and the set of ETag options.
For OSCORE messages, this matching is to be done to the options in the decrypted message.
[RFC7252] does not specify how the server should act upon receiving the same Token in different requests.
When using OSCORE, the server SHOULD NOT remove an active observation just because it receives a request with the same Token.
Since POST with the Observe option is not defined, for messages with the Observe option, the Outer Code MUST be set to 0.05 (FETCH) for requests and to 2.05 (Content) for responses (see Section 4.2).
Registrations and Cancellations The Inner and Outer Observe options in the request MUST contain the Observe value of the original CoAP request; 0 (registration) or 1 (cancellation).
Every time a client issues a new request with the Observe option, a new Partial IV MUST be used (see Section 5), and so the payload and OSCORE option are changed.
The server uses the Partial IV of the new request as the 'request_piv' of all associated notifications (see Section 5.4).
Intermediaries are not assumed to have access to the OSCORE security context used by the endpoints; thus, they cannot make requests or transform responses with the OSCORE option that pass verification (at the receiving endpoint) as having come from the other endpoint.
This has the following consequences and limitations for Observe operations.
o An intermediary node removing the Outer Observe 0 option does not change the registration request to a request without the Observe option (see Section 2 of [RFC7641]).
Instead other means for cancellation may be used as described in Section 3.6 of [RFC7641].
o An intermediary node is not able to transform a normal response into an OSCORE-protected Observe notification (see Figure 7 of [RFC7641]) that verifies as coming from the server.
o An intermediary node is not able to initiate an OSCORE protected Observe registration (Observe option with value 0) that verifies as coming from the client.
An OSCORE-aware intermediary SHALL NOT initiate registrations of observations (see Section 10).
If an OSCORE-unaware proxy resends an old registration message from a client, the replay protection mechanism in the server will be triggered.
To prevent this from resulting in the OSCORE-unaware proxy canceling the registration, a server MAY respond to a replayed registration request with a replay of a cached notification.
Alternatively, the server MAY send a new notification.
o An intermediary node is not able to initiate an OSCORE-protected Observe cancellation (Observe option with value 1) that verifies as coming from the client.
An application MAY decide to allow intermediaries to cancel Observe registrations, e.g., to send the Observe option with value 1 (see Section 3.6 of [RFC7641]); however, that can also be done with other methods, e.g., by sending a RST message.
This is out of scope for this specification.
Notifications If the server accepts an Observe registration, a Partial IV MUST be included in all notifications (both successful and error), except for the first one where the Partial IV MAY be omitted.
To protect against replay, the client SHALL maintain a Notification Number for each Observation it registers.
The Notification Number is a non-negative integer containing the largest Partial IV of the received notifications for the associated Observe registration.
Further details of replay protection of notifications are specified in Section 7.4.1.
For notifications, the Inner Observe option value MUST be empty (see Section 3.2 of [RFC7252]).
The Outer Observe option in a notification is needed for intermediary nodes to allow multiple responses to one request, and it MAY be set to the value of the Observe option in the original CoAP message.
The client performs ordering of notifications and replay protection by comparing their Partial IVs and SHALL ignore the Outer Observe option value.
If the client receives a response to an Observe request without an Inner Observe option, then it verifies the response as a non-Observe response, as specified in Section 8.4.
If the client receives a response to a non-Observe request with an Inner Observe option, then it stops processing the message, as specified in Section 8.4.
A client MUST consider the notification with the highest Partial IV as the freshest, regardless of the order of arrival.
In order to support existing Observe implementations, the OSCORE client implementation MAY set the Observe option value to the three least significant bytes of the Partial IV.
Implementations need to make sure that the notification without Partial IV is considered the oldest.
No-Response No-Response [RFC7967] is an optional feature used by the client to communicate its disinterest in certain classes of responses to a particular request.
An implementation MAY support [RFC7252] and the OSCORE option without supporting [RFC7967].
If used, No-Response MUST be Inner.
The Inner No-Response SHALL be processed by OSCORE as specified in Section 4.1.1.
The Outer option SHOULD NOT be present.
The server SHALL ignore the Outer No-Response option.
The client MAY set the Outer No-Response value to 26 (suppress all known codes) if the Inner value is set to 26.
The client MUST be prepared to receive and discard 5.04 (Gateway Timeout) error messages from intermediaries potentially resulting from destination time out due to no response.
OSCORE The OSCORE option is only defined to be present in OSCORE messages as an indication that OSCORE processing has been performed.
The content in the OSCORE option is neither encrypted nor integrity protected as a whole, but some part of the content of this option is protected (see Section 5.4).
Nested use of OSCORE is not supported: If OSCORE processing detects an OSCORE option in the original CoAP message, then processing SHALL be stopped.
CoAP Header Fields and Payload A summary of how the CoAP header fields and payload are protected is shown in Figure 6, including fields specific to CoAP over UDP and CoAP over TCP (marked accordingly in the table).
Most CoAP header fields (i.e., the message fields in the fixed 4-byte header) are required to be read and/or changed by CoAP proxies; thus, they cannot, in general, be protected end-to-end from one endpoint to the other.
As mentioned in Section 1, OSCORE protects the CoAP request/response layer only and not the CoAP messaging layer (Section 2 of [RFC7252]), so fields such as Type and Message ID are not protected with OSCORE.
The CoAP header field Code is protected by OSCORE.
Code SHALL be encrypted and integrity protected (Class E) to prevent an intermediary from eavesdropping on or manipulating it (e.g., changing from GET to DELETE).
The sending endpoint SHALL write the Code of the original CoAP message into the plaintext of the COSE object (see Section 5.3).
After that, the sending endpoint writes an Outer Code to the OSCORE message.
With one exception (see Section 4.1.3.5), the Outer Code SHALL be set to 0.02 (POST) for requests and to 2.04 (Changed) for responses.
The receiving endpoint SHALL discard the Outer Code in the OSCORE message and write the Code of the COSE object plaintext (Section 5.3) into the decrypted CoAP message.
The other currently defined CoAP header fields are Unprotected (Class U).
The sending endpoint SHALL write all other header fields of the original message into the header of the OSCORE message.
The receiving endpoint SHALL write the header fields from the received OSCORE message into the header of the decrypted CoAP message.
The CoAP Payload, if present in the original CoAP message, SHALL be encrypted and integrity protected; thus, it is an Inner message field.
The sending endpoint writes the payload of the original CoAP message into the plaintext (Section 5.3) input to the COSE object.
The receiving endpoint verifies and decrypts the COSE object, and it recreates the payload of the original CoAP message.
Signaling Messages Signaling messages (CoAP Code 7.00-7.31) were introduced to exchange information related to an underlying transport connection in the specific case of CoAP over reliable transports [RFC8323].
OSCORE MAY be used to protect signaling if the endpoints for OSCORE coincide with the endpoints for the signaling message.
If OSCORE is used to protect signaling then: o To comply with [RFC8323], an initial empty Capabilities and Settings Message (CSM) SHALL be sent.
The subsequent signaling message SHALL be protected.
o Signaling messages SHALL be protected as CoAP request messages, except in the case in which the signaling message is a response to a previous signaling message; then it SHALL be protected as a CoAP response message.
For example, 7.02 (Ping) is protected as a CoAP request and 7.03 (Pong) as a CoAP response.
o The Outer Code for signaling messages SHALL be set to 0.02 (POST), unless it is a response to a previous signaling message, in which case it SHALL be set to 2.04 (Changed).
o All signaling options, except the OSCORE option, SHALL be Inner (Class E).
NOTE: Option numbers for signaling messages are specific to the CoAP Code (see Section 5.2 of [RFC8323]).
If OSCORE is not used to protect signaling, Signaling messages SHALL be unaltered by OSCORE.
The COSE Object This section defines how to use COSE [RFC8152] to wrap and protect data in the original message.
OSCORE uses the untagged COSE_Encrypt0 structure (see Section 5.2 of [RFC8152]) with an AEAD algorithm.
The AEAD key lengths, AEAD nonce length, and maximum Sender Sequence Number are algorithm dependent.
The AEAD algorithm AES-CCM-16-64-128 defined in Section 10.2 of [RFC8152] is mandatory to implement.
For AES-CCM-16-64-128, the length of Sender Key and Recipient Key is 128 bits; the length of AEAD nonce and Common IV is 13 bytes.
The maximum Sender Sequence Number is specified in Section 12.
As specified in [RFC5116], plaintext denotes the data that is to be encrypted and integrity protected, and Additional Authenticated Data (AAD) denotes the data that is to be integrity protected only.
The COSE object SHALL be a COSE_Encrypt0 object with fields defined as follows: o The 'protected' field is empty.
o The 'unprotected' field includes: * The 'Partial IV' parameter.
The value is set to the Sender Sequence Number.
All leading bytes of value zero SHALL be removed when encoding the Partial IV, except in the case of Partial IV value 0, which is encoded to the byte string 0x00.
This parameter SHALL be present in requests and will not typically be present in responses (for two exceptions, see Observe notifications (Section 4.1.3.5.2) and Replay Window synchronization (Appendix B.1.2)).
* The 'kid' parameter.
The value is set to the Sender ID.
This parameter SHALL be present in requests and will not typically be present in responses.
An example where the Sender ID is included in a response is the extension of OSCORE to group communication [Group-OSCORE].
* Optionally, a 'kid context' parameter (see Section 5.1).
This parameter MAY be present in requests and, if so, MUST contain an ID Context (see Section 3.1).
This parameter SHOULD NOT be present in responses: an example of how 'kid context' can be used in responses is given in Appendix B.2.
If 'kid context' is present in the request, then the server SHALL use a security context with that ID Context when verifying the request.
o The 'ciphertext' field is computed from the secret key (Sender Key or Recipient Key), AEAD nonce (see Section 5.2), plaintext (see Section 5.3), and the AAD (see Section 5.4) following Section 5.2 of [RFC8152].
The encryption process is described in Section 5.3 of [RFC8152].
ID Context and 'kid context' For certain use cases, e.g., deployments where the same Sender ID is used with multiple contexts, it is possible (and sometimes necessary, see Section 3.3) for the client to use an ID Context to distinguish the security contexts (see Section 3.1).
For example: o If the client has a unique identifier in some namespace, then that identifier can be used as ID Context.
o The ID Context may be used to add randomness into new Sender and Recipient Contexts, see Appendix B.2.
o In the case of group communication [Group-OSCORE], a group identifier is used as ID Context to enable different security contexts for a server belonging to multiple groups.
The Sender ID and ID Context are used to establish the necessary input parameters and in the derivation of the security context (see Section 3.2).
While the 'kid' parameter is used to transport the Sender ID, the new COSE header parameter 'kid context' is used to transport the ID Context in requests, see Figure 7.
If ID Context is non-empty and the client sends a request without 'kid context' resulting in an error indicating that the server could not find the security context, then the client could include the ID Context in the 'kid context' when making another request.
Note that since the error is unprotected, it may have been spoofed and the real response blocked by an on-path attacker.
AEAD Nonce The high-level design of the AEAD nonce follows Section 4.4 of [IV-GEN].
Note that in this specification, only AEAD algorithms that use nonces equal or greater than 7 bytes are supported.
The nonce construction with S, ID_PIV, and PIV together with endpoint-unique IDs and encryption keys makes it easy to verify that the nonces used with a specific key will be unique, see Appendix D.4.
If the Partial IV is not present in a response, the nonce from the request is used.
For responses that are not notifications (i.e., when there is a single response to a request), the request and the response should typically use the same nonce to reduce message overhead.
Both alternatives provide all the required security properties, see Section 7.4 and Appendix D.4.
Another non-Observe scenario where a Partial IV is included in a response is when the server is unable to perform replay protection, see Appendix B.1.2.
For processing instructions see Section 8.
The options are encoded as described in Section 3.1 of [RFC7252], where the delta is the difference from the previously included instance of Class E option; and o the Payload of original CoAP message, if present, and in that case prefixed by the one-byte Payload Marker (0xff).
NOTE: The plaintext contains all CoAP data that needs to be encrypted end-to-end between the endpoints.
Additional Authenticated Data The external_aad SHALL be a CBOR array wrapped in a bstr object as defined below, following the notation of [RFC8610] as summarized in Appendix E: external_aad = bstr .cbor aad_array aad_array = [ oscore_version : uint, algorithms : [ alg_aead : int / tstr ], request_kid : bstr, request_piv : bstr, options : bstr, ] where: o oscore_version: contains the OSCORE version number.
Implementations of this specification MUST set this field to 1.
Other values are reserved for future versions.
o algorithms: contains (for extensibility) an array of algorithms, according to this specification only containing alg_aead.
o alg_aead: contains the AEAD Algorithm from the security context used for the exchange (see Section 3.1).
o request_kid: contains the value of the 'kid' in the COSE object of the request (see Section 5).
o request_piv: contains the value of the 'Partial IV' in the COSE object of the request (see Section 5).
o options: contains the Class I options (see Section 4.1.2) present in the original CoAP message encoded as described in Section 3.1 of [RFC7252], where the delta is the difference from the previously included instance of class I option.
The oscore_version and algorithms parameters are established out-of-band; thus, they are not transported in OSCORE, but the external_aad allows to verify that they are the same in both endpoints.
NOTE: The format of the external_aad is, for simplicity, the same for requests and responses, although some parameters, e.g., request_kid, need not be integrity protected in all requests.
The AAD is composed from the external_aad as described in Section 5.3 of [RFC8152] (the notation follows [RFC8610] as summarized in Appendix E): AAD = Enc_structure = [ "Encrypt0", h'', external_aad ] The following is an example of AAD constructed using AEAD Algorithm = AES-CCM-16-64-128 (10), request_kid = 0x00, request_piv = 0x25 and no Class I options: o oscore_version: 0x01 (1 byte) o algorithms: 0x810a (2 bytes) o request_kid: 0x00 (1 byte) o request_piv: 0x25 (1 byte) o options: 0x (0 bytes) o aad_array: 0x8501810a4100412540 (9 bytes) o external_aad: 0x498501810a4100412540 (10 bytes) o AAD: 0x8368456e63727970743040498501810a4100412540 (21 bytes) Note that the AAD consists of a fixed string of 11 bytes concatenated with the external_aad.
OSCORE Header Compression The Concise Binary Object Representation (CBOR) [RFC7049] combines very small message sizes with extensibility.
The CBOR Object Signing and Encryption (COSE) [RFC8152] uses CBOR to create compact encoding of signed and encrypted data.
However, COSE is constructed to support a large number of different stateless use cases and is not fully optimized for use as a stateful security protocol, leading to a larger than necessary message expansion.
In this section, we define a stateless header compression mechanism, simply removing redundant information from the COSE objects, which significantly reduces the per-packet overhead.
The result of applying this mechanism to a COSE object is called the "compressed COSE object".
The COSE_Encrypt0 object used in OSCORE is transported in the OSCORE option and in the Payload.
The Payload contains the ciphertext of the COSE object.
The headers of the COSE object are compactly encoded as described in the next section.
o The first byte, containing the OSCORE flag bits, encodes the following set of bits and the length of the 'Partial IV' parameter: * The three least significant bits encode the Partial IV length n. If n = 0, then the Partial IV is not present in the compressed COSE object.
The values n = 6 and n = 7 are reserved.
* The fourth least significant bit is the 'kid' flag, k. It is set to 1 if 'kid' is present in the compressed COSE object.
* The fifth least significant bit is the 'kid context' flag, h. It is set to 1 if the compressed COSE object contains a 'kid context' (see Section 5.1).
* The sixth-to-eighth least significant bits are reserved for future use.
These bits SHALL be set to zero when not in use.
According to this specification, if any of these bits are set to 1, the message is considered to be malformed and decompression fails as specified in item 2 of Section 8.2.
The flag bits are registered in the "OSCORE Flag Bits" registry specified in Section 13.7. o The following n bytes encode the value of the Partial IV, if the Partial IV is present (n > 0).
o The following 1 byte encodes the length s of the 'kid context' (Section 5.1), if the 'kid context' flag is set (h = 1).
o The following s bytes encode the 'kid context', if the 'kid context' flag is set (h = 1).
o The remaining bytes encode the value of the 'kid', if the 'kid' is present (k = 1).
Note that the 'kid' MUST be the last field of the OSCORE option value, even in the case in which reserved bits are used and additional fields are added to it.
The length of the OSCORE option thus depends on the presence and length of Partial IV, 'kid context', 'kid', as specified in this section, and on the presence and length of additional parameters, as defined in the future documents registering those parameters.
Encoding of the OSCORE Payload The payload of the OSCORE message SHALL encode the ciphertext of the COSE object.
Examples of Compressed COSE Objects This section covers a list of OSCORE Header Compression examples for requests and responses.
The examples assume the COSE_Encrypt0 object is set (which means the CoAP message and cryptographic material is known).
Note that the full CoAP unprotected message, as well as the full security context, is not reported in the examples, but only the input necessary to the compression mechanism, i.e., the COSE_Encrypt0 object.
The output is the compressed COSE object as defined in Section 6, divided into two parts, since the object is transported in two CoAP fields: the OSCORE option and payload.
Request with ciphertext = 0xaea0155667924dff8a24e4cb35b9, kid = 0x25, and Partial IV = 0x05 Before compression (24 bytes): [ h'', { 4:h'25', 6:h'05' }, h'aea0155667924dff8a24e4cb35b9', ] After compression (17 bytes): Flag byte: 0b00001001 = 0x09 (1 byte) Option Value: 0x090525 (3 bytes) Payload: 0xaea0155667924dff8a24e4cb35b9 (14 bytes) 2.
Request with ciphertext = 0xaea0155667924dff8a24e4cb35b9, kid = empty string, and Partial IV = 0x00 Before compression (23 bytes): [ h'', { 4:h'', 6:h'00' }, h'aea0155667924dff8a24e4cb35b9', ] After compression (16 bytes): Flag byte: 0b00001001 = 0x09 (1 byte) Option Value: 0x0900 (2 bytes) Payload: 0xaea0155667924dff8a24e4cb35b9 (14 bytes) 3.
Request with ciphertext = 0xaea0155667924dff8a24e4cb35b9, kid = empty string, Partial IV = 0x05, and kid context = 0x44616c656b Before compression (30 bytes): [ h'', { 4:h'', 6:h'05', 10:h'44616c656b' }, h'aea0155667924dff8a24e4cb35b9', ] After compression (22 bytes): Flag byte: 0b00011001 = 0x19 (1 byte) Option Value: 0x19050544616c656b (8 bytes) Payload: 0xae a0155667924dff8a24e4cb35b9 (14 bytes) 4.
Response with ciphertext = 0xaea0155667924dff8a24e4cb35b9 and no Partial IV Before compression (18 bytes): [ h'', {}, h'aea0155667924dff8a24e4cb35b9', ] After compression (14 bytes): Flag byte: 0b00000000 = 0x00 (1 byte) Option Value: 0x (0 bytes) Payload: 0xaea0155667924dff8a24e4cb35b9 (14 bytes) 5.
Response with ciphertext = 0xaea0155667924dff8a24e4cb35b9 and Partial IV = 0x07 Before compression (21 bytes): [ h'', { 6:h'07' }, h'aea0155667924dff8a24e4cb35b9', ] After compression (16 bytes): Flag byte: 0b00000001 = 0x01 (1 byte) Option Value: 0x0107 (2 bytes) Payload: 0xaea0155667924dff8a24e4cb35b9 (14 bytes)7.
Message Binding, Sequence Numbers, Freshness, and Replay Protection7.1.
Message Binding In order to prevent response delay and mismatch attacks [CoAP-Actuators] from on-path attackers and compromised intermediaries, OSCORE binds responses to the requests by including the 'kid' and Partial IV of the request in the AAD of the response.
Therefore, the server needs to store the 'kid' and Partial IV of the request until all responses have been sent.
Sequence Numbers An AEAD nonce MUST NOT be used more than once per AEAD key.
The uniqueness of (key, nonce) pairs is shown in Appendix D.4, and in particular depends on a correct usage of Partial IVs (which encode the Sender Sequence Numbers, see Section 5).
If messages are processed concurrently, the operation of reading and increasing the Sender Sequence Number MUST be atomic.
Maximum Sequence Number The maximum Sender Sequence Number is algorithm dependent (see Section 12) and SHALL be less than 2^40.
If the Sender Sequence Number exceeds the maximum, the endpoint MUST NOT process any more messages with the given Sender Context.
If necessary, the endpoint SHOULD acquire a new security context before this happens.
The latter is out of scope of this document.
Freshness For requests, OSCORE provides only the guarantee that the request is not older than the security context.
For applications having stronger demands on request freshness (e.g., control of actuators), OSCORE needs to be augmented with mechanisms providing freshness (for example, as specified in [CoAP-ECHO-REQ-TAG]).
Assuming an honest server (see Appendix D), the message binding guarantees that a response is not older than its request.
For responses that are not notifications (i.e., when there is a single response to a request), this gives absolute freshness.
For notifications, the absolute freshness gets weaker with time, and it is RECOMMENDED that the client regularly re-register the observation.
Note that the message binding does not guarantee that a misbehaving server created the response before receiving the request, i.e., it does not verify server aliveness.
For requests and notifications, OSCORE also provides relative freshness in the sense that the received Partial IV allows a recipient to determine the relative order of requests or responses.
Replay Protection In order to protect from replay of requests, the server's Recipient Context includes a Replay Window.
A server SHALL verify that the Sender Sequence Number received in the 'Partial IV' parameter of the COSE object (see Section 6.1) has not been received before.
If this verification fails, the server SHALL stop processing the message, and it MAY optionally respond with a 4.01 (Unauthorized) error message.
Also, the server MAY set an Outer Max-Age option with value zero to inform any intermediary that the response is not to be cached.
The diagnostic payload MAY contain the string "Replay detected".
The size and type of the Replay Window depends on the use case and the protocol with which the OSCORE message is transported.
In case of reliable and ordered transport from endpoint to endpoint, e.g., TCP, the server MAY just store the last received Partial IV and require that newly received Partial IVs equal the last received Partial IV + 1.
However, in the case of mixed reliable and unreliable transports and where messages may be lost, such a replay mechanism may be too restrictive and the default replay window may be more suitable (see Section 3.2.2).
Responses (with or without Partial IV) are protected against replay as they are bound to the request and the fact that only a single response is accepted.
In this case the Partial IV is not used for replay protection of responses.
The operation of validating the Partial IV and updating the replay protection MUST be atomic.
Replay Protection of Notifications The following applies additionally when the Observe option is supported.
The Notification Number (see Section 4.1.3.5.2) is initialized to the Partial IV of the first successfully verified notification in response to the registration request.
A client MUST only accept at most one Observe notification without Partial IV, and treat it as the oldest notification received.
A client receiving a notification containing a Partial IV SHALL compare the Partial IV with the Notification Number associated to that Observe registration.
The client MUST stop processing notifications with a Partial IV that has been previously received.
Applications MAY decide that a client only processes notifications that have a greater Partial IV than the Notification Number.
If the verification of the response succeeds, and the received Partial IV was greater than the Notification Number, then the client SHALL overwrite the corresponding Notification Number with the received Partial IV.
Losing Part of the Context State To prevent reuse of an AEAD nonce with the same AEAD key or the acceptance of replayed messages, an endpoint needs to handle the situation of losing rapidly changing parts of the context, such as the Sender Sequence Number and Replay Window.
These are typically stored in RAM and therefore lost in the case of, e.g., an unplanned reboot.
There are different alternatives to recover, for example: 1.
The endpoints can reuse an existing Security Context after updating the mutable parts of the security context (Sender Sequence Number and Replay Window).
This requires that the mutable parts of the security context are available throughout the lifetime of the device or that the device can establish a fresh security context after loss of mutable security context data.
Examples are given based on careful use of nonvolatile memory, see Appendix B.1.1 and the use of the Echo option, see Appendix B.1.2.
If an endpoint makes use of a partial security context stored in nonvolatile memory, it MUST NOT reuse a previous Sender Sequence Number and MUST NOT accept previously received messages.
The endpoints can reuse an existing shared Master Secret and derive new Sender and Recipient Contexts, see Appendix B.2 for an example.
This typically requires a good source of randomness.
The endpoints can use a trusted third-party-assisted key establishment protocol such as [OSCORE-PROFILE].
This requires the execution of a three-party protocol and may require a good source of randomness.
The endpoints can run a key exchange protocol providing forward secrecy resulting in a fresh Master Secret, from which an entirely new Security Context is derived.
This requires a good source of randomness, and additionally, the transmission and processing of the protocol may have a non-negligible cost, e.g., in terms of power consumption.
The endpoints need to be configured with information about which method is used.
The choice of method may depend on capabilities of the devices deployed and the solution architecture.
Using a key exchange protocol is necessary for deployments that require forward secrecy.
Processing This section describes the OSCORE message processing.
Additional processing for Observe or Block-wise are described in subsections.
Note that, analogously to [RFC7252] where the Token and source/ destination pair are used to match a response with a request, both endpoints MUST keep the association (Token, {Security Context, Partial IV of the request}), in order to be able to find the Security Context and compute the AAD to protect or verify the response.
The association MAY be forgotten after it has been used to successfully protect or verify the response, with the exception of Observe processing, where the association MUST be kept as long as the Observation is active.
The processing of the Sender Sequence Number follows the procedure described in Section 3 of [IV-GEN].
Protecting the Request Given a CoAP request, the client SHALL perform the following steps to create an OSCORE request: 1.
Retrieve the Sender Context associated with the target resource.
Compose the AAD and the plaintext, as described in Sections 5.3 and 5.4.
Encode the Partial IV (Sender Sequence Number in network byte order) and increment the Sender Sequence Number by one.
Compute the AEAD nonce from the Sender ID, Common IV, and Partial IV as described in Section 5.2.
Encrypt the COSE object using the Sender Key.
Compress the COSE object as specified in Section 6.
Format the OSCORE message according to Section 4.
The OSCORE option is added (see Section 4.1.2).
Verifying the Request A server receiving a request containing the OSCORE option SHALL perform the following steps: 1.
Discard Code and all Class E options (marked in Figure 5 with 'x' in column E) present in the received message.
For example, an If-Match Outer option is discarded, but an Uri-Host Outer option is not discarded.
Decompress the COSE object (Section 6) and retrieve the Recipient Context associated with the Recipient ID in the 'kid' parameter, additionally using the 'kid context', if present.
Note that the Recipient Context MAY be retrieved by deriving a new security context, e.g.
as described in Appendix B.2.
If either the decompression or the COSE message fails to decode, or the server fails to retrieve a Recipient Context with Recipient ID corresponding to the 'kid' parameter received, then the server SHALL stop processing the request.
* If either the decompression or the COSE message fails to decode, the server MAY respond with a 4.02 (Bad Option) error message.
The server MAY set an Outer Max-Age option with value zero.
The diagnostic payload MAY contain the string "Failed to decode COSE".
* If the server fails to retrieve a Recipient Context with Recipient ID corresponding to the 'kid' parameter received, the server MAY respond with a 4.01 (Unauthorized) error message.
The server MAY set an Outer Max-Age option with value zero.
The diagnostic payload MAY contain the string "Security context not found".
Verify that the Partial IV has not been received before using the Replay Window, as described in Section 7.4.
Compose the AAD, as described in Section 5.4.
Compute the AEAD nonce from the Recipient ID, Common IV, and the Partial IV, received in the COSE object.
Decrypt the COSE object using the Recipient Key, as per Section 5.3 of [RFC8152].
(The decrypt operation includes the verification of the integrity.)
* If decryption fails, the server MUST stop processing the request and MAY respond with a 4.00 (Bad Request) error message.
The server MAY set an Outer Max-Age option with value zero.
The diagnostic payload MAY contain the string "Decryption failed".
* If decryption succeeds, update the Replay Window, as described in Section 7.
Add decrypted Code, options, and payload to the decrypted request.
The OSCORE option is removed.
The decrypted CoAP request is processed according to [RFC7252].
Supporting Block-wise If Block-wise is supported, insert the following step before any other: A.
If Block-wise is present in the request, then process the Outer Block options according to [RFC7959], until all blocks of the request have been received (see Section 4.1.3.4).
Protecting the Response If a CoAP response is generated in response to an OSCORE request, the server SHALL perform the following steps to create an OSCORE response.
Note that CoAP error responses derived from CoAP processing (step 8 in Section 8.2) are protected, as well as successful CoAP responses, while the OSCORE errors (steps 2, 3, and 6 in Section 8.2) do not follow the processing below but are sent as simple CoAP responses, without OSCORE processing.
Retrieve the Sender Context in the Security Context associated with the Token.
Compose the AAD and the plaintext, as described in Sections 5.3 and 5.4.
Compute the AEAD nonce as described in Section 5.2: * Either use the AEAD nonce from the request, or * Encode the Partial IV (Sender Sequence Number in network byte order) and increment the Sender Sequence Number by one.
Compute the AEAD nonce from the Sender ID, Common IV, and Partial IV.
Encrypt the COSE object using the Sender Key.
Compress the COSE object as specified in Section 6.
If the AEAD nonce was constructed from a new Partial IV, this Partial IV MUST be included in the message.
If the AEAD nonce from the request was used, the Partial IV MUST NOT be included in the message.
Format the OSCORE message according to Section 4.
The OSCORE option is added (see Section 4.1.2).
Supporting Observe If Observe is supported, insert the following step between steps 2 and 3 of Section 8.3: A.
If the response is an Observe notification: o If the response is the first notification: * compute the AEAD nonce as described in Section 5.2: + Either use the AEAD nonce from the request, or + Encode the Partial IV (Sender Sequence Number in network byte order) and increment the Sender Sequence Number by one.
Compute the AEAD nonce from the Sender ID, Common IV, and Partial IV.
Then, go to 4. o If the response is not the first notification: * encode the Partial IV (Sender Sequence Number in network byte order) and increment the Sender Sequence Number by one.
Compute the AEAD nonce from the Sender ID, Common IV, and Partial IV, then go to 4.
Verifying the Response A client receiving a response containing the OSCORE option SHALL perform the following steps: 1.
Discard Code and all Class E options (marked in Figure 5 with 'x' in column E) present in the received message.
For example, ETag Outer option is discarded, as well as Max-Age Outer option.
Retrieve the Recipient Context in the Security Context associated with the Token.
Decompress the COSE object (Section 6).
If either the decompression or the COSE message fails to decode, then go to 8.
Compose the AAD, as described in Section 5.4.
Compute the AEAD nonce * If the Partial IV is not present in the response, the AEAD nonce from the request is used.
* If the Partial IV is present in the response, compute the AEAD nonce from the Recipient ID, Common IV, and the Partial IV, received in the COSE object.
Decrypt the COSE object using the Recipient Key, as per Section 5.3 of [RFC8152].
(The decrypt operation includes the verification of the integrity.)
If decryption fails, then go to 8.
Add decrypted Code, options and payload to the decrypted request.
The OSCORE option is removed.
The decrypted CoAP response is processed according to [RFC7252].
In case any of the previous erroneous conditions apply: the client SHALL stop processing the response.
Supporting Block-wise If Block-wise is supported, insert the following step before any other: A.
If Block-wise is present in the response, then process the Outer Block options according to [RFC7959], until all blocks of the response have been received (see Section 4.1.3.4).
Supporting Observe If Observe is supported: Insert the following step between step 5 and step 6: A.
If the request was an Observe registration, then: o If the Partial IV is not present in the response, and the Inner Observe option is present, and the AEAD nonce from the request was already used once, then go to 8. o If the Partial IV is present in the response and the Inner Observe option is present, then follow the processing described in Section 4.1.3.5.2 and Section 7.4.1, then: * initialize the Notification Number (if first successfully verified notification), or * overwrite the Notification Number (if the received Partial IV was greater than the Notification Number).
Replace step 8 of Section 8.4 with: B.
In case any of the previous erroneous conditions apply: the client SHALL stop processing the response.
An error condition occurring while processing a response to an observation request does not cancel the observation.
A client MUST NOT react to failure by re-registering the observation immediately.
Web Linking The use of OSCORE MAY be indicated by a target "osc" attribute in a web link [RFC8288] to a resource, e.g., using a link-format document [RFC6690] if the resource is accessible over CoAP.
The "osc" attribute is a hint indicating that the destination of that link is only accessible using OSCORE, and unprotected access to it is not supported.
Note that this is simply a hint, it does not include any security context material or any other information required to run OSCORE.
A value MUST NOT be given for the "osc" attribute; any present value MUST be ignored by parsers.
The "osc" attribute MUST NOT appear more than once in a given link-value; occurrences after the first MUST be ignored by parsers.
The link-format notation (see Section 5 of [RFC6690]) is used.
CoAP-to-CoAP Forwarding Proxy CoAP is designed for proxy operations (see Section 5.7 of [RFC7252]).
OSCORE is designed to work with OSCORE-unaware CoAP proxies.
Security requirements for forwarding are listed in Section 2.2.1 of [CoAP-E2E-Sec].
Proxy processing of the (Outer) Proxy-Uri option works as defined in [RFC7252].
Proxy processing of the (Outer) Block options works as defined in [RFC7959].
However, not all CoAP proxy operations are useful: o Since a CoAP response is only applicable to the original CoAP request, caching is in general not useful.
In support of existing proxies, OSCORE uses the Outer Max-Age option, see Section 4.1.3.1. o Proxy processing of the (Outer) Observe option as defined in [RFC7641] is specified in Section 4.1.3.5.
Optionally, a CoAP proxy MAY detect OSCORE and act accordingly.
An OSCORE-aware CoAP proxy: o SHALL bypass caching for the request if the OSCORE option is present.
o SHOULD avoid caching responses to requests with an OSCORE option.
In the case of Observe (see Section 4.1.3.5), the OSCORE-aware CoAP proxy: o SHALL NOT initiate an Observe registration.
o MAY verify the order of notifications using Partial IV rather than the Observe option.
HTTP Operations The CoAP request/response model may be mapped to HTTP and vice versa as described in Section 10 of [RFC7252].
The HTTP-CoAP mapping is further detailed in [RFC8075].
This section defines the components needed to map and transport OSCORE messages over HTTP hops.
By mapping between HTTP and CoAP and by using cross-protocol proxies, OSCORE may be used end-to-end between, e.g., an HTTP client and a CoAP server.
Examples are provided in Sections 11.5 and 11.6.
The HTTP OSCORE Header Field The HTTP OSCORE header field (see Section 13.4) is used for carrying the content of the CoAP OSCORE option when transporting OSCORE messages over HTTP hops.
The HTTP OSCORE header field is only used in POST requests and responses with HTTP Status Code 200 (OK).
When used, the HTTP header field Content-Type is set to 'application/oscore' (see Section 13.5) indicating that the HTTP body of this message contains the OSCORE payload (see Section 6.2).
No additional semantics are provided by other message fields.
Using the Augmented Backus-Naur Form (ABNF) notation of [RFC5234], including the following core ABNF syntax rules defined by that specification: ALPHA (letters) and DIGIT (decimal digits), the HTTP OSCORE header field value is as follows.
base64url-char = ALPHA / DIGIT / "-" / "_" OSCORE = 2*base64url-char The HTTP OSCORE header field is not appropriate to list in the Connection header field (see Section 6.1 of [RFC7230]) since it is not hop-by-hop.
OSCORE messages are generally not useful when served from cache (i.e., they will generally be marked Cache-Control: no-cache) and so interaction with Vary is not relevant (Section 7.1.4 of [RFC7231]).
Since the HTTP OSCORE header field is critical for message processing, moving it from headers to trailers renders the message unusable in case trailers are ignored (see Section 4.1 of [RFC7230]).
In general, intermediaries are not allowed to insert, delete, or modify the OSCORE header.
In general, changes to the HTTP OSCORE header field will violate the integrity of the OSCORE message resulting in an error.
For the same reason the HTTP OSCORE header field is generally not preserved across redirects.
Since redirects are not defined in the mappings between HTTP and CoAP ([RFC8075] [RFC7252]), a number of conditions need to be fulfilled for redirects to work.
For CoAP-client-to-HTTP-server redirects, such conditions include: o the CoAP-to-HTTP proxy follows the redirect, instead of the CoAP client as in the HTTP case.
o the CoAP-to-HTTP proxy copies the HTTP OSCORE header field and body to the new request.
o the target of the redirect has the necessary OSCORE security context required to decrypt and verify the message.
Since OSCORE requires the HTTP body to be preserved across redirects, the HTTP server is RECOMMENDED to reply with 307 (Temporary Redirect) or 308 (Permanent Redirect) instead of 301 (Moved Permanently) or 302 (Found).
For the case of HTTP-client-to-CoAP-server redirects, although redirect is not defined for CoAP servers [RFC7252], an HTTP client receiving a redirect should generate a new OSCORE request for the server it was redirected to.
CoAP-to-HTTP Mapping Section 10.1 of [RFC7252] describes the fundamentals of the CoAP-to-HTTP cross-protocol mapping process.
The additional rules for OSCORE messages are as follows: o The HTTP OSCORE header field value is set to: * AA if the CoAP OSCORE option is empty; otherwise, * the value of the CoAP OSCORE option (Section 6.1) in base64url (Section 5 of [RFC4648]) encoding without padding.
Implementation notes for this encoding are given in Appendix C of [RFC7515].
o The HTTP Content-Type is set to 'application/oscore' (see Section 13.5), independent of CoAP Content-Format.
HTTP-to-CoAP Mapping Section 10.2 of [RFC7252] and [RFC8075] specify the behavior of an HTTP-to-CoAP proxy.
The additional rules for HTTP messages with the OSCORE header field are as follows.
o The CoAP OSCORE option is set as follows: * empty if the value of the HTTP OSCORE header field is a single zero byte (0x00) represented by AA; otherwise, * the value of the HTTP OSCORE header field decoded from base64url (Section 5 of [RFC4648]) without padding.
Implementation notes for this encoding are given in Appendix C of [RFC7515].
o The CoAP Content-Format option is omitted, the content format for OSCORE (Section 13.6) MUST NOT be used.
HTTP Endpoints Restricted to subsets of HTTP and CoAP supporting a bijective mapping, OSCORE can be originated or terminated in HTTP endpoints.
The sending HTTP endpoint uses [RFC8075] to translate the HTTP message into a CoAP message.
The CoAP message is then processed with OSCORE as defined in this document.
The OSCORE message is then mapped to HTTP as described in Section 11.2 and sent in compliance with the rules in Section 11.1.
The receiving HTTP endpoint maps the HTTP message to a CoAP message using [RFC8075] and Section 11.3.
The resulting OSCORE message is processed as defined in this document.
If successful, the plaintext CoAP message is translated to HTTP for normal processing in the endpoint.
Example: HTTP Client and CoAP Server This section gives an example of what a request and a response between an HTTP client and a CoAP server could look like.
The example is not a test vector but intended as an illustration of how the message fields are translated in the different steps.
Mapping and notation here is based on "Simple Form" (Section 5.4.1 of [RFC8075]).
[HTTP request --Before client object security processing] GET http://proxy.url/hc/?target_uri=coap://server.url/orders HTTP/1.1 [HTTP request --HTTP Client to Proxy] POST http://proxy.url/hc/?target_uri=coap://server.url/ HTTP/1.1 Content-Type: application/oscore OSCORE: CSU Body: 09 07 01 13 61 f7 0f d2 97 b1 [binary] [CoAP request --Proxy to CoAP Server] POST coap://server.url/ OSCORE: 09 25 Payload: 09 07 01 13 61 f7 0f d2 97 b1 [binary] [CoAP request --After server object security processing] GET coap://server.url/orders [CoAP response --Before server object security processing] 2.05 Content Content-Format: 0 Payload: Exterminate!
Exterminate!
[CoAP response --CoAP Server to Proxy] 2.04 Changed OSCORE: [empty] Payload: 00 31 d1 fc f6 70 fb 0c 1d d5 ... [binary] [HTTP response --Proxy to HTTP Client] HTTP/1.1 200 OK Content-Type: application/oscore OSCORE: AA Body: 00 31 d1 fc f6 70 fb 0c 1d d5 ... [binary] [HTTP response --After client object security processing] HTTP/1.1 200 OK Content-Type: text/plain Body: Exterminate!
Exterminate!
Note that the HTTP Status Code 200 (OK) in the next-to-last message is the mapping of CoAP Code 2.04 (Changed), whereas the HTTP Status Code 200 (OK) in the last message is the mapping of the CoAP Code 2.05 (Content), which was encrypted within the compressed COSE object carried in the Body of the HTTP response.
Example: CoAP Client and HTTP Server This section gives an example of what a request and a response between a CoAP client and an HTTP server could look like.
The example is not a test vector but intended as an illustration of how the message fields are translated in the different steps.
[CoAP request --Before client object security processing] GET coap://proxy.url/ Proxy-Uri=http://server.url/orders [CoAP request --CoAP Client to Proxy] POST coap://proxy.url/ Proxy-Uri=http://server.url/ OSCORE: 09 25 Payload: 09 07 01 13 61 f7 0f d2 97 b1 [binary] [HTTP request --Proxy to HTTP Server] POST http://server.url/ HTTP/1.1 Content-Type: application/oscore OSCORE: CSU Body: 09 07 01 13 61 f7 0f d2 97 b1 [binary] [HTTP request --After server object security processing] GET http://server.url/orders HTTP/1.1 [HTTP response --Before server object security processing] HTTP/1.1 200 OK Content-Type: text/plain Body: Exterminate!
Exterminate!
[HTTP response --HTTP Server to Proxy] HTTP/1.1 200 OK Content-Type: application/oscore OSCORE: AA Body: 00 31 d1 fc f6 70 fb 0c 1d d5 ... [binary] [CoAP response --Proxy to CoAP Client] 2.04 Changed OSCORE: [empty] Payload: 00 31 d1 fc f6 70 fb 0c 1d d5 ... [binary] [CoAP response --After client object security processing] 2.05 Content Content-Format: 0 Payload: Exterminate!
Exterminate!
Note that the HTTP Code 2.04 (Changed) in the next-to-last message is the mapping of HTTP Status Code 200 (OK), whereas the CoAP Code 2.05 (Content) in the last message is the value that was encrypted within the compressed COSE object carried in the Body of the HTTP response.
Security Considerations An overview of the security properties is given in Appendix D.12.1.
End-to-end Protection In scenarios with intermediary nodes such as proxies or gateways, transport layer security such as (D)TLS only protects data hop-by-hop.
As a consequence, the intermediary nodes can read and modify any information.
The trust model where all intermediary nodes are considered trustworthy is problematic, not only from a privacy perspective, but also from a security perspective, as the intermediaries are free to delete resources on sensors and falsify commands to actuators (such as "unlock door", "start fire alarm", "raise bridge").
Even in the rare cases where all the owners of the intermediary nodes are fully trusted, attacks and data breaches make such an architecture brittle.
(D)TLS protects hop-by-hop the entire message.
OSCORE protects end-to-end all information that is not required for proxy operations (see Section 4).
(D)TLS and OSCORE can be combined, thereby enabling end-to-end security of the message payload, in combination with hop-by-hop protection of the entire message, during transport between endpoint and intermediary node.
In particular, when OSCORE is used with HTTP, the additional TLS protection of HTTP hops is RECOMMENDED, e.g., between an HTTP endpoint and a proxy translating between HTTP and CoAP.
Applications need to consider that certain message fields and messages types are not protected end-to-end and may be spoofed or manipulated.
The consequences of unprotected message fields are analyzed in Appendix D.5.
Security Context Establishment The use of COSE_Encrypt0 and AEAD to protect messages as specified in this document requires an established security context.
The method to establish the security context described in Section 3.2 is based on a common Master Secret and unique Sender IDs.
The necessary input parameters may be preestablished or obtained using a key establishment protocol augmented with establishment of Sender/ Recipient ID, such as a key exchange protocol or the OSCORE profile of the Authentication and Authorization for Constrained Environments (ACE) framework [OSCORE-PROFILE].
Such a procedure must ensure that the requirements of the security context parameters for the intended use are complied with (see Section 3.3) even in error situations.
While recipient IDs are allowed to coincide between different security contexts (see Section 3.3), this may cause a server to process multiple verifications before finding the right security context or rejecting a message.
Considerations for deploying OSCORE with a fixed Master Secret are given in Appendix B.
Master Secret OSCORE uses HKDF [RFC5869] and the established input parameters to derive the security context.
The required properties of the security context parameters are discussed in Section 3.3; in this section, we focus on the Master Secret.
In this specification, HKDF denotes the composition of the expand and extract functions as defined in [RFC5869] and the Master Secret is used as Input Keying Material (IKM).
Informally, HKDF takes as source an IKM containing some good amount of randomness but not necessarily distributed uniformly (or for which an attacker has some partial knowledge) and derive from it one or more cryptographically strong secret keys [RFC5869].
Therefore, the main requirement for the OSCORE Master Secret, in addition to being secret, is that it have a good amount of randomness.
The selected key establishment schemes must ensure that the necessary properties for the Master Secret are fulfilled.
For pre-shared key deployments and key transport solutions such as [OSCORE-PROFILE], the Master Secret can be generated offline using a good random number generator.
Randomness requirements for security are described in [RFC4086].
Replay Protection Replay attacks need to be considered in different parts of the implementation.
Most AEAD algorithms require a unique nonce for each message, for which the Sender Sequence Numbers in the COSE message field 'Partial IV' is used.
If the recipient accepts any sequence number larger than the one previously received, then the problem of sequence number synchronization is avoided.
With reliable transport, it may be defined that only messages with sequence numbers that are equal to the previous sequence number + 1 are accepted.
An adversary may try to induce a device reboot for the purpose of replaying a message (see Section 7.5).
Note that sharing a security context between servers may open up for replay attacks, for example, if the Replay Windows are not synchronized.
Client Aliveness A verified OSCORE request enables the server to verify the identity of the entity who generated the message.
However, it does not verify that the client is currently involved in the communication, since the message may be a delayed delivery of a previously generated request, which now reaches the server.
To verify the aliveness of the client the server may use the Echo option in the response to a request from the client (see [CoAP-ECHO-REQ-TAG]).
Cryptographic Considerations The maximum Sender Sequence Number is dependent on the AEAD algorithm.
The maximum Sender Sequence Number is 2^40 -1, or any algorithm-specific lower limit, after which a new security context must be generated.
The mechanism to build the AEAD nonce (Section 5.2) assumes that the nonce is at least 56 bits, and the Partial IV is at most 40 bits.
The mandatory-to-implement AEAD algorithm AES-CCM-16-64-128 is selected for compatibility with CCM*.
AEAD algorithms that require unpredictable nonces are not supported.
In order to prevent cryptanalysis when the same plaintext is repeatedly encrypted by many different users with distinct AEAD keys, the AEAD nonce is formed by mixing the sequence number with a secret per-context initialization vector (Common IV) derived along with the keys (see Section 3.1 of [RFC8152]), and by using a Master Salt in the key derivation (see [MF00] for an overview).
The Master Secret, Sender Key, Recipient Key, and Common IV must be secret, the rest of the parameters may be public.
The Master Secret must have a good amount of randomness (see Section 12.3).
The ID Context, Sender ID, and Partial IV are always at least implicitly integrity protected, as manipulation leads to the wrong nonce or key being used and therefore results in decryption failure.
Message Segmentation The Inner Block options enable the sender to split large messages into OSCORE-protected blocks such that the receiving endpoint can verify blocks before having received the complete message.
The Outer Block options allow for arbitrary proxy fragmentation operations that cannot be verified by the endpoints but that can, by policy, be restricted in size since the Inner Block options allow for secure fragmentation of very large messages.
A maximum message size (above which the sending endpoint fragments the message and the receiving endpoint discards the message, if complying to the policy) may be obtained as part of normal resource discovery.
Privacy Considerations Privacy threats executed through intermediary nodes are considerably reduced by means of OSCORE.
End-to-end integrity protection and encryption of the message payload and all options that are not used for proxy operations provide mitigation against attacks on sensor and actuator communication, which may have a direct impact on the personal sphere.
The unprotected options (Figure 5) may reveal privacy-sensitive information, see Appendix D.5.
CoAP headers sent in plaintext allow, for example, matching of CON and ACK (CoAP Message Identifier), matching of request and responses (Token) and traffic analysis.
OSCORE does not provide protection for HTTP header fields that are not both CoAP-mappable and Class E. The HTTP message fields that are visible to on-path entities are only used for the purpose of transporting the OSCORE message, whereas the application-layer message is encoded in CoAP and encrypted.
COSE message fields, i.e., the OSCORE option, may reveal information about the communicating endpoints.
For example, 'kid' and 'kid context', which are intended to help the server find the right context, may reveal information about the client.
Tracking 'kid' and 'kid context' to one server may be used for correlating requests from one client.
Unprotected error messages reveal information about the security state in the communication between the endpoints.
Unprotected signaling messages reveal information about the reliable transport used on a leg of the path.
Using the mechanisms described in Section 7.5 may reveal when a device goes through a reboot.
This can be mitigated by the device storing the precise state of Sender Sequence Number and Replay Window on a clean shutdown.
The length of message fields can reveal information about the message.
Applications may use a padding scheme to protect against traffic analysis.
IANA Considerations13.1.
COSE Header Parameters Registry The 'kid context' parameter has been added to the "COSE Header Parameters" registry: o Name: kid context o Label: 10 o Value Type: bstr o Value Registry: o Description: Identifies the context for the key identifier o Reference: Section 5.1 of this document13.2.
Media Type Registration This section registers the 'application/oscore' media type in the "Media Types" registry.
This media type is used to indicate that the content is an OSCORE message.
The OSCORE body cannot be understood without the OSCORE header field value and the security context.
Type name: application Subtype name: oscore Required parameters: N/A Optional parameters: N/A Encoding considerations: binary Security considerations: See the Security Considerations section of [RFC8613].
Interoperability considerations: N/A Published specification: [RFC8613] Applications that use this media type: IoT applications sending security content over HTTP(S) transports.
Fragment identifier considerations: N/A Additional information: * Deprecated alias names for this type: N/A * Magic number(s): N/A * File extension(s): N/A * Macintosh file type code(s): N/A Person & email address to contact for further information: IESG <iesg@ietf.org> Intended usage: COMMON Restrictions on usage: N/A Author: Goeran Selander <goran.selander@ericsson.com> Change Controller: IESG Provisional registration?
No13.6.
CoAP Content-Formats Registry This section registers the media type 'application/oscore' media type in the "CoAP Content-Formats" registry.
This Content-Format for the OSCORE payload is defined for potential future use cases and SHALL NOT be used in the OSCORE message.
The OSCORE payload cannot be understood without the OSCORE option value and the security context.
OSCORE Flag Bits Registry This document defines a subregistry for the OSCORE flag bits within the "CoRE Parameters" registry.
The name of the subregistry is "OSCORE Flag Bits".
The registry has been created with the Expert Review policy [RFC8126].
Guidelines for the experts are provided in Section 13.8.
The columns of the registry are as follows: o Bit Position: This indicates the position of the bit in the set of OSCORE flag bits, starting at 0 for the most significant bit.
The bit position must be an integer or a range of integers, in the range 0 to 63. o Name: The name is present to make it easier to refer to and discuss the registration entry.
The value is not used in the protocol.
Names are to be unique in the table.
o Description: This contains a brief description of the use of the bit.
o Reference: This contains a pointer to the specification defining the entry.
The initial contents of the registry are in the table below.
The reference column for all rows is this document.
The entries with Bit Position of 0 and 1 are marked as 'Reserved'.
The entry with Bit Position of 1 will be specified in a future document and will be used to expand the space for the OSCORE flag bits in Section 6.1, so that entries 8-63 of the registry are defined.
Expert Review Instructions The expert reviewers for the registry defined in this document are expected to ensure that the usage solves a valid use case that could not be solved better in a different way, that it is not going to duplicate one that is already registered, and that the registered point is likely to be used in deployments.
They are furthermore expected to check the clarity of purpose and use of the requested code points.
Experts should take into account the expected usage of entries when approving point assignment, and the length of the encoded value should be weighed against the number of code points left that encode to that size and the size of device it will be used on.
Experts should block registration for entries 8-63 until these points are defined (i.e., until the mechanism for the OSCORE flag bits expansion via bit 1 is specified).

Introduction The Constrained Application Protocol (CoAP) [RFC7252] is a RESTful application-layer protocol for constrained environments [RFC7228].
In CoAP, clients (or intermediaries in the client role) make requests to servers (or intermediaries in the server role), which satisfy the requests by returning responses.
While a request is ongoing, a client typically needs to keep some state that it requires for processing the response when that arrives.
In some scenarios, it can be beneficial to reduce the amount of state that is stored at the client at the cost of increased message sizes.
A client can opt into this by serializing (parts of) its state into the token itself and then recovering this state from the token in the response (Figure 2).
Section 3 of this document provides considerations for clients becoming "stateless" in this way.
(The term "stateless" is in quotes here, because it's a bit oversimplified.
Such clients still need to maintain per-server state and other kinds of state.
So it would be more accurate to just say that the clients are avoiding per-request state.)
Section 4 of this document extends the considerations for clients to intermediaries, which may want to avoid keeping state for not only the requests they send to servers but also the requests they receive from clients.
The serialization of state into tokens is limited by the fact that both CoAP over UDP [RFC7252] and CoAP over reliable transports [RFC8323] restrict the maximum token length to 8 bytes.
To overcome this limitation, Section 2 of this document introduces a CoAP protocol extension for extended token lengths.
While the use case (avoiding per-request state) and the mechanism (extended token lengths) presented in this document are closely related, each can be used independently of the other.
Some implementations may be able to fit their state in just 8 bytes; some implementations may have other use cases for extended token lengths.
Terminology In this document, the term "stateless" refers to an implementation strategy for a client (or intermediary in the client role) that does not require it to keep state for the individual requests it sends to a server (or intermediary in the server role).
The client still needs to keep state for each server it communicates with (e.g., for token generation, message retransmission, and congestion control).
The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT", "SHOULD", "SHOULD NOT", "RECOMMENDED", "NOT RECOMMENDED", "MAY", and "OPTIONAL" in this document are to be interpreted as described in BCP 14 [RFC2119] [RFC8174] when, and only when, they appear in all capitals, as shown here.
Extended Tokens This document updates the message formats defined for CoAP over UDP [RFC7252] and CoAP over TCP, TLS, and WebSockets [RFC8323] with a new definition of the "TKL" field.
Extended Token Length (TKL) Field The definition of the "TKL" field is updated as follows: Token Length (TKL): 4-bit unsigned integer.
A value between 0 and 12, inclusive, indicates the length of the variable-length "Token" field in bytes.
The other three values are reserved for special constructs: 13: An 8-bit unsigned integer directly precedes the "Token" field and indicates the length of the "Token" field minus 13.
14: A 16-bit unsigned integer in network byte order directly precedes the "Token" field and indicates the length of the "Token" field minus 269.
15: Reserved.
This value MUST NOT be sent and MUST be processed as a message-format error.
All other fields retain their definitions.
The updated message formats are illustrated in Appendix A.
The new definition of the "TKL" field increases the maximum token length that can be represented in a message to 65804 bytes.
However, the maximum token length that sender and recipient implementations support may be shorter.
For example, a constrained node of Class 1 [RFC7228] might support extended token lengths only up to 32 bytes.
In CoAP over UDP, it is often beneficial to keep CoAP messages small enough to avoid IP fragmentation.
The maximum practical token length may therefore also be influenced by the Path MTU (PMTU).
See Section 4.6 of [RFC7252] for details.
Discovering Support Extended token lengths require support from server implementations.
Support can be discovered by a client implementation in one of two ways: * Where Capabilities and Settings Messages (CSMs) are available, such as in CoAP over TCP, support can be discovered using the Extended-Token-Length Capability Option defined in Section 2.2.1.
* Otherwise, such as in CoAP over UDP, support can only be discovered by trial and error, as described in Section 2.2.2.
Extended-Token-Length Capability Option A server can use the elective Extended-Token-Length Capability Option to indicate the maximum token length it can accept in requests.
C=Critical, R=Repeatable As per Section 3 of [RFC7252], the base value (and the value used when this option is not implemented) is 8.
The active value of the Extended-Token-Length Option is replaced each time the option is sent with a modified value.
Its starting value is its base value.
The option value MUST NOT be less than 8 or greater than 65804.
If an option value less than 8 is received, the option MUST be ignored.
If an option value greater than 65804 is received, the option value MUST be set to 65804.
Any option value greater than 8 implies support for the new definition of the "TKL" field specified in Section 2.1.
Indication of support by a server does not oblige a client to actually make use of token lengths greater than 8.
If a server receives a request with a token of a length greater than what it indicated in its Extended-Token-Length Option, it MUST handle the request as a message-format error.
If a server receives a request with a token of a length less than, or equal to, what it indicated in its Extended-Token-Length Option but is unwilling or unable to handle the token at that time, it MUST NOT handle the request as a message-format error.
Instead, it SHOULD return a 5.03 (Service Unavailable) response.
The Extended-Token-Length Capability Option does not apply to responses.
The sender of a request is simply expected not to use a token of a length greater than it is willing to accept in a response.
Trial and Error A server implementation that does not support the updated definition of the "TKL" field specified in Section 2.1 will consider a request with a "TKL" field value outside the range 0 to 8 to be a message-format error and reject it (Section 3 of [RFC7252]).
A client can therefore determine support by sending a request with an extended token length and checking whether or not it is rejected by the server.
In CoAP over UDP, the way a request message is rejected depends on the message type.
A Confirmable message with a message-format error is rejected with a Reset message (Section 4.2 of [RFC7252]).
A Non-confirmable message with a message-format error is either rejected with a Reset message or just silently ignored (Section 4.3 of [RFC7252]).
To reliably get a Reset message, it is therefore REQUIRED that clients use a Confirmable message for determining support.
As per RFC 7252, Reset messages are empty and do not contain a token; they only return the Message ID (Figure 3).
They also do not contain any indication of what caused a message-format error.
To avoid any ambiguity, it is therefore RECOMMENDED that clients use a request that has no potential message-format error other than the extended token length.
Rejected with a Reset Message If the Server Does Not Have Support An example of a suitable request is a GET request in a Confirmable message that includes only an If-None-Match option and a token of the greatest length that the client intends to use.
Any response with the same token echoed back indicates that tokens up to that length are supported by the server.
Since network addresses may change, a client SHOULD NOT assume that extended token lengths are supported by a server for an unlimited duration.
Unless additional information is available, the client should assume that addresses (and therefore extended token lengths) are valid for a minimum of 1800 s and a maximum of 86400 s (1 day).
A client may use additional forms of input into this determination.
For instance, a client may assume a server that is in the same subnet as the client has a similar address lifetime as the client.
The client may use DHCP lease times or Router Advertisements to set the limits.
For servers that are not local, if the server was looked up using DNS, then the DNS resource record will have a Time To Live (TTL), and the extended token length should be kept for only that amount of time.
If a server supports extended token lengths but receives a request with a token of a length it is unwilling or unable to handle, it MUST NOT reject the message, as that would imply that extended token lengths are not supported at all.
Instead, if the server cannot handle the request at the time, it SHOULD return a 5.03 (Service Unavailable) response; if the server will never be able to handle the request (e.g., because the token is too large), it SHOULD return a 4.00 (Bad Request) response.
| Design Note: The requirement to return an error response when a | token cannot be handled might seem somewhat contradictory, as | returning the error response requires the server also to return | the token it cannot handle.
However, processing a request | usually involves a number of steps from receiving the message | to passing it to application logic.
The idea is that a server | implementing this extension supports large tokens at least in | its first few processing steps, enough to return an error | response rather than a Reset message.
| Design Note: To prevent the trial-and-error-based discovery | from becoming too complicated, no effort is made to indicate | the maximum supported token length.
A client implementation | would probably already choose the shortest token possible for | the task (such as being stateless, as described in Section 3), | so it would probably not be able to reduce the length any | further anyway should a server indicate a lower limit.
Intermediaries Tokens are a hop-by-hop feature: if there are one or more intermediaries between a client and a server, every token is scoped to the exchange between a node in the client role and the node in the server role that it is immediately interacting with.
When an intermediary receives a request, the only requirement is that it echoes the token back in any resulting response.
There is no requirement or expectation that an intermediary passes a client's token on to a server or that an intermediary uses extended token lengths itself in its request to satisfy a request with an extended token length.
Discovery needs to be performed for each hop where extended token lengths are to be used.
Stateless Clients A client can be alleviated of keeping per-request state as follows: 1.
The client serializes (parts of) its per-request state into a sequence of bytes and sends those bytes as the token of its request to the server.
The server returns the token verbatim in the response to the client, which allows the client to recover the state and process the response as if it had kept the state locally.
As servers are just expected to return any token verbatim to the client, this implementation strategy for clients does not impact the interoperability of client and server implementations.
However, there are a number of significant, nonobvious implications (e.g., related to security and other CoAP protocol features) that client implementations need take into consideration.
The following subsections discuss some of these considerations.
Serializing Client State The format of the serialized state is generally an implementation detail of the client and opaque to the server.
However, serialized state information is an attractive target for both unwanted nodes (e.g., on-path attackers) and wanted nodes (e.g., any configured forward proxy) on the path.
The serialization format therefore needs to include security measures such as the following: * A client SHOULD protect the integrity of the state information serialized in a token.
* Even when the integrity of the serialized state is protected, an attacker may still replay a response, making the client believe it sent the same request twice.
For this reason, the client SHOULD implement replay protection (e.g., by using sequence numbers and a replay window).
For replay protection, integrity protection is REQUIRED.
* If processing a response without keeping request state is sensitive to the time elapsed since sending the request, then the client SHOULD include freshness information (e.g., a timestamp) in the serialized state and reject any response where the freshness information is insufficiently fresh.
* Information in the serialized state may be privacy sensitive.
A client SHOULD encrypt the serialized state if it contains privacy-sensitive information that an attacker would not get otherwise.
* When a client changes the format of the serialized state, it SHOULD prevent false interoperability with the previous format (e.g., by changing the key used for integrity protection or changing a field in the serialized state).
Using Extended Tokens A client that depends on support for extended token lengths (Section 2) from the server to avoid keeping request state needs to perform a discovery of support (Section 2.2) before it can be stateless.
This discovery MUST be performed in a stateful way, i.e., keeping state for the request (Figure 4).
If the client was stateless from the start, and the server does not support extended tokens, then no error message could be processed, since the state would neither be present at the client nor returned in the Reset message (Figure 5).
In environments where support can be reliably discovered through some other means, the discovery of support is OPTIONAL.
An example for this is the Constrained Join Protocol (CoJP) in a 6TiSCH network [6TISCH-MIN-SEC], where support for extended tokens is required from all relevant parties.
Transmitting Messages In CoAP over UDP [RFC7252], a client has the choice between Confirmable and Non-confirmable messages for requests.
When using Non-confirmable messages, a client does not have to keep any message-exchange state, which can help in the goal of avoiding state.
When using Confirmable messages, a client needs to keep message-exchange state for performing retransmissions and handling Acknowledgement and Reset messages, however.
Non-confirmable messages are therefore better suited for avoiding state.
In any case, a client still needs to keep congestion-control state, i.e., maintain state for each node it communicates with and enforce limits like NSTART.
As per Section 5.2 of [RFC7252], a client must be prepared to receive a response as a piggybacked response, a separate response, or a Non-confirmable response, regardless of the message type used for the request.
A stateless client MUST handle these response types as follows: * If a piggybacked response passes the checks for token integrity and freshness (Section 3.1), the client processes the message as specified in RFC 7252; otherwise, it processes the acknowledgement portion of the message as specified in RFC 7252 and silently discards the response portion.
* If a separate response passes the checks for token integrity and freshness, the client processes the message as specified in RFC 7252; otherwise, it rejects the message as specified in Section 4.2 of [RFC7252].
* If a Non-confirmable response passes the checks for token integrity and freshness, the client processes the message as specified in RFC 7252; otherwise, it rejects the message as specified in Section 4.3 of [RFC7252].
Stateless Intermediaries Tokens are a hop-by-hop feature.
If a client makes a request to an intermediary, that intermediary needs to store the client's token (along with the client's transport address) while it makes its own request towards the origin server and waits for the response.
When the intermediary receives the response, it looks up the client's token and transport address for the received request and sends an appropriate response to the client.
An intermediary might want to be "stateless" not only in its role as a client but also in its role as a server, i.e., be alleviated of storing the client information for the requests it receives.
Such an intermediary can be implemented by serializing the client information along with the request state into the token towards the origin server.
When the intermediary receives the response, it can recover the client information from the token and use it to satisfy the client's request; therefore, the intermediary doesn't need to store the information itself.
The following subsections discuss some considerations for this approach.
Observing Resources One drawback of the approach is that an intermediary, without keeping request state, is unable to aggregate multiple requests for the same target resource, which can significantly reduce efficiency.
In particular, when clients observe [RFC7641] the same resource, aggregating requests is REQUIRED (Section 3.1 of [RFC7641]).
This requirement cannot be satisfied without keeping request state.
Furthermore, an intermediary that does not keep track of the clients observing a resource is not able to determine whether these clients are still interested in receiving further notifications (Section 3.5 of [RFC7641]) or want to cancel an observation (Section 3.6 of [RFC7641]).
Therefore, an intermediary MUST NOT include an Observe Option in requests it sends without keeping both the request state for the requests it sends and the client information for the requests it receives.
Block-Wise Transfers When using block-wise transfers [RFC7959], a server might not be able to distinguish blocks originating from different clients once they have been forwarded by an intermediary.
Intermediaries need to ensure that this does not lead to inconsistent resource state by keeping distinct block-wise request operations on the same resource apart, e.g., utilizing the Request-Tag Option [ECHO-REQUEST-TAG].
Gateway Timeouts As per Section 5.7.1 of [RFC7252], an intermediary is REQUIRED to return a 5.04 (Gateway Timeout) response if it cannot obtain a response within a timeout.
However, if an intermediary does not keep the client information for the requests it receives, it cannot return such a response.
Therefore, in this case, the gateway cannot return such a response and as such cannot implement such a timeout.
Extended Tokens A client may make use of extended token lengths in a request to an intermediary that wants to be "stateless".
This means that such an intermediary may have to serialize potentially very large client information into its token towards the origin server.
The tokens can grow even further when it progresses along a chain of intermediaries that all want to be "stateless".
Intermediaries SHOULD limit the size of client information they are serializing into their own tokens.
An intermediary can do this, for example, by limiting the extended token lengths it accepts from its clients (see Section 2.2) or by keeping the client information locally when the client information exceeds the limit (i.e., not being "stateless").
Security Considerations5.1.
Extended Tokens Tokens significantly larger than the 8 bytes specified in RFC 7252 have implications --in particular, for nodes with constrained memory size --that need to be mitigated.
A node in the server role supporting extended token lengths may be vulnerable to a denial of service when an attacker (either on-path or a malicious client) sends large tokens to fill up the memory of the node.
Implementations need to be prepared to handle such messages.
Stateless Clients and Intermediaries Transporting the state needed by a client to process a response as serialized state information in the token has several significant and nonobvious security and privacy implications that need to be mitigated; see Section 3.1 for recommendations.
In addition to the format requirements outlined there, implementations need to ensure that they are not vulnerable to maliciously crafted, delayed, or replayed tokens.
It is generally expected that the use of encryption, integrity protection, and replay protection for serialized state is appropriate.
In the absence of integrity and replay protection, an on-path attacker or rogue server/intermediary could return a state (either one modified in a reply, or an unsolicited one) that could alter the internal state of the client.
It is for this reason that at least the use of integrity protection on the token is always recommended.
It may be that in some very specific cases, as a result of a careful and detailed analysis of any potential attacks, it is decided that such cryptographic protections do not add value.
The authors of this document have not found such a use case as yet, but this is a local decision.
It should further be emphasized that the encrypted state is created by the sending node and decrypted by the same node when receiving a response.
The key is not shared with any other system.
Therefore, the choice of encryption scheme and the generation of the key for this system is purely a local matter.
When encryption is used, the use of AES-CCM [RFC3610] with a 64-bit tag is recommended, combined with a sequence number and a replay window.
This choice is informed by available hardware acceleration of on many constrained systems.
If a different algorithm is available accelerated on the sender, with similar or stronger strength, then it SHOULD be preferred.
Where privacy of the state is not required, and encryption is not needed, HMAC-SHA-256 [RFC6234], combined with a sequence number and a replay window, may be used.
This size of the replay window depends upon the number of requests that need to be outstanding.
This can be determined from the rate at which new ones are made and the expected time period during which responses are expected.
For instance, given a CoAP MAX_TRANSMIT_WAIT of 93 s (Section 4.8.2 of [RFC7252]), any request that is not answered within 93 s will be considered to have failed.
At a request rate of one request per 10 s, at most 10 (ceil(9.3)) requests can be outstanding at a time, and any convenient replay window larger than 20 will work.
As replay windows are often implemented with a sliding window and a bit, the use of a 32-bit window would be sufficient.
For use cases where requests are being relayed from another node, the request rate may be estimated by the total link capacity allocated for that kind of traffic.
An alternate view would consider how many IPv6 Neighbor Cache Entries (NCEs) the system can afford to allocate for this use.
When using an encryption mode that depends on a nonce, such as AES-CCM, repeated use of the same nonce under the same key causes the cipher to fail catastrophically.
If a nonce is ever used for more than one encryption operation with the same key, then the same key stream gets used to encrypt both plaintexts, and the confidentiality guarantees are voided.
Devices with low-quality entropy sources --as is typical with constrained devices, which incidentally happen to be a natural candidate for the stateless mechanism described in this document --need to carefully pick a nonce-generation mechanism that provides the above uniqueness guarantee.
[RFC8613], Appendix B.1.1 ("Sender Sequence Number") provides a model for how to maintain nonrepeating nonces without causing excessive wear of flash memory.
IANA Considerations6.1.
CoAP Signaling Option Number The following entry has been added to the "CoAP Signaling Option Numbers" registry within the "CoRE Parameters" registry.

Introduction 1.0 Intellectual property rights policy This specification is provided under the Non-Assertion Mode of the OASIS IPR Policy, the mode chosen when the Technical Committee was established.
For information on whether any patents have been disclosed that may be essential to implementing this specification, and any offers of patent licensing terms, please refer to the Intellectual Property Rights section of the TCâs web page (https://www.oasis- open.org/committees/mqtt/ipr.php).
1.1 Organization of the MQTT specification The specification is split into seven chapters: â¢ Chapter 1 - Introduction â¢ Chapter 2 - MQTT Control Packet format â¢ Chapter 3 - MQTT Control Packets â¢ Chapter 4 - Operational behavior â¢ Chapter 5 - Security â¢ Chapter 6 - Using WebSocket as a network transport â¢ Chapter 7 - Conformance Targets 1.2 Terminology The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT", "SHOULD", "SHOULD NOT", "RECOMMENDED", "MAY", and "OPTIONAL" in this specification are to be interpreted as described in IETF RFC 2119 [RFC2119], except where they appear in text that is marked as non- normative.
Network Connection: A construct provided by the underlying transport protocol that is being used by MQTT.
â¢ It connects the Client to the Server.
â¢ It provides the means to send an ordered, lossless, stream of bytes in both directions.
Refer to section 4.2 Network Connection for non-normative examples.
Application Message: The data carried by the MQTT protocol across the network for the application.
When an Application Message is transported by MQTT it contains payload data, a Quality of Service (QoS), a collection of Properties, and a Topic Name.
Client: A program or device that uses MQTT.
A Client: â¢ opens the Network Connection to the Server â¢ publishes Application Messages that other Clients might be interested in.
â¢ subscribes to request Application Messages that it is interested in receiving.
â¢ unsubscribes to remove a request for Application Messages.
â¢ closes the Network Connection to the Server.
Server: A program or device that acts as an intermediary between Clients which publish Application Messages and Clients which have made Subscriptions.
A Server: â¢ accepts Network Connections from Clients.
â¢ accepts Application Messages published by Clients.
â¢ processes Subscribe and Unsubscribe requests from Clients.
â¢ forwards Application Messages that match Client Subscriptions.
â¢ closes the Network Connection from the Client.
Session: A stateful interaction between a Client and a Server.
Some Sessions last only as long as the Network Connection, others can span multiple consecutive Network Connections between a Client and a Server.
Subscription: A Subscription comprises a Topic Filter and a maximum QoS.
A Subscription is associated with a single Session.
A Session can contain more than one Subscription.
Each Subscription within a Session has a different Topic Filter.
Shared Subscription: A Shared Subscription comprises a Topic Filter and a maximum QoS.
A Shared Subscription can be associated with more than one Session to allow a wider range of message exchange patterns.
An Application Message that matches a Shared Subscription is only sent to the Client associated with one of these Sessions.
A Session can subscribe to more than one Shared Subscription and can contain both Shared Subscriptions and Subscriptions which are not shared.
Wildcard Subscription: A Wildcard Subscription is a Subscription with a Topic Filter containing one or more wildcard characters.
This allows the subscription to match more than one Topic Name.
Refer to section 4.7 for a description of wildcard characters in a Topic Filter.
Topic Name: The label attached to an Application Message which is matched against the Subscriptions known to the Server.
Topic Filter: An expression contained in a Subscription to indicate an interest in one or more topics.
A Topic Filter can include wildcard characters.
MQTT Control Packet: A packet of information that is sent across the Network Connection.
The MQTT specification defines fifteen different types of MQTT Control Packet, for example the PUBLISH packet is used to convey Application Messages.
Malformed Packet: A control packet that cannot be parsed according to this specification.
Refer to section 4.13 for information about error handling.
Protocol Error: An error that is detected after the packet has been parsed and found to contain data that is not allowed by the protocol or is inconsistent with the state of the Client or Server.
Refer to section 4.13 for information about error handling.
Will Message: An Application Message which is published by the Server after the Network Connection is closed in cases where the Network Connection is not closed normally.
Refer to section 3.1.2.5 for information about Will Messages.
Disallowed Unicode code point: The set of Unicode Control Codes and Unicode Noncharacters which should not be included in a UTF-8 Encoded String.
Refer to section 1.5.4 for more information about the Disallowed Unicode code points.
Bit number 7 is the most significant bit, the least significant bit is assigned bit number 0.
1.5.2 Two Byte Integer Two Byte Integer data values are 16-bit unsigned integers in big-endian order: the high order byte precedes the lower order byte.
This means that a 16-bit word is presented on the network as Most Significant Byte (MSB), followed by Least Significant Byte (LSB).
1.5.3 Four Byte Integer Four Byte Integer data values are 32-bit unsigned integers in big-endian order: the high order byte precedes the successively lower order bytes.
This means that a 32-bit word is presented on the network as Most Significant Byte (MSB), followed by the next most Significant Byte (MSB), followed by the next most Significant Byte (MSB), followed by Least Significant Byte (LSB).
1.5.4 UTF-8 Encoded String Text fields within the MQTT Control Packets described later are encoded as UTF-8 strings.
UTF-8 [RFC3629] is an efficient encoding of Unicode [Unicode] characters that optimizes the encoding of ASCII characters in support of text-based communications.
Consequently, the maximum size of a UTF-8 Encoded String is 65,535 bytes.
Unless stated otherwise all UTF-8 encoded strings can have any length in the range 0 to 65,535 bytes.
UTF-8 encoded character data, if length > 0.
The character data in a UTF-8 Encoded String MUST be well-formed UTF-8 as defined by the Unicode specification [Unicode] and restated in RFC 3629 [RFC3629].
In particular, the character data MUST NOT include encodings of code points between U+D800 and U+DFFF [MQTT-1.5.4-1].
If the Client or Server receives an MQTT Control Packet containing ill-formed UTF-8 it is a Malformed Packet.
Refer to section 4.13 for information about handling errors.
A UTF-8 Encoded String MUST NOT include an encoding of the null character U+0000.
[MQTT-1.5.4-2].
If a receiver (Server or Client) receives an MQTT Control Packet containing U+0000 it is a Malformed Packet.
Refer to section 4.13 for information about handling errors.
The data SHOULD NOT include encodings of the Unicode [Unicode] code points listed below.
If a receiver (Server or Client) receives an MQTT Control Packet containing any of them it MAY treat it as a Malformed Packet.
These are the Disallowed Unicode code points.
Refer to section 5.4.9 for more information about handling Disallowed Unicode code points.
â¢ U+0001..U+001F control characters â¢ U+007F..U+009F control characters â¢ Code points defined in the Unicode specification [Unicode] to be non-characters (for example U+0FFFF) A UTF-8 encoded sequence 0xEF 0xBB 0xBF is always interpreted as U+FEFF ("ZERO WIDTH NO- BREAK SPACE") wherever it appears in a string and MUST NOT be skipped over or stripped off by a packet receiver [MQTT-1.5.4-3].
Larger values are handled as follows.
The least significant seven bits of each byte encode the data, and the most significant bit is used to indicate whether there are bytes following in the representation.
Thus, each byte encodes 128 values and a "continuation bit".
The maximum number of bytes in the Variable Byte Integer field is four.
The encoded value MUST use the minimum number of bytes necessary to represent the value [MQTT-1.5.5-1].
This is shown in Table 1-1 Size of Variable Byte Integer.
Table 1-1 Size of Variable Byte Integer Digits From To 0 (0x00) 127 (0x7F) 128 (0x80, 0x01) 16,383 (0xFF, 0x7F) 16,384 (0x80, 0x80, 0x01) 2,097,151 (0xFF, 0xFF, 0x7F) 2,097,152 (0x80, 0x80, 0x80, 0x01) 268,435,455 (0xFF, 0xFF, 0xFF, 0x7F) Non-normative comment The algorithm for encoding a non-negative integer (X) into the Variable Byte Integer encoding scheme is as follows: do encodedByte = X MOD 128 X = X DIV 128 // if there are more data to encode, set the top bit of this byte if (X > 0) encodedByte = encodedByte OR 128 endif 'output' encodedByte while (X > 0) Where MOD is the modulo operator (% in C), DIV is integer division (/ in C), and OR is bit-wise or (| in C).
Non-normative comment The algorithm for decoding a Variable Byte Integer type is as follows: multiplier = 1 value = 0 do encodedByte = 'next byte from stream' value += (encodedByte AND 127) * multiplier if (multiplier > 128*128*128) throw Error(Malformed Variable Byte Integer) multiplier *= 128 while ((encodedByte AND 128) != 0) where AND is the bit-wise and operator (& in C).
When this algorithm terminates, value contains the Variable Byte Integer value.
1.5.6 Binary Data Binary Data is represented by a Two Byte Integer length which indicates the number of data bytes, followed by that number of bytes.
Thus, the length of Binary Data is limited to the range of 0 to 65,535 Bytes.
1.5.7 UTF-8 String Pair A UTF-8 String Pair consists of two UTF-8 Encoded Strings.
This data type is used to hold name-value pairs.
The first string serves as the name, and the second string contains the value.
Both strings MUST comply with the requirements for UTF-8 Encoded Strings [MQTT-1.5.7-1].
If a receiver (Client or Server) receives a string pair which does not meet these requirements it is a Malformed Packet.
Refer to section 4.13 for information about handling errors.
1.6 Security MQTT Client and Server implementations SHOULD offer Authentication, Authorization and secure communication options, such as those discussed in Chapter 5.
Applications concerned with critical infrastructure, personally identifiable information, or other personal or sensitive information are strongly advised to use these security capabilities.
1.7 Editing convention Text highlighted in Yellow within this specification identifies conformance statements.
Each conformance statement has been assigned a reference in the format [MQTT-x.x.x-y] where x.x.x is the section number and y is a statement counter within the section.
1.8 Change history 1.8.1 MQTT v3.1.1 MQTT v3.1.1 was the first OASIS standard version of MQTT [MQTTV311].
MQTT v3.1.1 is also standardized as ISO/IEC 20922:2016 [ISO20922].
1.8.2 MQTT v5.0 MQTT v5.0 adds a significant number of new features to MQTT while keeping much of the core in place.
The major functional objectives are: â¢ Enhancements for scalability and large scale systems â¢ Improved error reporting â¢ Formalize common patterns including capability discovery and request response â¢ Extensibility mechanisms including user properties â¢ Performance improvements and support for small clients Refer to Appendix C for a summary of changes in MQTT v5.0.
MQTT Control Packet format 2.1 Structure of an MQTT Control Packet The MQTT protocol operates by exchanging a series of MQTT Control Packets in a defined way.
This section describes the format of these packets.
An MQTT Control Packet consists of up to three parts, always in the following order as shown below.
Represented as a 4-bit unsigned value, the values are shown below.
Table 2-1 MQTT Control Packet types Name Value Direction of flow Description Reserved 0 Forbidden Reserved CONNECT 1 Client to Server Connection request CONNACK 2 Server to Client Connect acknowledgment PUBLISH 3 Client to Server or Publish message Server to Client PUBACK 4 Client to Server or Publish acknowledgment (QoS 1) Server to Client PUBREC 5 Client to Server or Publish received (QoS 2 delivery part 1) Server to Client PUBREL 6 Client to Server or Publish release (QoS 2 delivery part 2) Server to Client PUBCOMP 7 Client to Server or Publish complete (QoS 2 delivery part 3) Server to Client SUBSCRIBE 8 Client to Server Subscribe request SUBACK 9 Server to Client Subscribe acknowledgment UNSUBSCRIBE 10 Client to Server Unsubscribe request UNSUBACK 11 Server to Client Unsubscribe acknowledgment PINGREQ 12 Client to Server PING request PINGRESP 13 Server to Client PING response DISCONNECT 14 Client to Server or Disconnect notification Server to Client AUTH 15 Client to Server or Authentication exchange Server to Client 2.1.3 Flags The remaining bits [3-0] of byte 1 in the Fixed Header contain flags specific to each MQTT Control Packet type as shown below.
Where a flag bit is marked as âReservedâ, it is reserved for future use and MUST be set to the value listed [MQTT-2.1.3-1].
If invalid flags are received it is a Malformed Packet.
Refer to section 4.13 for details about handling errors.
Table 2-2 Flag Bits MQTT Control Fixed Header flags Bit 3 Bit 2 Bit 1 Bit 0 Packet CONNECT Reserved 0 0 0 0 CONNACK Reserved 0 0 0 0 PUBLISH Used in MQTT v5.0 DUP QoS RETAIN PUBACK Reserved 0 0 0 0 PUBREC Reserved 0 0 0 0 PUBREL Reserved 0 0 1 0 PUBCOMP Reserved 0 0 0 0 SUBSCRIBE Reserved 0 0 1 0 SUBACK Reserved 0 0 0 0 UNSUBSCRIBE Reserved 0 0 1 0 UNSUBACK Reserved 0 0 0 0 PINGREQ Reserved 0 0 0 0 PINGRESP Reserved 0 0 0 0 DISCONNECT Reserved 0 0 0 0 AUTH Reserved 0 0 0 0 DUP = Duplicate delivery of a PUBLISH packet QoS = PUBLISH Quality of Service RETAIN = PUBLISH retained message flag Refer to section 3.3.1 for a description of the DUP, QoS, and RETAIN flags in the PUBLISH packet.
2.1.4 Remaining Length Position: starts at byte 2.
The Remaining Length is a Variable Byte Integer that represents the number of bytes remaining within the current Control Packet, including data in the Variable Header and the Payload.
The Remaining Length does not include the bytes used to encode the Remaining Length.
The packet size is the total number of bytes in an MQTT Control Packet, this is equal to the length of the Fixed Header plus the Remaining Length.
2.2 Variable Header Some types of MQTT Control Packet contain a Variable Header component.
It resides between the Fixed Header and the Payload.
The content of the Variable Header varies depending on the packet type.
The Packet Identifier field of Variable Header is common in several packet types.
2.2.1 Packet Identifier The Variable Header component of many of the MQTT Control Packet types includes a Two Byte Integer Packet Identifier field.
These MQTT Control Packets are PUBLISH (where QoS > 0), PUBACK, PUBREC, PUBREL, PUBCOMP, SUBSCRIBE, SUBACK, UNSUBSCRIBE, UNSUBACK.
MQTT Control Packets that require a Packet Identifier are shown below: Table 2-3 MQTT Control Packets that contain a Packet Identifier MQTT Control Packet Identifier field Packet CONNECT NO CONNACK NO PUBLISH YES (If QoS > 0) PUBACK YES PUBREC YES PUBREL YES PUBCOMP YES SUBSCRIBE YES SUBACK YES UNSUBSCRIBE YES UNSUBACK YES PINGREQ NO PINGRESP NO DISCONNECT NO AUTH NO A PUBLISH packet MUST NOT contain a Packet Identifier if its QoS value is set to 0 [MQTT-2.2.1-2].
Each time a Client sends a new SUBSCRIBE, UNSUBSCRIBE,or PUBLISH (where QoS > 0) MQTT Control Packet it MUST assign it a non-zero Packet Identifier that is currently unused [MQTT-2.2.1-3].
Each time a Server sends a new PUBLISH (with QoS > 0) MQTT Control Packet it MUST assign it a non zero Packet Identifier that is currently unused [MQTT-2.2.1-4].
The Packet Identifier becomes available for reuse after the sender has processed the corresponding acknowledgement packet, defined as follows.
In the case of a QoS 1 PUBLISH, this is the corresponding PUBACK; in the case of QoS 2 PUBLISH it is PUBCOMP or a PUBREC with a Reason Code of 128 or greater.
For SUBSCRIBE or UNSUBSCRIBE it is the corresponding SUBACK or UNSUBACK.
Packet Identifiers used with PUBLISH, SUBSCRIBE and UNSUBSCRIBE packets form a single, unified set of identifiers separately for the Client and the Server in a Session.
A Packet Identifier cannot be used by more than one command at any time.
A PUBACK, PUBREC , PUBREL, or PUBCOMP packet MUST contain the same Packet Identifier as the PUBLISH packet that was originally sent [MQTT-2.2.1-5].
A SUBACK and UNSUBACK MUST contain the Packet Identifier that was used in the corresponding SUBSCRIBE and UNSUBSCRIBE packet respectively [MQTT-2.2.1-6].
The Client and Server assign Packet Identifiers independently of each other.
As a result, Client-Server pairs can participate in concurrent message exchanges using the same Packet Identifiers.
Non-normative comment It is possible for a Client to send a PUBLISH packet with Packet Identifier 0x1234 and then receive a different PUBLISH packet with Packet Identifier 0x1234 from its Server before it receives a PUBACK for the PUBLISH packet that it sent.
Client Server PUBLISH Packet Identifier=0x1234 ââ ââ PUBLISH Packet Identifier=0x1234 PUBACK Packet Identifier=0x1234 ââ ââ PUBACK Packet Identifier=0x1234 2.2.2 Properties The last field in the Variable Header of the CONNECT, CONNACK, PUBLISH, PUBACK, PUBREC, PUBREL, PUBCOMP, SUBSCRIBE, SUBACK, UNSUBSCRIBE, UNSUBACK, DISCONNECT, and AUTH packet is a set of Properties.
In the CONNECT packet there is also an optional set of Properties in the Will Properties field with the Payload.
The set of Properties is composed of a Property Length followed by the Properties.
2.2.2.1 Property Length The Property Length is encoded as a Variable Byte Integer.
The Property Length does not include the bytes used to encode itself, but includes the length of the Properties.
If there are no properties, this MUST be indicated by including a Property Length of zero [MQTT-2.2.2-1].
2.2.2.2 Property A Property consists of an Identifier which defines its usage and data type, followed by a value.
The Identifier is encoded as a Variable Byte Integer.
A Control Packet which contains an Identifier which is not valid for its packet type, or contains a value not of the specified data type, is a Malformed Packet.
If received, use a CONNACK or DISCONNECT packet with Reason Code 0x81 (Malformed Packet) as described in section 4.13 Handling errors.
There is no significance in the order of Properties with different Identifiers.
Table 2-4 - Properties Identifier Name (usage) Type Packet / Will Properties Dec Hex 0x01 Payload Format Indicator Byte PUBLISH, Will Properties 0x02 Message Expiry Interval Four Byte Integer PUBLISH, Will Properties 0x03 Content Type UTF-8 Encoded String PUBLISH, Will Properties 0x08 Response Topic UTF-8 Encoded String PUBLISH, Will Properties 0x09 Correlation Data Binary Data PUBLISH, Will Properties 0x0B Subscription Identifier Variable Byte Integer PUBLISH, SUBSCRIBE 0x11 Session Expiry Interval Four Byte Integer CONNECT, CONNACK, DISCONNECT 0x12 Assigned Client Identifier UTF-8 Encoded String CONNACK 0x13 Server Keep Alive Two Byte Integer CONNACK 0x15 Authentication Method UTF-8 Encoded String CONNECT, CONNACK, AUTH 0x16 Authentication Data Binary Data CONNECT, CONNACK, AUTH 0x17 Request Problem Information Byte CONNECT 0x18 Will Delay Interval Four Byte Integer Will Properties 0x19 Request Response Byte CONNECT Information 0x1A Response Information UTF-8 Encoded String CONNACK 0x1C Server Reference UTF-8 Encoded String CONNACK, DISCONNECT 0x1F Reason String UTF-8 Encoded String CONNACK, PUBACK, PUBREC, PUBREL, PUBCOMP, SUBACK, UNSUBACK, DISCONNECT, AUTH 0x21 Receive Maximum Two Byte Integer CONNECT, CONNACK 0x22 Topic Alias Maximum Two Byte Integer CONNECT, CONNACK 0x23 Topic Alias Two Byte Integer PUBLISH 0x24 Maximum QoS Byte CONNACK 0x25 Retain Available Byte CONNACK 0x26 User Property UTF-8 String Pair CONNECT, CONNACK, PUBLISH, Will Properties, PUBACK, PUBREC, PUBREL, PUBCOMP, SUBSCRIBE, SUBACK, UNSUBSCRIBE, UNSUBACK, DISCONNECT, AUTH 0x27 Maximum Packet Size Four Byte Integer CONNECT, CONNACK 0x28 Wildcard Subscription Byte CONNACK Available 0x29 Subscription Identifier Byte CONNACK Available 0x2A Shared Subscription Byte CONNACK Available Non-normative comment Although the Property Identifier is defined as a Variable Byte Integer, in this version of the specification all of the Property Identifiers are one byte long.
2.3 Payload Some MQTT Control Packets contain a Payload as the final part of the packet.
In the PUBLISH packet this is the Application Message Table 2-5 - MQTT Control Packets that contain a Payload MQTT Control Payload Packet CONNECT Required CONNACK None PUBLISH Optional PUBACK None PUBREC None PUBREL None PUBCOMP None SUBSCRIBE Required SUBACK Required UNSUBSCRIBE Required UNSUBACK Required PINGREQ None PINGRESP None DISCONNECT None AUTH None 2.4 Reason Code A Reason Code is a one byte unsigned value that indicates the result of an operation.
Reason Codes less than 0x80 indicate successful completion of an operation.
The normal Reason Code for success is 0.
Reason Code values of 0x80 or greater indicate failure.
The CONNACK, PUBACK, PUBREC, PUBREL, PUBCOMP, DISCONNECT and AUTH Control Packets have a single Reason Code as part of the Variable Header.
The SUBACK and UNSUBACK packets contain a list of one or more Reason Codes in the Payload.
The Reason Codes share a common set of values as shown below.
Table 2-6 - Reason Codes Reason Code Name Packets Decimal Hex 0x00 Success CONNACK, PUBACK, PUBREC, PUBREL, PUBCOMP, UNSUBACK, AUTH 0x00 Normal disconnection DISCONNECT 0x00 Granted QoS 0 SUBACK 0x01 Granted QoS 1 SUBACK 0x02 Granted QoS 2 SUBACK 0x04 Disconnect with Will Message DISCONNECT 0x10 No matching subscribers PUBACK, PUBREC 0x11 No subscription existed UNSUBACK 0x18 Continue authentication AUTH 0x19 Re-authenticate AUTH 0x80 Unspecified error CONNACK, PUBACK, PUBREC, SUBACK, UNSUBACK, DISCONNECT 0x81 Malformed Packet CONNACK, DISCONNECT 0x82 Protocol Error CONNACK, DISCONNECT 0x83 Implementation specific error CONNACK, PUBACK, PUBREC, SUBACK, UNSUBACK, DISCONNECT 0x84 Unsupported Protocol Version CONNACK 0x85 Client Identifier not valid CONNACK 0x86 Bad User Name or Password CONNACK 0x87 Not authorized CONNACK, PUBACK, PUBREC, SUBACK, UNSUBACK, DISCONNECT 0x88 Server unavailable CONNACK 0x89 Server busy CONNACK, DISCONNECT 0x8A Banned CONNACK 0x8B Server shutting down DISCONNECT 0x8C Bad authentication method CONNACK, DISCONNECT 0x8D Keep Alive timeout DISCONNECT 0x8E Session taken over DISCONNECT 0x8F Topic Filter invalid SUBACK, UNSUBACK, DISCONNECT 0x90 Topic Name invalid CONNACK, PUBACK, PUBREC, DISCONNECT 0x91 Packet Identifier in use PUBACK, PUBREC, SUBACK, UNSUBACK 0x92 Packet Identifier not found PUBREL, PUBCOMP 0x93 Receive Maximum exceeded DISCONNECT 0x94 Topic Alias invalid DISCONNECT 0x95 Packet too large CONNACK, DISCONNECT 0x96 Message rate too high DISCONNECT 0x97 Quota exceeded CONNACK, PUBACK, PUBREC, SUBACK, DISCONNECT 0x98 Administrative action DISCONNECT 0x99 Payload format invalid CONNACK, PUBACK, PUBREC, DISCONNECT 0x9A Retain not supported CONNACK, DISCONNECT 0x9B QoS not supported CONNACK, DISCONNECT 0x9C Use another server CONNACK, DISCONNECT 0x9D Server moved CONNACK, DISCONNECT 0x9E Shared Subscriptions not SUBACK, DISCONNECT supported 0x9F Connection rate exceeded CONNACK, DISCONNECT 0xA0 Maximum connect time DISCONNECT 0xA1 Subscription Identifiers not SUBACK, DISCONNECT supported 0xA2 Wildcard Subscriptions not SUBACK, DISCONNECT supported Non-normative comment For Reason Code 0x91 (Packet identifier in use), the response to this is either to try to fix the state, or to reset the Session state by connecting using Clean Start set to 1, or to decide if the Client or Server implementations are defective.
MQTT Control Packets 3.1 CONNECT â Connection Request After a Network Connection is established by a Client to a Server, the first packet sent from the Client to the Server MUST be a CONNECT packet [MQTT-3.1.0-1].
A Client can only send the CONNECT packet once over a Network Connection.
The Server MUST process a second CONNECT packet sent from a Client as a Protocol Error and close the Network Connection [MQTT-3.1.0-2].
Refer to section 4.13 for information about handling errors.
The Payload contains one or more encoded fields.
They specify a unique Client identifier for the Client, a Will Topic, Will Payload, User Name and Password.
All but the Client identifier can be omitted and their presence is determined based on flags in the Variable Header.
It is encoded as a Variable Byte Integer.
3.1.2 CONNECT Variable Header The Variable Header for the CONNECT Packet contains the following fields in this order: Protocol Name, Protocol Level, Connect Flags, Keep Alive, and Properties.
The rules for encoding Properties are described in section 2.2.2.
The string, its offset and length will not be changed by future versions of the MQTT specification.
A Server which support multiple protocols uses the Protocol Name to determine whether the data is MQTT.
The protocol name MUST be the UTF-8 String "MQTT".
If the Server does not want to accept the CONNECT, and wishes to reveal that it is an MQTT Server it MAY send a CONNACK packet with Reason Code of 0x84 (Unsupported Protocol Version), and then it MUST close the Network Connection [MQTT-3.1.2-1].
Non-normative comment Packet inspectors, such as firewalls, could use the Protocol Name to identify MQTT traffic.
The value of the Protocol Version field for version 5.0 of the protocol is 5 (0x05).
A Server which supports multiple versions of the MQTT protocol uses the Protocol Version to determine which version of MQTT the Client is using.
If the Protocol Version is not 5 and the Server does not want to accept the CONNECT packet, the Server MAY send a CONNACK packet with Reason Code 0x84 (Unsupported Protocol Version) and then MUST close the Network Connection [MQTT-3.1.2-2].
3.1.2.3 Connect Flags The Connect Flags byte contains several parameters specifying the behavior of the MQTT connection.
It also indicates the presence or absence of fields in the Payload.
If the reserved flag is not 0 it is a Malformed Packet.
Refer to section 4.13 for information about handling errors.
3.1.2.4 Clean Start Position: bit 1 of the Connect Flags byte.
This bit specifies whether the Connection starts a new Session or is a continuation of an existing Session.
Refer to section 4.1 for a definition of the Session State.
If a CONNECT packet is received with Clean Start is set to 1, the Client and Server MUST discard any existing Session and start a new Session [MQTT-3.1.2-4].
Consequently, the Session Present flag in CONNACK is always set to 0 if Clean Start is set to 1.
If a CONNECT packet is received with Clean Start set to 0 and there is a Session associated with the Client Identifier, the Server MUST resume communications with the Client based on state from the existing Session [MQTT-3.1.2-5].
If a CONNECT packet is received with Clean Start set to 0 and there is no Session associated with the Client Identifier, the Server MUST create a new Session [MQTT-3.1.2-6].
3.1.2.5 Will Flag Position: bit 2 of the Connect Flags.
If the Will Flag is set to 1 this indicates that a Will Message MUST be stored on the Server and associated with the Session [MQTT-3.1.2-7].
The Will Message consists of the Will Properties, Will Topic, and Will Payload fields in the CONNECT Payload.
The Will Message MUST be published after the Network Connection is subsequently closed and either the Will Delay Interval has elapsed or the Session ends, unless the Will Message has been deleted by the Server on receipt of a DISCONNECT packet with Reason Code 0x00 (Normal disconnection) or a new Network Connection for the ClientID is opened before the Will Delay Interval has elapsed [MQTT-3.1.2-8].
Situations in which the Will Message is published include, but are not limited to: â¢ An I/O error or network failure detected by the Server.
â¢ The Client fails to communicate within the Keep Alive time.
â¢ The Client closes the Network Connection without first sending a DISCONNECT packet with a Reason Code 0x00 (Normal disconnection).
â¢ The Server closes the Network Connection without first receiving a DISCONNECT packet with a Reason Code 0x00 (Normal disconnection).
If the Will Flag is set to 1, the Will Properties, Will Topic, and Will Payload fields MUST be present in the Payload [MQTT-3.1.2-9].
The Will Message MUST be removed from the stored Session State in the Server once it has been published or the Server has received a DISCONNECT packet with a Reason Code of 0x00 (Normal disconnection) from the Client [MQTT-3.1.2-10].
The Server SHOULD publish Will Messages promptly after the Network Connection is closed and the Will Delay Interval has passed, or when the Session ends, whichever occurs first.
In the case of a Server shutdown or failure, the Server MAY defer publication of Will Messages until a subsequent restart.
If this happens, there might be a delay between the time the Server experienced failure and when the Will Message is published.
Refer to section 3.1.3.2 for information about the Will Delay Interval.
Non-normative comment The Client can arrange for the Will Message to notify that Session Expiry has occurred by setting the Will Delay Interval to be longer than the Session Expiry Interval and sending DISCONNECT with Reason Code 0x04 (Disconnect with Will Message).
3.1.2.6 Will QoS Position: bits 4 and 3 of the Connect Flags.
These two bits specify the QoS level to be used when publishing the Will Message.
If the Will Flag is set to 0, then the Will QoS MUST be set to 0(0x00) [MQTT-3.1.2-11].
If the Will Flag is set to 1, the value of Will QoS can be 0 (0x00), 1 (0x01), or 2 (0x02) [MQTT-3.1.2-12].
A value of 3 (0x03) is a Malformed Packet.
Refer to section 4.13 for information about handling errors.
3.1.2.7 Will Retain Position: bit 5 of the Connect Flags.
This bit specifies if the Will Message is to be retained when it is published.
If the Will Flag is set to 0, then Will Retain MUST be set to 0 [MQTT-3.1.2-13].
If the Will Flag is set to 1 and Will Retain is set to 0, the Server MUST publish the Will Message as a non-retained message [MQTT-3.1.2-14].
If the Will Flag is set to 1 and Will Retain is set to 1, the Server MUST publish the Will Message as a retained message [MQTT-3.1.2-15].
3.1.2.8 User Name Flag Position: bit 7 of the Connect Flags.
If the User Name Flag is set to 0, a User Name MUST NOT be present in the Payload [MQTT-3.1.2-16].
If the User Name Flag is set to 1, a User Name MUST be present in the Payload [MQTT-3.1.2-17].
3.1.2.9 Password Flag Position: bit 6 of the Connect Flags.
If the Password Flag is set to 0, a Password MUST NOT be present in the Payload [MQTT-3.1.2-18].
If the Password Flag is set to 1, a Password MUST be present in the Payload [MQTT-3.1.2-19].
Non-normative comment This version of the protocol allows the sending of a Password with no User Name, where MQTT v3.1.1 did not.
This reflects the common use of Password for credentials other than a password.
It is the maximum time interval that is permitted to elapse between the point at which the Client finishes transmitting one MQTT Control Packet and the point it starts sending the next.
It is the responsibility of the Client to ensure that the interval between MQTT Control Packets being sent does not exceed the Keep Alive value.
If Keep Alive is non-zero and in the absence of sending any other MQTT Control Packets, the Client MUST send a PINGREQ packet [MQTT-3.1.2-20].
If the Server returns a Server Keep Alive on the CONNACK packet, the Client MUST use that value instead of the value it sent as the Keep Alive [MQTT-3.1.2-21].
The Client can send PINGREQ at any time, irrespective of the Keep Alive value, and check for a corresponding PINGRESP to determine that the network and the Server are available.
If the Keep Alive value is non-zero and the Server does not receive an MQTT Control Packet from the Client within one and a half times the Keep Alive time period, it MUST close the Network Connection to the Client as if the network had failed [MQTT-3.1.2-22].
If a Client does not receive a PINGRESP packet within a reasonable amount of time after it has sent a PINGREQ, it SHOULD close the Network Connection to the Server.
A Keep Alive value of 0 has the effect of turning off the Keep Alive mechanism.
If Keep Alive is 0 the Client is not obliged to send MQTT Control Packets on any particular schedule.
Non-normative comment The Server may have other reasons to disconnect the Client, for instance because it is shutting down.
Setting Keep Alive does not guarantee that the Client will remain connected.
Non-normative comment The actual value of the Keep Alive is application specific; typically, this is a few minutes.
The maximum value of 65,535 is 18 hours 12 minutes and 15 seconds.
3.1.2.11 CONNECT Properties 3.1.2.11.1 Property Length The length of the Properties in the CONNECT packet Variable Header encoded as a Variable Byte Integer.
3.1.2.11.2 Session Expiry Interval 17 (0x11) Byte, Identifier of the Session Expiry Interval.
Followed by the Four Byte Integer representing the Session Expiry Interval in seconds.
It is a Protocol Error to include the Session Expiry Interval more than once.
If the Session Expiry Interval is absent the value 0 is used.
If it is set to 0, or is absent, the Session ends when the Network Connection is closed.
If the Session Expiry Interval is 0xFFFFFFFF (UINT_MAX), the Session does not expire.
The Client and Server MUST store the Session State after the Network Connection is closed if the Session Expiry Interval is greater than 0 [MQTT-3.1.2-23].
Non-normative comment The clock in the Client or Server may not be running for part of the time interval, for instance because the Client or Server are not running.
This might cause the deletion of the state to be delayed.
Refer to section 4.1 for more information about Sessions.
Refer to section 4.1.1 for details and limitations of stored state.
When the Session expires the Client and Server need not process the deletion of state atomically.
Non-normative comment Setting Clean Start to 1 and a Session Expiry Interval of 0, is equivalent to setting CleanSession to 1 in the MQTT Specification Version 3.1.1.
Setting Clean Start to 0 and no Session Expiry Interval, is equivalent to setting CleanSession to 0 in the MQTT Specification Version 3.1.1.
Non-normative comment A Client that only wants to process messages while connected will set the Clean Start to 1 and set the Session Expiry Interval to 0.
It will not receive Application Messages published before it connected and has to subscribe afresh to any topics that it is interested in each time it connects.
Non-normative comment A Client might be connecting to a Server using a network that provides intermittent connectivity.
This Client can use a short Session Expiry Interval so that it can reconnect when the network is available again and continue reliable message delivery.
If the Client does not reconnect, allowing the Session to expire, then Application Messages will be lost.
Non-normative comment When a Client connects with a long Session Expiry Interval, it is requesting that the Server maintain its MQTT session state after it disconnects for an extended period.
Clients should only connect with a long Session Expiry Interval if they intend to reconnect to the Server at some later point in time.
When a Client has determined that it has no further use for the Session it should disconnect with a Session Expiry Interval set to 0.
Non-normative comment The Client should always use the Session Present flag in the CONNACK to determine whether the Server has a Session State for this Client.
Non-normative comment The Client can avoid implementing its own Session expiry and instead rely on the Session Present flag returned from the Server to determine if the Session had expired.
If the Client does implement its own Session expiry, it needs to store the time at which the Session State will be deleted as part of its Session State.
3.1.2.11.3 Receive Maximum 33 (0x21) Byte, Identifier of the Receive Maximum.
Followed by the Two Byte Integer representing the Receive Maximum value.
It is a Protocol Error to include the Receive Maximum value more than once or for it to have the value 0.
The Client uses this value to limit the number of QoS 1 and QoS 2 publications that it is willing to process concurrently.
There is no mechanism to limit the QoS 0 publications that the Server might try to send.
The value of Receive Maximum applies only to the current Network Connection.
If the Receive Maximum value is absent then its value defaults to 65,535.
Refer to section 4.9 Flow Control for details of how the Receive Maximum is used.
3.1.2.11.4 Maximum Packet Size 39 (0x27) Byte, Identifier of the Maximum Packet Size.
Followed by a Four Byte Integer representing the Maximum Packet Size the Client is willing to accept.
If the Maximum Packet Size is not present, no limit on the packet size is imposed beyond the limitations in the protocol as a result of the remaining length encoding and the protocol header sizes.
It is a Protocol Error to include the Maximum Packet Size more than once, or for the value to be set to zero.
Non-normative comment It is the responsibility of the application to select a suitable Maximum Packet Size value if it chooses to restrict the Maximum Packet Size.
The packet size is the total number of bytes in an MQTT Control Packet, as defined in section 2.1.4.
The Client uses the Maximum Packet Size to inform the Server that it will not process packets exceeding this limit.
The Server MUST NOT send packets exceeding Maximum Packet Size to the Client [MQTT-3.1.2-24].
If a Client receives a packet whose size exceeds this limit, this is a Protocol Error, the Client uses DISCONNECT with Reason Code 0x95 (Packet too large), as described in section 4.13.
Where a Packet is too large to send, the Server MUST discard it without sending it and then behave as if it had completed sending that Application Message [MQTT-3.1.2-25].
In the case of a Shared Subscription where the message is too large to send to one or more of the Clients but other Clients can receive it, the Server can choose either discard the message without sending the message to any of the Clients, or to send the message to one of the Clients that can receive it.
Non-normative comment Where a packet is discarded without being sent, the Server could place the discarded packet on a âdead letter queueâ or perform other diagnostic action.
Such actions are outside the scope of this specification.
3.1.2.11.5 Topic Alias Maximum 34 (0x22) Byte, Identifier of the Topic Alias Maximum.
Followed by the Two Byte Integer representing the Topic Alias Maximum value.
It is a Protocol Error to include the Topic Alias Maximum value more than once.
If the Topic Alias Maximum property is absent, the default value is 0.
This value indicates the highest value that the Client will accept as a Topic Alias sent by the Server.
The Client uses this value to limit the number of Topic Aliases that it is willing to hold on this Connection.
The Server MUST NOT send a Topic Alias in a PUBLISH packet to the Client greater than Topic Alias Maximum [MQTT-3.1.2-26].
A value of 0 indicates that the Client does not accept any Topic Aliases on this connection.
If Topic Alias Maximum is absent or zero, the Server MUST NOT send any Topic Aliases to the Client [MQTT-3.1.2-27].
3.1.2.11.6 Request Response Information 25 (0x19) Byte, Identifier of the Request Response Information.
Followed by a Byte with a value of either 0 or 1.
It is Protocol Error to include the Request Response Information more than once, or to have a value other than 0 or 1.
If the Request Response Information is absent, the value of 0 is used.
The Client uses this value to request the Server to return Response Information in the CONNACK.
A value of 0 indicates that the Server MUST NOT return Response Information [MQTT-3.1.2-28].
If the value is 1 the Server MAY return Response Information in the CONNACK packet.
Non-normative comment The Server can choose not to include Response Information in the CONNACK, even if the Client requested it.
Refer to section 4.10 for more information about Request / Response.
3.1.2.11.7 Request Problem Information 23 (0x17) Byte, Identifier of the Request Problem Information.
Followed by a Byte with a value of either 0 or 1.
It is a Protocol Error to include Request Problem Information more than once, or to have a value other than 0 or 1.
If the Request Problem Information is absent, the value of 1 is used.
The Client uses this value to indicate whether the Reason String or User Properties are sent in the case of failures.
If the value of Request Problem Information is 0, the Server MAY return a Reason String or User Properties on a CONNACK or DISCONNECT packet, but MUST NOT send a Reason String or User Properties on any packet other than PUBLISH, CONNACK, or DISCONNECT [MQTT-3.1.2-29].
If the value is 0 and the Client receives a Reason String or User Properties in a packet other than PUBLISH, CONNACK, or DISCONNECT, it uses a DISCONNECT packet with Reason Code 0x82 (Protocol Error) as described in section 4.13 Handling errors.
If this value is 1, the Server MAY return a Reason String or User Properties on any packet where it is allowed.
3.1.2.11.8 User Property 38 (0x26) Byte, Identifier of the User Property.
Followed by a UTF-8 String Pair.
The User Property is allowed to appear multiple times to represent multiple name, value pairs.
The same name is allowed to appear more than once.
Non-normative comment User Properties on the CONNECT packet can be used to send connection related properties from the Client to the Server.
The meaning of these properties is not defined by this specification.
3.1.2.11.9 Authentication Method 21 (0x15) Byte, Identifier of the Authentication Method.
Followed by a UTF-8 Encoded String containing the name of the authentication method used for extended authentication .It is a Protocol Error to include Authentication Method more than once.
If Authentication Method is absent, extended authentication is not performed.
Refer to section 4.12.
If a Client sets an Authentication Method in the CONNECT, the Client MUST NOT send any packets other than AUTH or DISCONNECT packets until it has received a CONNACK packet [MQTT-3.1.2-30].
3.1.2.11.10 Authentication Data 22 (0x16) Byte, Identifier of the Authentication Data.
Followed by Binary Data containing authentication data.
It is a Protocol Error to include Authentication Data if there is no Authentication Method.
It is a Protocol Error to include Authentication Data more than once.
The contents of this data are defined by the authentication method.
Refer to section 4.12 for more information about extended authentication.
These fields, if present, MUST appear in the order Client Identifier, Will Properties, Will Topic, Will Payload, User Name, Password [MQTT-3.1.3-1].
3.1.3.1 Client Identifier (ClientID) The Client Identifier (ClientID) identifies the Client to the Server.
Each Client connecting to the Server has a unique ClientID.
The ClientID MUST be used by Clients and by Servers to identify state that they hold relating to this MQTT Session between the Client and the Server [MQTT-3.1.3-2].
Refer to section 4.1 for more information about Session State.
The ClientID MUST be present and is the first field in the CONNECT packet Payload [MQTT-3.1.3-3].
The ClientID MUST be a UTF-8 Encoded String as defined in section 1.5.4 [MQTT-3.1.3-4].
The Server MUST allow ClientIDâs which are between 1 and 23 UTF-8 encoded bytes in length, and that contain only the characters "0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ" [MQTT-3.1.3-5].
The Server MAY allow ClientIDâs that contain more than 23 encoded bytes.
The Server MAY allow ClientIDâs that contain characters not included in the list given above.
A Server MAY allow a Client to supply a ClientID that has a length of zero bytes, however if it does so the Server MUST treat this as a special case and assign a unique ClientID to that Client [MQTT-3.1.3-6].
It MUST then process the CONNECT packet as if the Client had provided that unique ClientID, and MUST return the Assigned Client Identifier in the CONNACK packet [MQTT-3.1.3-7].
If the Server rejects the ClientID it MAY respond to the CONNECT packet with a CONNACK using Reason Code 0x85 (Client Identifier not valid) as described in section 4.13 Handling errors, and then it MUST close the Network Connection [MQTT-3.1.3-8].
Non-normative comment A Client implementation could provide a convenience method to generate a random ClientID.
Clients using this method should take care to avoid creating long-lived orphaned Sessions.
3.1.3.2 Will Properties If the Will Flag is set to 1, the Will Properties is the next field in the Payload.
The Will Properties field defines the Application Message properties to be sent with the Will Message when it is published, and properties which define when to publish the Will Message.
The Will Properties consists of a Property Length and the Properties.
3.1.3.2.1 Property Length The length of the Properties in the Will Properties encoded as a Variable Byte Integer.
3.1.3.2.2 Will Delay Interval 24 (0x18) Byte, Identifier of the Will Delay Interval.
Followed by the Four Byte Integer representing the Will Delay Interval in seconds.
It is a Protocol Error to include the Will Delay Interval more than once.
If the Will Delay Interval is absent, the default value is 0 and there is no delay before the Will Message is published.
The Server delays publishing the Clientâs Will Message until the Will Delay Interval has passed or the Session ends, whichever happens first.
If a new Network Connection to this Session is made before the Will Delay Interval has passed, the Server MUST NOT send the Will Message [MQTT-3.1.3-9].
Non-normative comment One use of this is to avoid publishing Will Messages if there is a temporary network disconnection and the Client succeeds in reconnecting and continuing its Session before the Will Message is published.
Non-normative comment If a Network Connection uses a Client Identifier of an existing Network Connection to the Server, the Will Message for the exiting connection is sent unless the new connection specifies Clean Start of 0 and the Will Delay is greater than zero.
If the Will Delay is 0 the Will Message is sent at the close of the existing Network Connection, and if Clean Start is 1 the Will Message is sent because the Session ends.
3.1.3.2.3 Payload Format Indicator 1 (0x01) Byte, Identifier of the Payload Format Indicator.
Followed by the value of the Payload Format Indicator, either of: â¢ 0 (0x00) Byte Indicates that the Will Message is unspecified bytes, which is equivalent to not sending a Payload Format Indicator.
â¢ 1 (0x01) Byte Indicates that the Will Message is UTF-8 Encoded Character Data.
The UTF-8 data in the Payload MUST be well-formed UTF-8 as defined by the Unicode specification [Unicode] and restated in RFC 3629 [RFC3629].
It is a Protocol Error to include the Payload Format Indicator more than once.
The Server MAY validate that the Will Message is of the format indicated, and if it is not send a CONNACK with the Reason Code of 0x99 (Payload format invalid) as described in section 4.13.
3.1.3.2.4 Message Expiry Interval 2 (0x02) Byte, Identifier of the Message Expiry Interval.
Followed by the Four Byte Integer representing the Message Expiry Interval.
It is a Protocol Error to include the Message Expiry Interval more than once.
If present, the Four Byte value is the lifetime of the Will Message in seconds and is sent as the Publication Expiry Interval when the Server publishes the Will Message.
If absent, no Message Expiry Interval is sent when the Server publishes the Will Message.
3.1.3.2.5 Content Type 3 (0x03) Identifier of the Content Type.
Followed by a UTF-8 Encoded String describing the content of the Will Message.
It is a Protocol Error to include the Content Type more than once.
The value of the Content Type is defined by the sending and receiving application.
3.1.3.2.6 Response Topic 8 (0x08) Byte, Identifier of the Response Topic.
Followed by a UTF-8 Encoded String which is used as the Topic Name for a response message.
It is a Protocol Error to include the Response Topic more than once.
The presence of a Response Topic identifies the Will Message as a Request.
Refer to section 4.10 for more information about Request / Response.
3.1.3.2.7 Correlation Data 9 (0x09) Byte, Identifier of the Correlation Data.
Followed by Binary Data.
The Correlation Data is used by the sender of the Request Message to identify which request the Response Message is for when it is received.
It is a Protocol Error to include Correlation Data more than once.
If the Correlation Data is not present, the Requester does not require any correlation data.
The value of the Correlation Data only has meaning to the sender of the Request Message and receiver of the Response Message.
Refer to section 4.10 for more information about Request / Response 3.1.3.2.8 User Property 38 (0x26) Byte, Identifier of the User Property.
Followed by a UTF-8 String Pair.
The User Property is allowed to appear multiple times to represent multiple name, value pairs.
The same name is allowed to appear more than once.
The Server MUST maintain the order of User Properties when publishing the Will Message [MQTT-3.1.3- Non-normative comment This property is intended to provide a means of transferring application layer name-value tags whose meaning and interpretation are known only by the application programs responsible for sending and receiving them.
3.1.3.3 Will Topic If the Will Flag is set to 1, the Will Topic is the next field in the Payload.
The Will Topic MUST be a UTF-8 Encoded String as defined in section 1.5.4 [MQTT-3.1.3-11].
3.1.3.4 Will Payload If the Will Flag is set to 1 the Will Payload is the next field in the Payload.
The Will Payload defines the Application Message Payload that is to be published to the Will Topic as described in section 3.1.2.5.
This field consists of Binary Data.
3.1.3.5 User Name If the User Name Flag is set to 1, the User Name is the next field in the Payload.
The User Name MUST be a UTF-8 Encoded String as defined in section 1.5.4 [MQTT-3.1.3-12].
It can be used by the Server for authentication and authorization.
3.1.3.6 Password If the Password Flag is set to 1, the Password is the next field in the Payload.
The Password field is Binary Data.
Although this field is called Password, it can be used to carry any credential information.
3.1.4 CONNECT Actions Note that a Server MAY support multiple protocols (including other versions of the MQTT protocol) on the same TCP port or other network endpoint.
If the Server determines that the protocol is MQTT v5.0 then it validates the connection attempt as follows.
If the Server does not receive a CONNECT packet within a reasonable amount of time after the Network Connection is established, the Server SHOULD close the Network Connection.
The Server MUST validate that the CONNECT packet matches the format described in section 3.1 and close the Network Connection if it does not match [MQTT-3.1.4-1].
The Server MAY send a CONNACK with a Reason Code of 0x80 or greater as described in section 4.13 before closing the Network Connection.
The Server MAY check that the contents of the CONNECT packet meet any further restrictions and SHOULD perform authentication and authorization checks.
If any of these checks fail, it MUST close the Network Connection [MQTT-3.1.4-2].
Before closing the Network Connection, it MAY send an appropriate CONNACK response with a Reason Code of 0x80 or greater as described in section 3.2 and section 4.13.
If validation is successful, the Server performs the following steps.
If the ClientID represents a Client already connected to the Server, the Server sends a DISCONNECT packet to the existing Client with Reason Code of 0x8E (Session taken over) as described in section 4.13 and MUST close the Network Connection of the existing Client [MQTT- 3.1.4-3].
If the existing Client has a Will Message, that Will Message is published as described in section 3.1.2.5.
Non-normative comment If the Will Delay Interval of the existing Network Connection is 0 and there is a Will Message, it will be sent because the Network Connection is closed.
If the Session Expiry Interval of the existing Network Connection is 0, or the new Network Connection has Clean Start set to 1 then if the existing Network Connection has a Will Message it will be sent because the original Session is ended on the takeover.
The Server MUST perform the processing of Clean Start that is described in section 3.1.2.4 [MQTT-3.1.4-4].
The Server MUST acknowledge the CONNECT packet with a CONNACK packet containing a 0x00 (Success) Reason Code [MQTT-3.1.4-5].
Non-normative comment It is recommended that authentication and authorization checks be performed if the Server is being used to process any form of business critical data.
If these checks succeed, the Server responds by sending CONNACK with a 0x00 (Success) Reason Code.
If they fail, it is suggested that the Server does not send a CONNACK at all, as this could alert a potential attacker to the presence of the MQTT Server and encourage such an attacker to launch a denial of service or password-guessing attack.
Start message delivery and Keep Alive monitoring.
Clients are allowed to send further MQTT Control Packets immediately after sending a CONNECT packet; Clients need not wait for a CONNACK packet to arrive from the Server.
If the Server rejects the CONNECT, it MUST NOT process any data sent by the Client after the CONNECT packet except AUTH packets [MQTT-3.1.4-6].
Non-normative comment Clients typically wait for a CONNACK packet, However, if the Client exploits its freedom to send MQTT Control Packets before it receives a CONNACK, it might simplify the Client implementation as it does not have to police the connected state.
The Client accepts that any data that it sends before it receives a CONNACK packet from the Server will not be processed if the Server rejects the connection.
Non-normative comment Clients that send MQTT Control Packets before they receive CONNACK will be unaware of the Server constraints and whether any existing Session is being used.
Non-normative comment The Server can limit reading from the Network Connection or close the Network Connection if the Client sends too much data before authentication is complete.
This is suggested as a way of avoiding denial of service attacks.
3.2 CONNACK â Connect acknowledgement The CONNACK packet is the packet sent by the Server in response to a CONNECT packet received from a Client.
The Server MUST send a CONNACK with a 0x00 (Success) Reason Code before sending any Packet other than AUTH [MQTT-3.2.0-1].
The Server MUST NOT send more than one CONNACK in a Network Connection [MQTT-3.2.0-2].
If the Client does not receive a CONNACK packet from the Server within a reasonable amount of time, the Client SHOULD close the Network Connection.
A "reasonable" amount of time depends on the type of application and the communications infrastructure.
3.2.2 CONNACK Variable Header The Variable Header of the CONNACK Packet contains the following fields in the order: Connect Acknowledge Flags, Connect Reason Code, and Properties.
The rules for encoding Properties are described in section 2.2.2.
3.2.2.1 Connect Acknowledge Flags Byte 1 is the "Connect Acknowledge Flags".
Bits 7-1 are reserved and MUST be set to 0 [MQTT-3.2.2-1].
Bit 0 is the Session Present Flag.
3.2.2.1.1 Session Present Position: bit 0 of the Connect Acknowledge Flags.
The Session Present flag informs the Client whether the Server is using Session State from a previous connection for this ClientID.
This allows the Client and Server to have a consistent view of the Session State.
If the Server accepts a connection with Clean Start set to 1, the Server MUST set Session Present to 0 in the CONNACK packet in addition to setting a 0x00 (Success) Reason Code in the CONNACK packet [MQTT-3.2.2-2].
If the Server accepts a connection with Clean Start set to 0 and the Server has Session State for the ClientID, it MUST set Session Present to 1 in the CONNACK packet, otherwise it MUST set Session Present to 0 in the CONNACK packet.
In both cases it MUST set a 0x00 (Success) Reason Code in the CONNACK packet [MQTT-3.2.2-3].
If the value of Session Present received by the Client from the Server is not as expected, the Client proceeds as follows: â¢ If the Client does not have Session State and receives Session Present set to 1 it MUST close the Network Connection [MQTT-3.2.2-4].
If it wishes to restart with a new Session the Client can reconnect using Clean Start set to 1.
â¢ If the Client does have Session State and receives Session Present set to 0 it MUST discard its Session State if it continues with the Network Connection [MQTT-3.2.2-5].
If a Server sends a CONNACK packet containing a non-zero Reason Code it MUST set Session Present to 0 [MQTT-3.2.2-6].
3.2.2.2 Connect Reason Code Byte 2 in the Variable Header is the Connect Reason Code.
The values the Connect Reason Code are shown below.
If a well formed CONNECT packet is received by the Server, but the Server is unable to complete the Connection the Server MAY send a CONNACK packet containing the appropriate Connect Reason code from this table.
If a Server sends a CONNACK packet containing a Reason code of 128 or greater it MUST then close the Network Connection [MQTT- Table 3-1 - Connect Reason Code values Value Hex Reason Code name Description 0x00 Success The Connection is accepted.
0x80 Unspecified error The Server does not wish to reveal the reason for the failure, or none of the other Reason Codes apply.
0x81 Malformed Packet Data within the CONNECT packet could not be correctly parsed.
0x82 Protocol Error Data in the CONNECT packet does not conform to this specification.
0x83 Implementation specific error The CONNECT is valid but is not accepted by this Server.
0x84 Unsupported Protocol Version The Server does not support the version of the MQTT protocol requested by the Client.
0x85 Client Identifier not valid The Client Identifier is a valid string but is not allowed by the Server.
0x86 Bad User Name or Password The Server does not accept the User Name or Password specified by the Client 0x87 Not authorized The Client is not authorized to connect.
0x88 Server unavailable The MQTT Server is not available.
0x89 Server busy The Server is busy.
Try again later.
0x8A Banned This Client has been banned by administrative action.
Contact the server administrator.
0x8C Bad authentication method The authentication method is not supported or does not match the authentication method currently in use.
0x90 Topic Name invalid The Will Topic Name is not malformed, but is not accepted by this Server.
0x95 Packet too large The CONNECT packet exceeded the maximum permissible size.
0x97 Quota exceeded An implementation or administrative imposed limit has been exceeded.
0x99 Payload format invalid The Will Payload does not match the specified Payload Format Indicator.
0x9A Retain not supported The Server does not support retained messages, and Will Retain was set to 1.
0x9B QoS not supported The Server does not support the QoS set in Will QoS.
0x9C Use another server The Client should temporarily use another server.
0x9D Server moved The Client should permanently use another server.
0x9F Connection rate exceeded The connection rate limit has been exceeded.
The Server sending the CONNACK packet MUST use one of the Connect Reason Code valuesT-3.2.2- Non-normative comment Reason Code 0x80 (Unspecified error) may be used where the Server knows the reason for the failure but does not wish to reveal it to the Client, or when none of the other Reason Code values applies.
The Server may choose to close the Network Connection without sending a CONNACK to enhance security in the case where an error is found on the CONNECT.
For instance, when on a public network and the connection has not been authorized it might be unwise to indicate that this is an MQTT Server.
3.2.2.3 CONNACK Properties 3.2.2.3.1 Property Length This is the length of the Properties in the CONNACK packet Variable Header encoded as a Variable Byte Integer.
3.2.2.3.2 Session Expiry Interval 17 (0x11) Byte, Identifier of the Session Expiry Interval.
Followed by the Four Byte Integer representing the Session Expiry Interval in seconds.
It is a Protocol Error to include the Session Expiry Interval more than once.
If the Session Expiry Interval is absent the value in the CONNECT Packet used.
The server uses this property to inform the Client that it is using a value other than that sent by the Client in the CONNACK.
Refer to section 3.1.2.11.2 for a description of the use of Session Expiry Interval.
3.2.2.3.3 Receive Maximum 33 (0x21) Byte, Identifier of the Receive Maximum.
Followed by the Two Byte Integer representing the Receive Maximum value.
It is a Protocol Error to include the Receive Maximum value more than once or for it to have the value 0.
The Server uses this value to limit the number of QoS 1 and QoS 2 publications that it is willing to process concurrently for the Client.
It does not provide a mechanism to limit the QoS 0 publications that the Client might try to send.
If the Receive Maximum value is absent, then its value defaults to 65,535.
Refer to section 4.9 Flow Control for details of how the Receive Maximum is used.
3.2.2.3.4 Maximum QoS 36 (0x24) Byte, Identifier of the Maximum QoS.
Followed by a Byte with a value of either 0 or 1.
It is a Protocol Error to include Maximum QoS more than once, or to have a value other than 0 or 1.
If the Maximum QoS is absent, the Client uses a Maximum QoS of 2.
If a Server does not support QoS 1 or QoS 2 PUBLISH packets it MUST send a Maximum QoS in the CONNACK packet specifying the highest QoS it supports [MQTT-3.2.2-9].
A Server that does not support QoS 1 or QoS 2 PUBLISH packets MUST still accept SUBSCRIBE packets containing a Requested QoS of 0, 1 or 2 [MQTT-3.2.2-10].
If a Client receives a Maximum QoS from a Server, it MUST NOT send PUBLISH packets at a QoS level exceeding the Maximum QoS level specified [MQTT-3.2.2-11].
It is a Protocol Error if the Server receives a PUBLISH packet with a QoS greater than the Maximum QoS it specified.
In this case use DISCONNECT with Reason Code 0x9B (QoS not supported) as described in section 4.13 Handling errors.
If a Server receives a CONNECT packet containing a Will QoS that exceeds its capabilities, it MUST reject the connection.
It SHOULD use a CONNACK packet with Reason Code 0x9B (QoS not supported) as described in section 4.13 Handling errors, and MUST close the Network Connection [MQTT-3.2.2-12].
Non-normative comment A Client does not need to support QoS 1 or QoS 2 PUBLISH packets.
If this is the case, the Client simply restricts the maximum QoS field in any SUBSCRIBE commands it sends to a value it can support.
3.2.2.3.5 Retain Available 37 (0x25) Byte, Identifier of Retain Available.
Followed by a Byte field.
If present, this byte declares whether the Server supports retained messages.
A value of 0 means that retained messages are not supported.
A value of 1 means retained messages are supported.
If not present, then retained messages are supported.
It is a Protocol Error to include Retain Available more than once or to use a value other than 0 or 1.
If a Server receives a CONNECT packet containing a Will Message with the Will Retain set to 1, and it does not support retained messages, the Server MUST reject the connection request.
It SHOULD send CONNACK with Reason Code 0x9A (Retain not supported) and then it MUST close the Network Connection [MQTT-3.2.2-13].
A Client receiving Retain Available set to 0 from the Server MUST NOT send a PUBLISH packet with the RETAIN flag set to 1 [MQTT-3.2.2-14].
If the Server receives such a packet, this is a Protocol Error.
The Server SHOULD send a DISCONNECT with Reason Code of 0x9A (Retain not supported) as described in section 4.13.
3.2.2.3.6 Maximum Packet Size 39 (0x27) Byte, Identifier of the Maximum Packet Size.
Followed by a Four Byte Integer representing the Maximum Packet Size the Server is willing to accept.
If the Maximum Packet Size is not present, there is no limit on the packet size imposed beyond the limitations in the protocol as a result of the remaining length encoding and the protocol header sizes.
It is a Protocol Error to include the Maximum Packet Size more than once, or for the value to be set to zero.
The packet size is the total number of bytes in an MQTT Control Packet, as defined in section 2.1.4.
The Server uses the Maximum Packet Size to inform the Client that it will not process packets whose size exceeds this limit.
The Client MUST NOT send packets exceeding Maximum Packet Size to the Server [MQTT-3.2.2-15].
If a Server receives a packet whose size exceeds this limit, this is a Protocol Error, the Server uses DISCONNECT with Reason Code 0x95 (Packet too large), as described in section 4.13.
3.2.2.3.7 Assigned Client Identifier 18 (0x12) Byte, Identifier of the Assigned Client Identifier.
Followed by the UTF-8 string which is the Assigned Client Identifier.
It is a Protocol Error to include the Assigned Client Identifier more than once.
The Client Identifier which was assigned by the Server because a zero length Client Identifier was found in the CONNECT packet.
If the Client connects using a zero length Client Identifier, the Server MUST respond with a CONNACK containing an Assigned Client Identifier.
The Assigned Client Identifier MUST be a new Client Identifier not used by any other Session currently in the Server [MQTT-3.2.2-16].
3.2.2.3.8 Topic Alias Maximum 34 (0x22) Byte, Identifier of the Topic Alias Maximum.
Followed by the Two Byte Integer representing the Topic Alias Maximum value.
It is a Protocol Error to include the Topic Alias Maximum value more than once.
If the Topic Alias Maximum property is absent, the default value is 0.
This value indicates the highest value that the Server will accept as a Topic Alias sent by the Client.
The Server uses this value to limit the number of Topic Aliases that it is willing to hold on this Connection.
The Client MUST NOT send a Topic Alias in a PUBLISH packet to the Server greater than this value [MQTT- 3.2.2-17].
A value of 0 indicates that the Server does not accept any Topic Aliases on this connection.
If Topic Alias Maximum is absent or 0, the Client MUST NOT send any Topic Aliases on to the Server [MQTT-3.2.2-18].
3.2.2.3.9 Reason String 31 (0x1F) Byte Identifier of the Reason String.
Followed by the UTF-8 Encoded String representing the reason associated with this response.
This Reason String is a human readable string designed for diagnostics and SHOULD NOT be parsed by the Client.
The Server uses this value to give additional information to the Client.
The Server MUST NOT send this property if it would increase the size of the CONNACK packet beyond the Maximum Packet Size specified by the Client [MQTT-3.2.2-19].
It is a Protocol Error to include the Reason String more than once.
Non-normative comment Proper uses for the reason string in the Client would include using this information in an exception thrown by the Client code, or writing this string to a log.
3.2.2.3.10 User Property 38 (0x26) Byte, Identifier of User Property.
Followed by a UTF-8 String Pair.
This property can be used to provide additional information to the Client including diagnostic information.
The Server MUST NOT send this property if it would increase the size of the CONNACK packet beyond the Maximum Packet Size specified by the Client [MQTT-3.2.2-20].
The User Property is allowed to appear multiple times to represent multiple name, value pairs.
The same name is allowed to appear more than once.
The content and meaning of this property is not defined by this specification.
The receiver of a CONNACK containing this property MAY ignore it.
3.2.2.3.11 Wildcard Subscription Available 40 (0x28) Byte, Identifier of Wildcard Subscription Available.
Followed by a Byte field.
If present, this byte declares whether the Server supports Wildcard Subscriptions.
A value is 0 means that Wildcard Subscriptions are not supported.
A value of 1 means Wildcard Subscriptions are supported.
If not present, then Wildcard Subscriptions are supported.
It is a Protocol Error to include the Wildcard Subscription Available more than once or to send a value other than 0 or 1.
If the Server receives a SUBSCRIBE packet containing a Wildcard Subscription and it does not support Wildcard Subscriptions, this is a Protocol Error.
The Server uses DISCONNECT with Reason Code 0xA2 (Wildcard Subscriptions not supported) as described in section 4.13.
If a Server supports Wildcard Subscriptions, it can still reject a particular subscribe request containing a Wildcard Subscription.
In this case the Server MAY send a SUBACK Control Packet with a Reason Code 0xA2 (Wildcard Subscriptions not supported).
3.2.2.3.12 Subscription Identifiers Available 41 (0x29) Byte, Identifier of Subscription Identifier Available.
Followed by a Byte field.
If present, this byte declares whether the Server supports Subscription Identifiers.
A value is 0 means that Subscription Identifiers are not supported.
A value of 1 means Subscription Identifiers are supported.
If not present, then Subscription Identifiers are supported.
It is a Protocol Error to include the Subscription Identifier Available more than once, or to send a value other than 0 or 1.
If the Server receives a SUBSCRIBE packet containing Subscription Identifier and it does not support Subscription Identifiers, this is a Protocol Error.
The Server uses DISCONNECT with Reason Code of 0xA1 (Subscription Identifiers not supported) as described in section 4.13.
3.2.2.3.13 Shared Subscription Available 42 (0x2A) Byte, Identifier of Shared Subscription Available.
Followed by a Byte field.
If present, this byte declares whether the Server supports Shared Subscriptions.
A value is 0 means that Shared Subscriptions are not supported.
A value of 1 means Shared Subscriptions are supported.
If not present, then Shared Subscriptions are supported.
It is a Protocol Error to include the Shared Subscription Available more than once or to send a value other than 0 or 1.
If the Server receives a SUBSCRIBE packet containing Shared Subscriptions and it does not support Shared Subscriptions, this is a Protocol Error.
The Server uses DISCONNECT with Reason Code 0x9E (Shared Subscriptions not supported) as described in section 4.13.
3.2.2.3.14 Server Keep Alive 19 (0x13) Byte, Identifier of the Server Keep Alive.
Followed by a Two Byte Integer with the Keep Alive time assigned by the Server.
If the Server sends a Server Keep Alive on the CONNACK packet, the Client MUST use this value instead of the Keep Alive value the Client sent on CONNECT [MQTT-3.2.2-21].
If the Server does not send the Server Keep Alive, the Server MUST use the Keep Alive value set by the Client on CONNECT [MQTT-3.2.2-22].
It is a Protocol Error to include the Server Keep Alive more than once.
Non-normative comment The primary use of the Server Keep Alive is for the Server to inform the Client that it will disconnect the Client for inactivity sooner than the Keep Alive specified by the Client.
3.2.2.3.15 Response Information 26 (0x1A) Byte, Identifier of the Response Information.
Followed by a UTF-8 Encoded String which is used as the basis for creating a Response Topic.
The way in which the Client creates a Response Topic from the Response Information is not defined by this specification.
It is a Protocol Error to include the Response Information more than once.
If the Client sends a Request Response Information with a value 1, it is OPTIONAL for the Server to send the Response Information in the CONNACK.
Non-normative comment A common use of this is to pass a globally unique portion of the topic tree which is reserved for this Client for at least the lifetime of its Session.
This often cannot just be a random name as both the requesting Client and the responding Client need to be authorized to use it.
It is normal to use this as the root of a topic tree for a particular Client.
For the Server to return this information, it normally needs to be correctly configured.
Using this mechanism allows this configuration to be done once in the Server rather than in each Client.
Refer to section 4.10 for more information about Request / Response.
3.2.2.3.16 Server Reference 28 (0x1C) Byte, Identifier of the Server Reference.
Followed by a UTF-8 Encoded String which can be used by the Client to identify another Server to use.
It is a Protocol Error to include the Server Reference more than once.
The Server uses a Server Reference in either a CONNACK or DISCONNECT packet with Reason code of 0x9C (Use another server) or Reason Code 0x9D (Server moved) as described in section 4.13.
Refer to section 4.11 Server redirection for information about how Server Reference is used.
3.2.2.3.17 Authentication Method 21 (0x15) Byte, Identifier of the Authentication Method.
Followed by a UTF-8 Encoded String containing the name of the authentication method.
It is a Protocol Error to include the Authentication Method more than once.
Refer to section 4.12 for more information about extended authentication.
3.2.2.3.18 Authentication Data 22 (0x16) Byte, Identifier of the Authentication Data.
Followed by Binary Data containing authentication data.
The contents of this data are defined by the authentication method and the state of already exchanged authentication data.
It is a Protocol Error to include the Authentication Data more than once.
Refer to section 4.12 for more information about extended authentication.
3.2.3 CONNACK Payload The CONNACK packet has no Payload.
3.3 PUBLISH â Publish message A PUBLISH packet is sent from a Client to a Server or from a Server to a Client to transport an Application Message.
If the DUP flag is set to 0, it indicates that this is the first occasion that the Client or Server has attempted to send this PUBLISH packet.
If the DUP flag is set to 1, it indicates that this might be re-delivery of an earlier attempt to send the packet.
The DUP flag MUST be set to 1 by the Client or Server when it attempts to re-deliver a PUBLISH packet [MQTT-3.3.1-1].
The DUP flag MUST be set to 0 for all QoS 0 messages [MQTT-3.3.1-2].
The value of the DUP flag from an incoming PUBLISH packet is not propagated when the PUBLISH packet is sent to subscribers by the Server.
The DUP flag in the outgoing PUBLISH packet is set independently to the incoming PUBLISH packet, its value MUST be determined solely by whether the outgoing PUBLISH packet is a retransmission [MQTT-3.3.1-3].
Non-normative comment The receiver of an MQTT Control Packet that contains the DUP flag set to 1 cannot assume that it has seen an earlier copy of this packet.
Non-normative comment It is important to note that the DUP flag refers to the MQTT Control Packet itself and not to the Application Message that it contains.
When using QoS 1, it is possible for a Client to receive a PUBLISH packet with DUP flag set to 0 that contains a repetition of an Application Message that it received earlier, but with a different Packet Identifier.
Section 2.2.1 provides more information about Packet Identifiers.
3.3.1.2 QoS Position: byte 1, bits 2-1.
This field indicates the level of assurance for delivery of an Application Message.
The QoS levels are shown below.
Table 3-2 - QoS definitions QoS value Bit 2 bit 1 Description 0 0 At most once delivery 0 1 At least once delivery 1 0 Exactly once delivery - 1 1 Reserved â must not be used If the Server included a Maximum QoS in its CONNACK response to a Client and it receives a PUBLISH packet with a QoS greater than this, then it uses DISCONNECT with Reason Code 0x9B (QoS not supported) as described in section 4.13 Handling errors.
A PUBLISH Packet MUST NOT have both QoS bits set to 1 [MQTT-3.3.1-4].
If a Server or Client receives a PUBLISH packet which has both QoS bits set to 1 it is a Malformed Packet.
Use DISCONNECT with Reason Code 0x81 (Malformed Packet) as described in section 4.13.
3.3.1.3 RETAIN Position: byte 1, bit 0.
If the RETAIN flag is set to 1 in a PUBLISH packet sent by a Client to a Server, the Server MUST replace any existing retained message for this topic and store the Application Message [MQTT-3.3.1-5], so that it can be delivered to future subscribers whose subscriptions match its Topic Name.
If the Payload contains zero bytes it is processed normally by the Server but any retained message with the same topic name MUST be removed and any future subscribers for the topic will not receive a retained message [MQTT- 3.3.1-6].
A retained message with a Payload containing zero bytes MUST NOT be stored as a retained message on the Server [MQTT-3.3.1-7].
If the RETAIN flag is 0 in a PUBLISH packet sent by a Client to a Server, the Server MUST NOT store the message as a retained message and MUST NOT remove or replace any existing retained message [MQTT-3.3.1-8].
If the Server included Retain Available in its CONNACK response to a Client with its value set to 0 and it receives a PUBLISH packet with the RETAIN flag is set to 1, then it uses the DISCONNECT Reason Code of 0x9A (Retain not supported) as described in section 4.13.
When a new Non-shared Subscription is made, the last retained message, if any, on each matching topic name is sent to the Client as directed by the Retain Handling Subscription Option.
These messages are sent with the RETAIN flag set to 1.
Which retained messages are sent is controlled by the Retain Handling Subscription Option.
At the time of the Subscription: â¢ If Retain Handling is set to 0 the Server MUST send the retained messages matching the Topic Filter of the subscription to the Client [MQTT-3.3.1-9].
â¢ If Retain Handling is set to 1 then if the subscription did not already exist, the Server MUST send all retained message matching the Topic Filter of the subscription to the Client, and if the subscription did exist the Server MUST NOT send the retained messages.
[MQTT-3.3.1-10].
â¢ If Retain Handling is set to 2, the Server MUST NOT send the retained messages [MQTT-3.3.1- Refer to section 3.8.3.1 for a definition of the Subscription Options.
If the Server receives a PUBLISH packet with the RETAIN flag set to 1, and QoS 0 it SHOULD store the new QoS 0 message as the new retained message for that topic, but MAY choose to discard it at any time.
If this happens there will be no retained message for that topic.
If the current retained message for a Topic expires, it is discarded and there will be no retained message for that topic.
The setting of the RETAIN flag in an Application Message forwarded by the Server from an established connection is controlled by the Retain As Published subscription option.
Refer to section 3.8.3.1 for a definition of the Subscription Options.
â¢ If the value of Retain As Published subscription option is set to 0, the Server MUST set the RETAIN flag to 0 when forwarding an Application Message regardless of how the RETAIN flag was set in the received PUBLISH packet [MQTT-3.3.1-12].
â¢ If the value of Retain As Published subscription option is set to 1, the Server MUST set the RETAIN flag equal to the RETAIN flag in the received PUBLISH packet [MQTT-3.3.1-13].
Non-normative comment Retained messages are useful where publishers send state messages on an irregular basis.
A new non-shared subscriber will receive the most recent state.
3.3.1.4 Remaining Length This is the length of Variable Header plus the length of the Payload, encoded as a Variable Byte Integer.
3.3.2 PUBLISH Variable Header The Variable Header of the PUBLISH Packet contains the following fields in the order: Topic Name, Packet Identifier, and Properties.
The rules for encoding Properties are described in section 2.2.2.
3.3.2.1 Topic Name The Topic Name identifies the information channel to which Payload data is published.
The Topic Name MUST be present as the first field in the PUBLISH packet Variable Header.
It MUST be a UTF-8 Encoded String as defined in section 1.5.4 [MQTT-3.3.2-1].
The Topic Name in the PUBLISH packet MUST NOT contain wildcard characters [MQTT-3.3.2-2].
The Topic Name in a PUBLISH packet sent by a Server to a subscribing Client MUST match the Subscriptionâs Topic Filter according to the matching process defined in section 4.7 [MQTT-3.3.2-3].
However, as the Server is permitted to map the Topic Name to another name, it might not be the same as the Topic Name in the original PUBLISH packet.
To reduce the size of the PUBLISH packet the sender can use a Topic Alias.
The Topic Alias is described in section 3.3.2.3.4.
It is a Protocol Error if the Topic Name is zero length and there is no Topic Alias.
3.3.2.2 Packet Identifier The Packet Identifier field is only present in PUBLISH packets where the QoS level is 1 or 2.
Section 2.2.1 provides more information about Packet Identifiers.
3.3.2.3 PUBLISH Properties 3.3.2.3.1 Property Length The length of the Properties in the PUBLISH packet Variable Header encoded as a Variable Byte Integer.
3.3.2.3.2 Payload Format Indicator 1 (0x01) Byte, Identifier of the Payload Format Indicator.
Followed by the value of the Payload Forma t Indicator, either of: â¢ 0 (0x00) Byte Indicates that the Payload is unspecified bytes, which is equivalent to not sending a Payload Format Indicator.
â¢ 1 (0x01) Byte Indicates that the Payload is UTF-8 Encoded Character Data.
The UTF-8 data in the Payload MUST be well-formed UTF-8 as defined by the Unicode specification [Unicode] and restated in RFC 3629 [RFC3629].
A Server MUST send the Payload Format Indicator unaltered to all subscribers receiving the Application Message [MQTT-3.3.2-4].
The receiver MAY validate that the Payload is of the format indicated, and if it is not send a PUBACK, PUBREC, or DISCONNECT with Reason Code of 0x99 (Payload format invalid) as described in section 4.13.
Refer to section 5.4.9 for information about security issues in validating the payload format.
3.3.2.3.3 Message Expiry Interval` 2 (0x02) Byte, Identifier of the Message Expiry Interval.
Followed by the Four Byte Integer representing the Message Expiry Interval.
If present, the Four Byte value is the lifetime of the Application Message in seconds.
If the Message Expiry Interval has passed and the Server has not managed to start onward delivery to a matching subscriber, then it MUST delete the copy of the message for that subscriber [MQTT-3.3.2-5].
If absent, the Application Message does not expire.
The PUBLISH packet sent to a Client by the Server MUST contain a Message Expiry Interval set to the received value minus the time that the Application Message has been waiting in the Server [MQTT-3.3.2- 6].
Refer to section 4.1 for details and limitations of stored state.
3.3.2.3.4 Topic Alias 35 (0x23) Byte, Identifier of the Topic Alias.
Followed by the Two Byte integer representing the Topic Alias value.
It is a Protocol Error to include the Topic Alias value more than once.
A Topic Alias is an integer value that is used to identify the Topic instead of using the Topic Name.
This reduces the size of the PUBLISH packet, and is useful when the Topic Names are long and the same Topic Names are used repetitively within a Network Connection.
The sender decides whether to use a Topic Alias and chooses the value.
It sets a Topic Alias mapping by including a non-zero length Topic Name and a Topic Alias in the PUBLISH packet.
The receiver processes the PUBLISH as normal but also sets the specified Topic Alias mapping to this Topic Name.
If a Topic Alias mapping has been set at the receiver, a sender can send a PUBLISH packet that contains that Topic Alias and a zero length Topic Name.
The receiver then treats the incoming PUBLISH as if it had contained the Topic Name of the Topic Alias.
A sender can modify the Topic Alias mapping by sending another PUBLISH in the same Network Connection with the same Topic Alias value and a different non-zero length Topic Name.
Topic Alias mappings exist only within a Network Connection and last only for the lifetime of that Network Connection.
A receiver MUST NOT carry forward any Topic Alias mappings from one Network Connection to another [MQTT-3.3.2-7].
A Topic Alias of 0 is not permitted.
A sender MUST NOT send a PUBLISH packet containing a Topic Alias which has the value 0 [MQTT-3.3.2-8].
A Client MUST NOT send a PUBLISH packet with a Topic Alias greater than the Topic Alias Maximum value returned by the Server in the CONNACK packet [MQTT-3.3.2-9].
A Client MUST accept all Topic Alias values greater than 0 and less than or equal to the Topic Alias Maximum value that it sent in the CONNECT packet [MQTT-3.3.2-10].
A Server MUST NOT send a PUBLISH packet with a Topic Alias greater than the Topic Alias Maximum value sent by the Client in the CONNECT packet [MQTT-3.3.2-11].
A Server MUST accept all Topic Alias values greater than 0 and less than or equal to the Topic Alias Maximum value that it returned in the CONNACK packet [MQTT-3.3.2-12].
The Topic Alias mappings used by the Client and Server are independent from each other.
Thus, when a Client sends a PUBLISH containing a Topic Alias value of 1 to a Server and the Server sends a PUBLISH with a Topic Alias value of 1 to that Client they will in general be referring to different Topics.
3.3.2.3.5 Response Topic 8 (0x08) Byte, Identifier of the Response Topic.
Followed by a UTF-8 Encoded String which is used as the Topic Name for a response message.
The Response Topic MUST be a UTF-8 Encoded String as defined in section 1.5.4 [MQTT-3.3.2-13].
The Response Topic MUST NOT contain wildcard characters [MQTT-3.3.2-14].
It is a Protocol Error to include the Response Topic more than once.
The presence of a Response Topic identifies the Message as a Request.
Refer to section 4.10 for more information about Request / Response.
The Server MUST send the Response Topic unaltered to all subscribers receiving the Application Message [MQTT-3.3.2-15].
Non-normative comment: The receiver of an Application Message with a Response Topic sends a response by using the Response Topic as the Topic Name of a PUBLISH.
If the Request Message contains a Correlation Data, the receiver of the Request Message should also include this Correlation Data as a property in the PUBLISH packet of the Response Message.
3.3.2.3.6 Correlation Data 9 (0x09) Byte, Identifier of the Correlation Data.
Followed by Binary Data.
The Correlation Data is used by the sender of the Request Message to identify which request the Response Message is for when it is received.
It is a Protocol Error to include Correlation Data more than once.
If the Correlation Data is not present, the Requester does not require any correlation data.
The Server MUST send the Correlation Data unaltered to all subscribers receiving the Application Message [MQTT-3.3.2-16].
The value of the Correlation Data only has meaning to the sender of the Request Message and receiver of the Response Message.
Non-normative comment The receiver of an Application Message which contains both a Response Topic and a Correlation Data sends a response by using the Response Topic as the Topic Name of a PUBLISH.
The Client should also send the Correlation Data unaltered as part of the PUBLISH of the responses.
Non-normative comment If the Correlation Data contains information which can cause application failures if modified by the Client responding to the request, it should be encrypted and/or hashed to allow any alteration to be detected.
Refer to section 4.10 for more information about Request / Response 3.3.2.3.7 User Property 38 (0x26) Byte, Identifier of the User Property.
Followed by a UTF-8 String Pair.
The User Property is allowed to appear multiple times to represent multiple name, value pairs.
The same name is allowed to appear more than once.
The Server MUST send all User Properties unaltered in a PUBLISH packet when forwarding the Application Message to a Client [MQTT-3.3.2-17].
The Server MUST maintain the order of User Properties when forwarding the Application Message [MQTT-3.3.2-18].
Non-normative comment This property is intended to provide a means of transferring application layer name-value tags whose meaning and interpretation are known only by the application programs responsible for sending and receiving them.
3.3.2.3.8 Subscription Identifier 11 (0x0B), Identifier of the Subscription Identifier.
Followed by a Variable Byte Integer representing the identifier of the subscription.
The Subscription Identifier can have the value of 1 to 268,435,455.
It is a Protocol Error if the Subscription Identifier has a value of 0.
Multiple Subscription Identifiers will be included if the publication is the result of a match to more than one subscription, in this case their order is not significant.
3.3.2.3.9 Content Type 3 (0x03) Identifier of the Content Type.
Followed by a UTF-8 Encoded String describing the content of the Application Message.
The Content Type MUST be a UTF-8 Encoded String as defined in section 1.5.4 [MQTT-3.3.2-19].
It is a Protocol Error to include the Content Type more than once.
The value of the Content Type is defined by the sending and receiving application.
A Server MUST send the Content Type unaltered to all subscribers receiving the Application Message [MQTT-3.3.2-20].
Non-normative comment The UTF-8 Encoded String may use a MIME content type string to describe the contents of the Application message.
However, since the sending and receiving applications are responsible for the definition and interpretation of the string, MQTT performs no validation of the string except to insure it is a valid UTF-8 Encoded String.
The content and format of the data is application specific.
The length of the Payload can be calculated by subtracting the length of the Variable Header from the Remaining Length field that is in the Fixed Header.
It is valid for a PUBLISH packet to contain a zero length Payload.
3.3.4 PUBLISH Actions The receiver of a PUBLISH Packet MUST respond with the packet as determined by the QoS in the PUBLISH Packet [MQTT-3.3.4-1].
Table 3-3 Expected PUBLISH packet response QoS Level Expected Response QoS 0 None QoS 1 PUBACK packet QoS 2 PUBREC packet The Client uses a PUBLISH packet to send an Application Message to the Server, for distribution to Clients with matching subscriptions.
The Server uses a PUBLISH packet to send an Application Message to each Client which has a matching subscription.
The PUBLISH packet includes the Subscription Identifier carried in the SUBSCRIBE packet, if there was one.
When Clients make subscriptions with Topic Filters that include wildcards, it is possible for a Clientâs subscriptions to overlap so that a published message might match multiple filters.
In this case the Server MUST deliver the message to the Client respecting the maximum QoS of all the matching subscriptions [MQTT-3.3.4-2].
In addition, the Server MAY deliver further copies of the message, one for each additional matching subscription and respecting the subscriptionâs QoS in each case.
If a Client receives an unsolicited Application Message (not resulting from a subscription) which has a QoS greater than Maximum QoS, it uses a DISCONNECT packet with Reason Code 0x9B (QoS not supported ) as described in section 4.13 Handling errors.
If the Client specified a Subscription Identifier for any of the overlapping subscriptions the Server MUST send those Subscription Identifiers in the message which is published as the result of the subscriptions [MQTT-3.3.4-3].
If the Server sends a single copy of the message it MUST include in the PUBLISH packet the Subscription Identifiers for all matching subscriptions which have a Subscription Identifiers, their order is not significant [MQTT-3.3.4-4].
If the Server sends multiple PUBLISH packets it MUST send, in each of them, the Subscription Identifier of the matching subscription if it has a Subscription Identifier [MQTT-3.3.4-5].
It is possible that the Client made several subscriptions which match a publication and that it used the same identifier for more than one of them.
In this case the PUBLISH packet will carry multiple identical Subscription Identifiers.
It is a Protocol Error for a PUBLISH packet to contain any Subscription Identifier other than those received in SUBSCRIBE packet which caused it to flow.
A PUBLISH packet sent from a Client to a Server MUST NOT contain a Subscription Identifier [MQTT-3.3.4-6].
If the subscription was shared, then only the Subscription Identifiers that were present in the SUBSCRIBE packet from the Client which is receiving the message are returned in the PUBLISH packet.
The action of the recipient when it receives a PUBLISH packet depends on the QoS level as described in section 4.3.
If the PUBLISH packet contains a Topic Alias, the receiver processes it as follows: 1) A Topic Alias value of 0 or greater than the Maximum Topic Alias is a Protocol Error, the receiver uses DISCONNECT with Reason Code of 0x94 (Topic Alias invalid) as described in section 4.13.
2) If the receiver has already established a mapping for the Topic Alias, then a) If the packet has a zero length Topic Name, the receiver processes it using the Topic Name that corresponds to the Topic Alias b) If the packet contains a non-zero length Topic Name, the receiver processes the packet using that Topic Name and updates its mapping for the Topic Alias to the Topic Name from the incoming packet 3) If the receiver does not already have a mapping for this Topic Alias a) If the packet has a zero length Topic Name field it is a Protocol Error and the receiver uses DISCONNECT with Reason Code of 0x82 (Protocol Error) as described in section 4.13. b) If the packet contains a Topic Name with a non-zero length, the receiver processes the packet using that Topic Name and sets its mappings for the Topic Alias to Topic Name from the incoming packet.
Non-normative Comment If the Server distributes Application Messages to Clients at different protocol levels (such as MQTT V3.1.1) which do not support properties or other features provided by this specification, some information in the Application Message can be lost, and applications which depend on this information might not work correctly.
The Client MUST NOT send more than Receive Maximum QoS 1 and QoS 2 PUBLISH packets for which it has not received PUBACK, PUBCOMP, or PUBREC with a Reason Code of 128 or greater from the Server [MQTT-3.3.4-7].
If it receives more than Receive Maximum QoS 1 and QoS 2 PUBLISH packets where it has not sent a PUBACK or PUBCOMP in response, the Server uses a DISCONNECT packet with Reason Code 0x93 (Receive Maximum exceeded) as described in section 4.13 Handling errors.
Refer to section 4.9 for more information about flow control.
The Client MUST NOT delay the sending of any packets other than PUBLISH packets due to having sent Receive Maximum PUBLISH packets without receiving acknowledgements for them [MQTT-3.3.4-8].
The value of Receive Maximum applies only to the current Network Connection.
Non-normative comment The Client might choose to send fewer than Receive Maximum messages to the Server without receiving acknowledgement, even if it has more than this number of messages available to send.
Non-normative comment The Client might choose to suspend the sending of QoS 0 PUBLISH packets when it suspends the sending of QoS 1 and QoS 2 PUBLISH packets.
Non-normative comment If the Client sends QoS 1 or QoS 2 PUBLISH packets before it has received a CONNACK packet, it risks being disconnected because it has sent more than Receive Maximum publications.
The Server MUST NOT send more than Receive Maximum QoS 1 and QoS 2 PUBLISH packets for which it has not received PUBACK, PUBCOMP, or PUBREC with a Reason Code of 128 or greater from the Client [MQTT-3.3.4-9].
If it receives more than Receive Maximum QoS 1 and QoS 2 PUBLISH packets where it has not sent a PUBACK or PUBCOMP in response, the Client uses DISCONNECT with Reason Code 0x93 (Receive Maximum exceeded) as described in section 4.13 Handling errors.
Refer to section 4.9 for more information about flow control.
The Server MUST NOT delay the sending of any packets other than PUBLISH packets due to having sent Receive Maximum PUBLISH packets without receiving acknowledgements for them [MQTT-3.3.4- Non-normative comment The Server might choose to send fewer than Receive Maximum messages to the Client without receiving acknowledgement, even if it has more than this number of messages available to send.
Non-normative comment The Server might choose to suspend the sending of QoS 0 PUBLISH packets when it suspends the sending of QoS 1 and QoS 2 PUBLISH packets.
3.4 PUBACK â Publish acknowledgement A PUBACK packet is the response to a PUBLISH packet with QoS 1.
3.4.2 PUBACK Variable Header The Variable Header of the PUBACK Packet contains the following fields in the order: Packet Identifier from the PUBLISH packet that is being acknowledged, PUBACK Reason Code, Property Length, and the Properties.
The rules for encoding Properties are described in section 2.2.2.
If the Remaining Length is 2, then there is no Reason Code and the value of 0x00 (Success) is used.
Table 3-4 - PUBACK Reason Codes Value Hex Reason Code name Description 0x00 Success The message is accepted.
Publication of the QoS 1 message proceeds.
0x10 No matching subscribers The message is accepted but there are no subscribers.
This is sent only by the Server.
If the Server knows that there are no matching subscribers, it MAY use this Reason Code instead of 0x00 (Success).
0x80 Unspecified error The receiver does not accept the publish but either does not want to reveal the reason, or it does not match one of the other values.
0x83 Implementation specific error The PUBLISH is valid but the receiver is not willing to accept it.
0x87 Not authorized The PUBLISH is not authorized.
0x90 Topic Name invalid The Topic Name is not malformed, but is not accepted by this Client or Server.
0x91 Packet identifier in use The Packet Identifier is already in use.
This might indicate a mismatch in the Session State between the Client and Server.
0x97 Quota exceeded An implementation or administrative imposed limit has been exceeded.
0x99 Payload format invalid The payload format does not match the specified Payload Format Indicator.
The Client or Server sending the PUBACK packet MUST use one of the PUBACK Reason Codes [MQTT- 3.4.2-1].
The Reason Code and Property Length can be omitted if the Reason Code is 0x00 (Success) and there are no Properties.
In this case the PUBACK has a Remaining Length of 2.
3.4.2.2 PUBACK Properties 3.4.2.2.1 Property Length The length of the Properties in the PUBACK packet Variable Header encoded as a Variable Byte Integer.
If the Remaining Length is less than 4 there is no Property Length and the value of 0 is used.
3.4.2.2.2 Reason String 31 (0x1F) Byte, Identifier of the Reason String.
Followed by the UTF-8 Encoded String representing the reason associated with this response.
This Reason String is a human readable string designed for diagnostics and is not intended to be parsed by the receiver.
The sender uses this value to give additional information to the receiver.
The sender MUST NOT send this property if it would increase the size of the PUBACK packet beyond the Maximum Packet Size specified by the receiver [MQTT-3.4.2-2].
It is a Protocol Error to include the Reason String more than once.
3.4.2.2.3 User Property 38 (0x26) Byte, Identifier of the User Property.
Followed by UTF-8 String Pair.
This property can be used to provide additional diagnostic or other information.
The sender MUST NOT send this property if it would increase the size of the PUBACK packet beyond the Maximum Packet Size specified by the receiver [MQTT-3.4.2-3].
The User Property is allowed to appear multiple times to represent multiple name, value pairs.
The same name is allowed to appear more than once.
3.4.3 PUBACK Payload The PUBACK packet has no Payload.
3.4.4 PUBACK Actions This is described in section 4.3.2.
3.5 PUBREC â Publish received (QoS 2 delivery part 1) A PUBREC packet is the response to a PUBLISH packet with QoS 2.
It is the second packet of the QoS 2 protocol exchange.
3.5.2 PUBREC Variable Header The Variable Header of the PUBREC Packet consists of the following fields in the order: the Packet Identifier from the PUBLISH packet that is being acknowledged, PUBREC Reason Code, and Properties.
The rules for encoding Properties are described in section 2.2.2.
If the Remaining Length is 2, then the Publish Reason Code has the value 0x00 (Success).
Table 3-5 â PUBREC Reason Codes Value Hex Reason Code name Description 0x00 Success The message is accepted.
Publication of the QoS 2 message proceeds.
0x10 No matching subscribers.
The message is accepted but there are no subscribers.
This is sent only by the Server.
If the Server knows that there are no matching subscribers, it MAY use this Reason Code instead of 0x00 (Success).
0x80 Unspecified error The receiver does not accept the publish but either does not want to reveal the reason, or it does not match one of the other values.
0x83 Implementation specific error The PUBLISH is valid but the receiver is not willing to accept it.
0x87 Not authorized The PUBLISH is not authorized.
0x90 Topic Name invalid The Topic Name is not malformed, but is not accepted by this Client or Server.
0x91 Packet Identifier in use The Packet Identifier is already in use.
This might indicate a mismatch in the Session State between the Client and Server.
0x97 Quota exceeded An implementation or administrative imposed limit has been exceeded.
0x99 Payload format invalid The payload format does not match the one specified in the Payload Format Indicator.
The Client or Server sending the PUBREC packet MUST use one of the PUBREC Reason Code values.
[MQTT-3.5.2-1].
The Reason Code and Property Length can be omitted if the Reason Code is 0x00 (Success) and there are no Properties.
In this case the PUBREC has a Remaining Length of 2.
3.5.2.2 PUBREC Properties 3.5.2.2.1 Property Length The length of the Properties in the PUBREC packet Variable Header encoded as a Variable Byte Integer.
If the Remaining Length is less than 4 there is no Property Length and the value of 0 is used.
3.5.2.2.2 Reason String 31 (0x1F) Byte, Identifier of the Reason String.
Followed by the UTF-8 Encoded String representing the reason associated with this response.
This Reason String is human readable, designed for diagnostics and SHOULD NOT be parsed by the receiver.
The sender uses this value to give additional information to the receiver.
The sender MUST NOT send this property if it would increase the size of the PUBREC packet beyond the Maximum Packet Size specified by the receiver [MQTT-3.5.2-2].
It is a Protocol Error to include the Reason String more than once.
3.5.2.2.3 User Property 38 (0x26) Byte, Identifier of the User Property.
Followed by UTF-8 String Pair.
This property can be used to provide additional diagnostic or other information.
The sender MUST NOT send this property if it would increase the size of the PUBREC packet beyond the Maximum Packet Size specified by the receiver [MQTT-3.5.2-3].
The User Property is allowed to appear multiple times to represent multiple name, value pairs.
The same name is allowed to appear more than once.
3.5.3 PUBREC Payload The PUBREC packet has no Payload.
3.5.4 PUBREC Actions This is described in section 4.3.3.
3.6 PUBREL â Publish release (QoS 2 delivery part 2) A PUBREL packet is the response to a PUBREC packet.
It is the third packet of the QoS 2 protocol exchange.
The Server MUST treat any other value as malformed and close the Network Connection [MQTT-3.6.1-1].
Remaining Length field This is the length of the Variable Header, encoded as a Variable Byte Integer.
3.6.2 PUBREL Variable Header The Variable Header of the PUBREL Packet contains the following fields in the order: the Packet Identifier from the PUBREC packet that is being acknowledged, PUBREL Reason Code, and Properties.
The rules for encoding Properties are described in section 2.2.2.
If the Remaining Length is 2, the value of 0x00 (Success) is used.
Table 3-6 - PUBREL Reason Codes Value Hex Reason Code name Description 0x00 Success Message released.
0x92 Packet Identifier not found The Packet Identifier is not known.
This is not an error during recovery, but at other times indicates a mismatch between the Session State on the Client and Server.
The Client or Server sending the PUBREL packet MUST use one of the PUBREL Reason Code values [MQTT-3.6.2-1].
The Reason Code and Property Length can be omitted if the Reason Code is 0x00 (Success) and there are no Properties.
In this case the PUBREL has a Remaining Length of 2.
3.6.2.2 PUBREL Properties 3.6.2.2.1 Property Length The length of the Properties in the PUBREL packet Variable Header encoded as a Variable Byte Integer.
If the Remaining Length is less than 4 there is no Property Length and the value of 0 is used.
3.6.2.2.2 Reason String 31 (0x1F) Byte, Identifier of the Reason String.
Followed by the UTF-8 Encoded String representing the reason associated with this response.
This Reason String is human readable, designed for diagnostics and SHOULD NOT be parsed by the receiver.
The sender uses this value to give additional information to the receiver.
The sender MUST NOT send this Property if it would increase the size of the PUBREL packet beyond the Maximum Packet Size specified by the receiver [MQTT-3.6.2-2].
It is a Protocol Error to include the Reason String more than once.
3.6.2.2.3 User Property 38 (0x26) Byte, Identifier of the User Property.
Followed by UTF-8 String Pair.
This property can be used to provide additional diagnostic or other information for the PUBREL.
The sender MUST NOT send this property if it would increase the size of the PUBREL packet beyond the Maximum Packet Size specified by the receiver [MQTT-3.6.2-3].
The User Property is allowed to appear multiple times to represent multiple name, value pairs.
The same name is allowed to appear more than once.
3.6.3 PUBREL Payload The PUBREL packet has no Payload.
3.6.4 PUBREL Actions This is described in section 4.3.3.
3.7 PUBCOMP â Publish complete (QoS 2 delivery part 3) The PUBCOMP packet is the response to a PUBREL packet.
It is the fourth and final packet of the QoS 2 protocol exchange.
3.7.2 PUBCOMP Variable Header The Variable Header of the PUBCOMP Packet contains the following fields in the order: Packet Identifier from the PUBREL packet that is being acknowledged, PUBCOMP Reason Code, and Properties.
The rules for encoding Properties are described in section 2.2.2.
If the Remaining Length is 2, then the value 0x00 (Success) is used.
Table 3-7 â PUBCOMP Reason Codes Value Hex Reason Code name Description 0x00 Success Packet Identifier released.
Publication of QoS 2 message is complete.
0x92 Packet Identifier not found The Packet Identifier is not known.
This is not an error during recovery, but at other times indicates a mismatch between the Session State on the Client and Server.
The Client or Server sending the PUBCOMP packet MUST use one of the PUBCOMP Reason Code values [MQTT-3.7.2-1].
The Reason Code and Property Length can be omitted if the Reason Code is 0x00 (Success) and there are no Properties.
In this case the PUBCOMP has a Remaining Length of 2.
3.7.2.2 PUBCOMP Properties 3.7.2.2.1 Property Length The length of the Properties in the PUBCOMP packet Variable Header encoded as a Variable Byte Integer.
If the Remaining Length is less than 4 there is no Property Length and the value of 0 is used.
3.7.2.2.2 Reason String 31 (0x1F) Byte, Identifier of the Reason String.
Followed by the UTF-8 Encoded String representing the reason associated with this response.
This Reason String is a human readable string designed for diagnostics and SHOULD NOT be parsed by the receiver.
The sender uses this value to give additional information to the receiver.
The sender MUST NOT send this Property if it would increase the size of the PUBCOMP packet beyond the Maximum Packet Size specified by the receiver [MQTT-3.7.2-2].
It is a Protocol Error to include the Reason String more than once.
3.7.2.2.3 User Property 38 (0x26) Byte, Identifier of the User Property.
Followed by UTF-8 String Pair.
This property can be used to provide additional diagnostic or other information.
The sender MUST NOT send this property if it would increase the size of the PUBCOMP packet beyond the Maximum Packet Size specified by the receiver [MQTT-3.7.2-3].
The User Property is allowed to appear multiple times to represent multiple name, value pairs.
The same name is allowed to appear more than once.
3.7.3 PUBCOMP Payload The PUBCOMP packet has no Payload.
3.7.4 PUBCOMP Actions This is described in section 4.3.3.
3.8 SUBSCRIBE - Subscribe request The SUBSCRIBE packet is sent from the Client to the Server to create one or more Subscriptions.
Each Subscription registers a Clientâs interest in one or more Topics.
The Server sends PUBLISH packets to the Client to forward Application Messages that were published to Topics that match these Subscriptions.
The SUBSCRIBE packet also specifies (for each Subscription) the maximum QoS with which the Server can send Application Messages to the Client.
The Server MUST treat any other value as malformed and close the Network Connection [MQTT-3.8.1-1].
Remaining Length field This is the length of Variable Header plus the length of the Payload, encoded as a Variable Byte Integer.
3.8.2 SUBSCRIBE Variable Header The Variable Header of the SUBSCRIBE Packet contains the following fields in the order: Packet Identifier, and Properties.
Section 2.2.1 provides more information about Packet Identifiers.
The rules for encoding Properties are described in section 2.2.2.
3.8.2.1.2 Subscription Identifier 11 (0x0B) Byte, Identifier of the Subscription Identifier.
Followed by a Variable Byte Integer representing the identifier of the subscription.
The Subscription Identifier can have the value of 1 to 268,435,455.
It is a Protocol Error if the Subscription Identifier has a value of 0.
It is a Protocol Error to include the Subscription Identifier more than once.
The Subscription Identifier is associated with any subscription created or modified as the result of this SUBSCRIBE packet.
If there is a Subscription Identifier, it is stored with the subscription.
If this property is not specified, then the absence of a Subscription Identifier is stored with the subscription.
Refer to section 3.8.3.1 for more information about the handling of Subscription Identifiers.
3.8.2.1.3 User Property 38 (0x26) Byte, Identifier of the User Property.
Followed by a UTF-8 String Pair.
The User Property is allowed to appear multiple times to represent multiple name, value pairs.
The same name is allowed to appear more than once.
Non-normative comment User Properties on the SUBSCRIBE packet can be used to send subscription related properties from the Client to the Server.
The meaning of these properties is not defined by this specification.
3.8.3 SUBSCRIBE Payload The Payload of a SUBSCRIBE packet contains a list of Topic Filters indicating the Topics to which the Client wants to subscribe.
The Topic Filters MUST be a UTF-8 Encoded String [MQTT-3.8.3-1].
Each Topic Filter is followed by a Subscription Options byte.
The Payload MUST contain at least one Topic Filter and Subscription Options pair [MQTT-3.8.3-2].
A SUBSCRIBE packet with no Payload is a Protocol Error.
Refer to section 4.13 for information about handling errors.
3.8.3.1 Subscription Options Bits 0 and 1 of the Subscription Options represent Maximum QoS field.
This gives the maximum QoS level at which the Server can send Application Messages to the Client.
It is a Protocol Error if the Maximum QoS field has the value 3.
Bit 2 of the Subscription Options represents the No Local option.
If the value is 1, Application Messages MUST NOT be forwarded to a connection with a ClientID equal to the ClientID of the publishing connection [MQTT-3.8.3-3].
It is a Protocol Error to set the No Local bit to 1 on a Shared Subscription [MQTT-3.8.3-4].
Bit 3 of the Subscription Options represents the Retain As Published option.
If 1, Application Messages forwarded using this subscription keep the RETAIN flag they were published with.
If 0, Application Messages forwarded using this subscription have the RETAIN flag set to 0.
Retained messages sent when the subscription is established have the RETAIN flag set to 1.
Bits 4 and 5 of the Subscription Options represent the Retain Handling option.
This option specifies whether retained messages are sent when the subscription is established.
This does not affect the sending of retained messages at any point after the subscribe.
If there are no retained messages matching the Topic Filter, all of these values act the same.
The values are: 0 = Send retained messages at the time of the subscribe 1 = Send retained messages at subscribe only if the subscription does not currently exist 2 = Do not send retained messages at the time of the subscribe It is a Protocol Error to send a Retain Handling value of 3.
Bits 6 and 7 of the Subscription Options byte are reserved for future use.
The Server MUST treat a SUBSCRIBE packet as malformed if any of Reserved bits in the Payload are non-zero [MQTT-3.8.3-5].
Non-normative comment The No Local and Retain As Published subscription options can be used to implement bridging where the Client is sending the message on to another Server.
Non-normative comment Not sending retained messages for an existing subscription is useful when a reconnect is done and the Client is not certain whether the subscriptions were completed in the previous connection to the Session.
Non-normative comment Not sending stored retained messages because of a new subscription is useful where a Client wishes to receive change notifications and does not need to know the initial state.
Non-normative comment For a Server that indicates it does not support retained messages, all valid values of Retain As Published and Retain Handling give the same result which is to not send any retained messages at subscribe and to set the RETAIN flag to 0 for all messages.
NL means No Local.
The first is âa/bâ with QoS 1, and the second is âc/dâ with QoS 2.
The SUBACK packet MUST have the same Packet Identifier as the SUBSCRIBE packet that it is acknowledging [MQTT-3.8.4-2].
The Server is permitted to start sending PUBLISH packets matching the Subscription before the Server sends the SUBACK packet.
If a Server receives a SUBSCRIBE packet containing a Topic Filter that is identical to a Non-shared Subscriptionâs Topic Filter for the current Session, then it MUST replace that existing Subscription with a new Subscription [MQTT-3.8.4-3].
The Topic Filter in the new Subscription will be identical to that in the previous Subscription, although its Subscription Options could be different.
If the Retain Handling option is 0, any existing retained messages matching the Topic Filter MUST be re-sent, but Applicaton Messages MUST NOT be lost due to replacing the Subscription [MQTT-3.8.4-4].
If a Server receives a Non-shared Topic Filter that is not identical to any Topic Filter for the current Session, a new Non-shared Subscription is created.
If the Retain Handling option is not 2, all matching retained messages are sent to the Client.
If a Server receives a Topic Filter that is identical to the Topic Filter for a Shared Subscription that already exists on the Server, the Session is added as a subscriber to that Shared Subscription.
No retained messages are sent.
If a Server receives a Shared Subscription Topic Filter that is not identical to any existing Shared Subscriptionâs Topic Filter, a new Shared Subscription is created.
The Session is added as a subscriber to that Shared Subscription.
No retained messages are sent.
Refer to section 4.8 for more details on Shared Subscriptions.
If a Server receives a SUBSCRIBE packet that contains multiple Topic Filters it MUST handle that packet as if it had received a sequence of multiple SUBSCRIBE packets, except that it combines their responses into a single SUBACK response [MQTT-3.8.4-5].
The SUBACK packet sent by the Server to the Client MUST contain a Reason Code for each Topic Filter/Subscription Option pair [MQTT-3.8.4-6].
This Reason Code MUST either show the maximum QoS that was granted for that Subscription or indicate that the subscription failed [MQTT-3.8.4-7].
The Server might grant a lower Maximum QoS than the subscriber requested.
The QoS of Application Messages sent in response to a Subscription MUST be the minimum of the QoS of the originally published message and the Maximum QoS granted by the Server [MQTT-3.8.4-8].
The server is permitted to send duplicate copies of a message to a subscriber in the case where the original message was published with QoS 1 and the maximum QoS granted was QoS 0.
Non-normative comment If a subscribing Client has been granted maximum QoS 1 for a particular Topic Filter, then a QoS 0 Application Message matching the filter is delivered to the Client at QoS 0.
This means that at most one copy of the message is received by the Client.
On the other hand, a QoS 2 Message published to the same topic is downgraded by the Server to QoS 1 for delivery to the Client, so that Client might receive duplicate copies of the Message.
Non-normative comment If the subscribing Client has been granted maximum QoS 0, then an Application Message originally published as QoS 2 might get lost on the hop to the Client, but the Server should never send a duplicate of that Message.
A QoS 1 Message published to the same topic might either get lost or duplicated on its transmission to that Client.
Non-normative comment Subscribing to a Topic Filter at QoS 2 is equivalent to saying "I would like to receive Messages matching this filter at the QoS with which they were published".
This means a publisher is responsible for determining the maximum QoS a Message can be delivered at, but a subscriber is able to require that the Server downgrades the QoS to one more suitable for its usage.
The Subscription Identifiers are part of the Session State in the Server and are returned to the Client receiving a matching PUBLISH packet.
They are removed from the Serverâs Session State when the Server receives an UNSUBSCRIBE packet, when the Server receives a SUBSCRIBE packet from the Client for the same Topic Filter but with a different Subscription Identifier or with no Subscription Identifier, or when the Server sends Session Present 0 in a CONNACK packet.
The Subscription Identifiers do not form part of the Clientâs Session State in the Client.
In a useful implementation, a Client will associate the Subscription Identifiers with other Client side state, this state is typically removed when the Client unsubscribes, when the Client subscribes for the same Topic Filter with a different identifier or no identifier, or when the Client receives Session Present 0 in a CONNACK packet.
The Server need not use the same set of Subscription Identifiers in the retransmitted PUBLISH packet.
The Client can remake a Subscription by sending a SUBSCRIBE packet containing a Topic Filter that is identical to the Topic Filter of an existing Subscription in the current Session.
If the Client remade a subscription after the initial transmission of a PUBLISH packet and used a different Subscription Identifier, then the Server is allowed to use the identifiers from the first transmission in any retransmission.
Alternatively, the Server is allowed to use the new identifiers during a retransmission.
The Server is not allowed to revert to the old identifier after it has sent a PUBLISH packet containing the new one.
Non-normative comment Usage scenarios, for illustration of Subscription Identifiers.
â¢ The Client implementation indicates via its programming interface that a publication matched more than one subscription.
The Client implementation generates a new identifier each time a subscription is made.
If the returned publication carries more than one Subscription Identifier, then the publication matched more than one subscription.
â¢ The Client implementation allows the subscriber to direct messages to a callback associated with the subscription.
The Client implementation generates an identifier which uniquely maps the identifier to the callback.
When a publication is received it uses the Subscription Identifier to determine which callback is driven.
â¢ The Client implementation returns the topic string used to make the subscription to the application when it delivers the published message.
To achieve this the Client generates an identifier which uniquely identifies the Topic Filter.
When a publication is received the Client implementation uses the identifiers to look up the original Topic Filters and return them to the Client application.
â¢ A gateway forwards publications received from a Server to Clients that have made subscriptions to the gateway.
The gateway implementation maintains a map of each unique Topic Filter it receives to the set of ClientID, Subscription Identifier pairs that it also received.
It generates a unique identifier for each Topic Filter that it forwards to the Server.
When a publication is received, the gateway uses the Subscription Identifiers it received from the Server to look up the Client Identifier, Subscription Identifier pairs associated with them.
It adds these to the PUBLISH packets it sends to the Clients.
If the upstream Server sent multiple PUBLISH packets because the message matched multiple subscriptions, then this behavior is mirrored to the Clients.
3.9 SUBACK â Subscribe acknowledgement A SUBACK packet is sent by the Server to the Client to confirm receipt and processing of a SUBSCRIBE packet.
A SUBACK packet contains a list of Reason Codes, that specify the maximum QoS level that was granted or the error which was found for each Subscription that was requested by the SUBSCRIBE.
3.9.2 SUBACK Variable Header The Variable Header of the SUBACK Packet contains the following fields in the order: the Packet Identifier from the SUBSCRIBE Packet that is being acknowledged, and Properties.
3.9.2.1 SUBACK Properties 3.9.2.1.1 Property Length The length of Properties in the SUBACK packet Variable Header encoded as a Variable Byte Integer 3.9.2.1.2 Reason String 31 (0x1F) Byte, Identifier of the Reason String.
Followed by the UTF-8 Encoded String representing the reason associated with this response.
This Reason String is a human readable string designed for diagnostics and SHOULD NOT be parsed by the Client.
The Server uses this value to give additional information to the Client.
The Server MUST NOT send this Property if it would increase the size of the SUBACK packet beyond the Maximum Packet Size specified by the Client [MQTT-3.9.2-1].
It is a Protocol Error to include the Reason String more than once.
3.9.2.1.3 User Property 38 (0x26) Byte, Identifier of the User Property.
Followed by UTF-8 String Pair.
This property can be used to provide additional diagnostic or other information.
The Server MUST NOT send this property if it would increase the size of the SUBACK packet beyond the Maximum Packet Size specified by Client [MQTT-3.9.2-2].
The User Property is allowed to appear multiple times to represent multiple name, value pairs.
The same name is allowed to appear more than once.
Each Reason Code corresponds to a Topic Filter in the SUBSCRIBE packet being acknowledged.
The order of Reason Codes in the SUBACK packet MUST match the order of Topic Filters in the SUBSCRIBE packet [MQTT-3.9.3-1].
Table 3-8 - Subscribe Reason Codes Value Hex Reason Code name Description 0x00 Granted QoS 0 The subscription is accepted and the maximum QoS sent will be QoS 0.
This might be a lower QoS than was requested.
0x01 Granted QoS 1 The subscription is accepted and the maximum QoS sent will be QoS 1.
This might be a lower QoS than was requested.
0x02 Granted QoS 2 The subscription is accepted and any received QoS will be sent to this subscription.
0x80 Unspecified error The subscription is not accepted and the Server either does not wish to reveal the reason or none of the other Reason Codes apply.
0x83 Implementation specific The SUBSCRIBE is valid but the Server does not accept it.
error 0x87 Not authorized The Client is not authorized to make this subscription.
0x8F Topic Filter invalid The Topic Filter is correctly formed but is not allowed for this Client.
0x91 Packet Identifier in use The specified Packet Identifier is already in use.
0x97 Quota exceeded An implementation or administrative imposed limit has been exceeded.
0x9E Shared Subscriptions not The Server does not support Shared Subscriptions for this Client.
supported 0xA1 Subscription Identifiers not The Server does not support Subscription Identifiers; the supported subscription is not accepted.
0xA2 Wildcard Subscriptions not The Server does not support Wildcard Subscriptions; the supported subscription is not accepted.
The Server sending a SUBACK packet MUST use one of the Subscribe Reason Codes for each Topic Filter received [MQTT-3.9.3-2].
Non-normative comment There is always one Reason Code for each Topic Filter in the corresponding SUBSCRIBE packet.
If the Reason Code is not specific to a Topic Filters (such as 0x91 (Packet Identifier in use)) it is set for each Topic Filter.
3.10 UNSUBSCRIBE â Unsubscribe request An UNSUBSCRIBE packet is sent by the Client to the Server, to unsubscribe from topics.
The Server MUST treat any other value as malformed and close the Network Connection [MQTT-3.10.1-1].
Remaining Length field This is the length of Variable Header (2 bytes) plus the length of the Payload, encoded as a Variable Byte Integer.
3.10.2 UNSUBSCRIBE Variable Header The Variable Header of the UNSUBSCRIBE Packet contains the following fields in the order: Packet Identifier, and Properties.
Section 2.2.1 provides more information about Packet Identifiers.
The rules for encoding Properties are described in section 2.2.2.
3.10.2.1 UNSUBSCRIBE Properties 3.10.2.1.1 Property Length The length of Properties in the UNSUBSCRIBE packet Variable Header encoded as a Variable Byte Integer.
3.10.2.1.2 User Property 38 (0x26) Byte, Identifier of the User Property.
Followed by a UTF-8 String Pair.
The User Property is allowed to appear multiple times to represent multiple name, value pairs.
The same name is allowed to appear more than once.
Non-normative comment User Properties on the UNSUBSCRIBE packet can be used to send subscription related properties from the Client to the Server.
The meaning of these properties is not defined by this specification.
3.10.3 UNSUBSCRIBE Payload The Payload for the UNSUBSCRIBE packet contains the list of Topic Filters that the Client wishes to unsubscribe from.
The Topic Filters in an UNSUBSCRIBE packet MUST be UTF-8 Encoded Strings [MQTT-3.10.3-1] as defined in section 1.5.4, packed contiguously.
The Payload of an UNSUBSCRIBE packet MUST contain at least one Topic Filter [MQTT-3.10.3-2].
An UNSUBSCRIBE packet with no Payload is a Protocol Error.
Refer to section 4.13 for information about handling errors.
If any filter matches exactly then its owning Subscription MUST be deleted [MQTT-3.10.4-1], otherwise no additional processing occurs.
When a Server receives UNSUBSCRIBE : â¢ It MUST stop adding any new messages which match the Topic Filters, for delivery to the Client [MQTT-3.10.4-2].
â¢ It MUST complete the delivery of any QoS 1 or QoS 2 messages which match the Topic Filters and it has started to send to the Client [MQTT-3.10.4-3].
â¢ It MAY continue to deliver any existing messages buffered for delivery to the Client.
The Server MUST respond to an UNSUBSCRIBE request by sending an UNSUBACK packet [MQTT- 3.10.4-4].
The UNSUBACK packet MUST have the same Packet Identifier as the UNSUBSCRIBE packet.
Even where no Topic Subscriptions are deleted, the Server MUST respond with an UNSUBACK [MQTT- If a Server receives an UNSUBSCRIBE packet that contains multiple Topic Filters, it MUST process that packet as if it had received a sequence of multiple UNSUBSCRIBE packets, except that it sends just one UNSUBACK response [MQTT-3.10.4-6].
If a Topic Filter represents a Shared Subscription, this Session is detached from the Shared Subscription.
If this Session was the only Session that the Shared Subscription was associated with, the Shared Subscription is deleted.
Refer to section 4.8.2 for a description of Shared Subscription handling.
3.11 UNSUBACK â Unsubscribe acknowledgement The UNSUBACK packet is sent by the Server to the Client to confirm receipt of an UNSUBSCRIBE packet.
3.11.2 UNSUBACK Variable Header The Variable Header of the UNSUBACK Packet the following fields in the order: the Packet Identifier from the UNSUBSCRIBE Packet that is being acknowledged, and Properties.
The rules for encoding Properties are described in section 2.2.2.
3.11.2.1.2 Reason String 31 (0x1F) Byte, Identifier of the Reason String.
Followed by the UTF-8 Encoded String representing the reason associated with this response.
This Reason String is a human readable string designed for diagnostics and SHOULD NOT be parsed by the Client.
The Server uses this value to give additional information to the Client.
The Server MUST NOT send this Property if it would increase the size of the UNSUBACK packet beyond the Maximum Packet Size specified by the Client [MQTT-3.11.2-1].
It is a Protocol Error to include the Reason String more than once.
3.11.2.1.3 User Property 38 (0x26) Byte, Identifier of the User Property.
Followed by UTF-8 String Pair.
This property can be used to provide additional diagnostic or other information.
The Server MUST NOT send this property if it would increase the size of the UNSUBACK packet beyond the Maximum Packet Size specified by the Client [MQTT-3.11.2-2].
The User Property is allowed to appear multiple times to represent multiple name, value pairs.
The same name is allowed to appear more than once.
3.11.3 UNSUBACK Payload The Payload contains a list of Reason Codes.
Each Reason Code corresponds to a Topic Filter in the UNSUBSCRIBE packet being acknowledged.
The order of Reason Codes in the UNSUBACK packet MUST match the order of Topic Filters in the UNSUBSCRIBE packet [MQTT-3.11.3-1].
The values for the one byte unsigned Unsubscribe Reason Codes are shown below.
The Server sending an UNSUBACK packet MUST use one of the Unsubscribe Reason Code values for each Topic Filter received [MQTT-3.11.3-2].
Table 3-9 - Unsubscribe Reason Codes Value Hex Reason Code name Description 0x00 Success The subscription is deleted.
0x11 No subscription existed No matching Topic Filter is being used by the Client.
0x80 Unspecified error The unsubscribe could not be completed and the Server either does not wish to reveal the reason or none of the other Reason Codes apply.
0x83 Implementation specific error The UNSUBSCRIBE is valid but the Server does not accept it.
0x87 Not authorized The Client is not authorized to unsubscribe.
0x8F Topic Filter invalid The Topic Filter is correctly formed but is not allowed for this Client.
0x91 Packet Identifier in use The specified Packet Identifier is already in use.
Non-normative comment There is always one Reason Code for each Topic Filter in the corresponding UNSUBSCRIBE packet.
If the Reason Code is not specific to a Topic Filters (such as 0x91 (Packet Identifier in use)) it is set for each Topic Filter.
3.12 PINGREQ â PING request The PINGREQ packet is sent from a Client to the Server.
It can be used to: â¢ Indicate to the Server that the Client is alive in the absence of any other MQTT Control Packets being sent from the Client to the Server.
â¢ Request that the Server responds to confirm that it is alive.
â¢ Exercise the network to indicate that the Network Connection is active.
This packet is used in Keep Alive processing.
Refer to section 3.1.2.10 for more details.
3.12.3 PINGREQ Payload The PINGREQ packet has no Payload.
3.12.4 PINGREQ Actions The Server MUST send a PINGRESP packet in response to a PINGREQ packet [MQTT-3.12.4-1].
3.13 PINGRESP â PING response A PINGRESP Packet is sent by the Server to the Client in response to a PINGREQ packet.
It indicates that the Server is alive.
This packet is used in Keep Alive processing.
Refer to section 3.1.2.10 for more details.
3.13.3 PINGRESP Payload The PINGRESP packet has no Payload.
3.13.4 PINGRESP Actions The Client takes no action on receiving this packet 3.14 DISCONNECT â Disconnect notification The DISCONNECT packet is the final MQTT Control Packet sent from the Client or the Server.
It indicates the reason why the Network Connection is being closed.
The Client or Server MAY send a DISCONNECT packet before closing the Network Connection.
If the Network Connection is closed without the Client first sending a DISCONNECT packet with Reason Code 0x00 (Normal disconnection) and the Connection has a Will Message, the Will Message is published.
Refer to section 3.1.2.5 for further details.
A Server MUST NOT send a DISCONNECT until after it has sent a CONNACK with Reason Code of less than 0x80 [MQTT-3.14.0-1].
If they are not zero it sends a DISCONNECT packet with a Reason code of 0x81 (Malformed Packet) as described in section 4.13 [MQTT-3.14.1-1].
Remaining Length field This is the length of the Variable Header encoded as a Variable Byte Integer.
3.14.2 DISCONNECT Variable Header The Variable Header of the DISCONNECT Packet contains the following fields in the order: Disconnect Reason Code, and Properties.
The rules for encoding Properties are described in section 2.2.2.
3.14.2.1 Disconnect Reason Code Byte 1 in the Variable Header is the Disconnect Reason Code.
If the Remaining Length is less than 1 the value of 0x00 (Normal disconnection) is used.
The values for the one byte unsigned Disconnect Reason Code field are shown below.
Table 3-10 â Disconnect Reason Code values Value Hex Reason Code name Sent by Description 0x00 Normal disconnection Client or Close the connection normally.
Do not send Server the Will Message.
0x04 Disconnect with Will Client The Client wishes to disconnect but requires Message that the Server also publishes its Will Message.
0x80 Unspecified error Client or The Connection is closed but the sender either Server does not wish to reveal the reason, or none of the other Reason Codes apply.
0x81 Malformed Packet Client or The received packet does not conform to this Server specification.
0x82 Protocol Error Client or An unexpected or out of order packet was Server received.
0x83 Implementation specific Client or The packet received is valid but cannot be error Server processed by this implementation.
0x87 Not authorized Server The request is not authorized.
0x89 Server busy Server The Server is busy and cannot continue processing requests from this Client.
0x8B Server shutting down Server The Server is shutting down.
0x8D Keep Alive timeout Server The Connection is closed because no packet has been received for 1.5 times the Keepalive time.
0x8E Session taken over Server Another Connection using the same ClientID has connected causing this Connection to be closed.
0x8F Topic Filter invalid Server The Topic Filter is correctly formed, but is not accepted by this Sever.
0x90 Topic Name invalid Client or The Topic Name is correctly formed, but is not Server accepted by this Client or Server.
0x93 Receive Maximum Client or The Client or Server has received more than exceeded Server Receive Maximum publication for which it has not sent PUBACK or PUBCOMP.
0x94 Topic Alias invalid Client or The Client or Server has received a PUBLISH Server packet containing a Topic Alias which is greater than the Maximum Topic Alias it sent in the CONNECT or CONNACK packet.
0x95 Packet too large Client or The packet size is greater than Maximum Server Packet Size for this Client or Server.
0x96 Message rate too high Client or The received data rate is too high.
Server 0x97 Quota exceeded Client or An implementation or administrative imposed Server limit has been exceeded.
0x98 Administrative action Client or The Connection is closed due to an Server administrative action.
0x99 Payload format invalid Client or The payload format does not match the one Server specified by the Payload Format Indicator.
0x9A Retain not supported Server The Server has does not support retained messages.
0x9B QoS not supported Server The Client specified a QoS greater than the QoS specified in a Maximum QoS in the CONNACK.
0x9C Use another server Server The Client should temporarily change its Server.
0x9D Server moved Server The Server is moved and the Client should permanently change its server location.
0x9E Shared Subscriptions not Server The Server does not support Shared supported Subscriptions.
0x9F Connection rate exceeded Server This connection is closed because the connection rate is too high.
0xA0 Maximum connect time Server The maximum connection time authorized for this connection has been exceeded.
0xA1 Subscription Identifiers not Server The Server does not support Subscription supported Identifiers; the subscription is not accepted.
0xA2 Wildcard Subscriptions not Server The Server does not support Wildcard supported Subscriptions; the subscription is not accepted.
The Client or Server sending the DISCONNECT packet MUST use one of the DISCONNECT Reason Code values [MQTT-3.14.2-1].
The Reason Code and Property Length can be omitted if the Reason Code is 0x00 (Normal disconnecton) and there are no Properties.
In this case the DISCONNECT has a Remaining Length of 0.
Non-normative comment The DISCONNECT packet is used to indicate the reason for a disconnect for cases where there is no acknowledge packet (such as a QoS 0 publish) or when the Client or Server is unable to continue processing the Connection.
Non-normative comment The information can be used by the Client to decide whether to retry the connection, and how long it should wait before retrying the connection.
3.14.2.2 DISCONNECT Properties 3.14.2.2.1 Property Length The length of Properties in the DISCONNECT packet Variable Header encoded as a Variable Byte Integer.
If the Remaining Length is less than 2, a value of 0 is used.
3.14.2.2.2 Session Expiry Interval 17 (0x11) Byte, Identifier of the Session Expiry Interval.
Followed by the Four Byte Integer representing the Session Expiry Interval in seconds.
It is a Protocol Error to include the Session Expiry Interval more than once.
If the Session Expiry Interval is absent, the Session Expiry Interval in the CONNECT packet is used.
The Session Expiry Interval MUST NOT be sent on a DISCONNECT by the Server [MQTT-3.14.2-2].
If the Session Expiry Interval in the CONNECT packet was zero, then it is a Protocol Error to set a non- zero Session Expiry Interval in the DISCONNECT packet sent by the Client.
If such a non-zero Session Expiry Interval is received by the Server, it does not treat it as a valid DISCONNECT packet.
The Server uses DISCONNECT with Reason Code 0x82 (Protocol Error) as described in section 4.13.
3.14.2.2.3 Reason String 31 (0x1F) Byte, Identifier of the Reason String.
Followed by the UTF-8 Encoded String representing the reason for the disconnect.
This Reason String is human readable, designed for diagnostics and SHOULD NOT be parsed by the receiver.
The sender MUST NOT send this Property if it would increase the size of the DISCONNECT packet beyond the Maximum Packet Size specified by the receiver [MQTT-3.14.2-3].
It is a Protocol Error to include the Reason String more than once.
3.14.2.2.4 User Property 38 (0x26) Byte, Identifier of the User Property.
Followed by UTF-8 String Pair.
This property may be used to provide additional diagnostic or other information.
The sender MUST NOT send this property if it would increase the size of the DISCONNECT packet beyond the Maximum Packet Size specified by the receiver [MQTT-3.14.2-4].
The User Property is allowed to appear multiple times to represent multiple name, value pairs.
The same name is allowed to appear more than once.
3.14.2.2.5 Server Reference 28 (0x1C) Byte, Identifier of the Server Reference.
Followed by a UTF-8 Encoded String which can be used by the Client to identify another Server to use.
It is a Protocol Error to include the Server Reference more than once.
The Server sends DISCONNECT including a Server Reference and Reason Code 0x9C (Use another server) or 0x9D (Server moved) as described in section 4.13.
Refer to section 4.11 Server Redirection for information about how Server Reference is used.
3.14.4 DISCONNECT Actions After sending a DISCONNECT packet the sender: â¢ MUST NOT send any more MQTT Control Packets on that Network Connection [MQTT-3.14.4-1].
â¢ MUST close the Network Connection [MQTT-3.14.4-2].
On receipt of DISCONNECT with a Reason Code of 0x00 (Success) the Server: â¢ MUST discard any Will Message associated with the current Connection without publishing it [MQTT-3.14.4-3], as described in section 3.1.2.5.
On receipt of DISCONNECT, the receiver: â¢ SHOULD close the Network Connection.
3.15 AUTH â Authentication exchange An AUTH packet is sent from Client to Server or Server to Client as part of an extended authentication exchange, such as challenge / response authentication.
It is a Protocol Error for the Client or Server to send an AUTH packet if the CONNECT packet did not contain the same Authentication Method.
The Client or Server MUST treat any other value as malformed and close the Network Connection [MQTT- Remaining Length field This is the length of the Variable Header encoded as a Variable Byte Integer.
3.15.2 AUTH Variable Header The Variable Header of the AUTH Packet contains the following fields in the order: Authenticate Reason Code, and Properties.
The rules for encoding Properties are described in section 2.2.2.
3.15.2.1 Authenticate Reason Code Byte 0 in the Variable Header is the Authenticate Reason Code.
The values for the one byte unsigned Authenticate Reason Code field are shown below.
The sender of the AUTH Packet MUST use one of the Authenticate Reason Codes [MQTT-3.15.2-1].
Table 3-11 Authenticate Reason Codes Value Hex Reason Code name Sent by Description 0x00 Success Server Authentication is successful 0x18 Continue authentication Client or Continue the authentication with another step Server 0x19 Re-authenticate Client Initiate a re-authentication The Reason Code and Property Length can be omitted if the Reason Code is 0x00 (Success) and there are no Properties.
In this case the AUTH has a Remaining Length of 0.
3.15.2.2 AUTH Properties 3.15.2.2.1 Property Length The length of Properties in the AUTH packet Variable Header encoded as a Variable Byte Integer.
3.15.2.2.2 Authentication Method 21 (0x15) Byte, Identifier of the Authentication Method.
Followed by a UTF-8 Encoded String containing the name of the authentication method.
It is a Protocol Error to omit the Authentication Method or to include it more than once.
Refer to section 4.12 for more information about extended authentication.
3.15.2.2.3 Authentication Data 22 (0x16) Byte, Identifier of the Authentication Data.
Followed by Binary Data containing authentication data.
It is a Protocol Error to include Authentication Data more than once.
The contents of this data are defined by the authentication method.
Refer to section 4.12 for more information about extended authentication.
3.15.2.2.4 Reason String 31 (0x1F) Byte, Identifier of the Reason String.
Followed by the UTF-8 Encoded String representing the reason for the disconnect.
This Reason String is human readable, designed for diagnostics and SHOULD NOT be parsed by the receiver.
The sender MUST NOT send this property if it would increase the size of the AUTH packet beyond the Maximum Packet Size specified by the receiver [MQTT-3.15.2-2].
It is a Protocol Error to include the Reason String more than once.
3.15.2.2.5 User Property 38 (0x26) Byte, Identifier of the User Property.
Followed by UTF-8 String Pair.
This property may be used to provide additional diagnostic or other information.
The sender MUST NOT send this property if it would increase the size of the AUTH packet beyond the Maximum Packet Size specified by the receiver [MQTT-3.15.2-3].
The User Property is allowed to appear multiple times to represent multiple name, value pairs.
The same name is allowed to appear more than once.
3.15.3 AUTH Payload The AUTH packet has no Payload.
3.15.4 AUTH Actions Refer to section 4.12 for more information about extended authentication.
Operational behavior 4.1 Session State In order to implement QoS 1 and QoS 2 protocol flows the Client and Server need to associate state with the Client Identifier, this is referred to as the Session State.
The Server also stores the subscriptions as part of the Session State.
The session can continue across a sequence of Network Connections.
It lasts as long as the latest Network Connection plus the Session Expiry Interval.
The Session State in the Client consists of: â¢ QoS 1 and QoS 2 messages which have been sent to the Server, but have not been completely acknowledged.
â¢ QoS 2 messages which have been received from the Server, but have not been completely acknowledged.
The Session State in the Server consists of: â¢ The existence of a Session, even if the rest of the Session State is empty.
â¢ The Clients subscriptions, including any Subscription Identifiers.
â¢ QoS 1 and QoS 2 messages which have been sent to the Client, but have not been completely acknowledged.
â¢ QoS 1 and QoS 2 messages pending transmission to the Client and OPTIONALLY QoS 0 messages pending transmission to the Client.
â¢ QoS 2 messages which have been received from the Client, but have not been completely acknowledged.The Will Message and the Will Delay Interval â¢ If the Session is currently not connected, the time at which the Session will end and Session State will be discarded.
Retained messages do not form part of the Session State in the Server, they are not deleted as a result of a Session ending.
4.1.1 Storing Session State The Client and Server MUST NOT discard the Session State while the Network Connection is open [MQTT-4.1.0-1].
The Server MUST discard the Session State when the Network Connection is closed and the Session Expiry Interval has passed [MQTT-4.1.0-2].
Non-normative comment The storage capabilities of Client and Server implementations will of course have limits in terms of capacity and may be subject to administrative policies.
Stored Session State can be discarded as a result of an administrator action, including an automated response to defined conditions.
This has the effect of terminating the Session.
These actions might be prompted by resource constraints or for other operational reasons.
It is possible that hardware or software failures may result in loss or corruption of Session State stored by the Client or Server.
It is prudent to evaluate the storage capabilities of the Client and Server to ensure that they are sufficient.
4.1.2 Session State non-normative examples For example, an electricity meter reading solution might use QoS 1 messages to protect the readings against loss over the network.
The solution developer might have determined that the power supply is sufficiently reliable that, in this case, the data in the Client and Server can be stored in volatile memory without too much risk of its loss.
Conversely a parking meter payment application provider might decide that the payment messages should never be lost due to a network or Client failure.
Thus, they require that all data be written to non- volatile memory before it is transmitted across the network.
4.2 Network Connections The MQTT protocol requires an underlying transport that provides an ordered, lossless, stream of bytes from the Client to Server and Server to Client.
This specification does not require the support of any specific transport protocol.
A Client or Server MAY support any of the transport protocols listed here, or any other transport protocol that meets the requirements of this section.
A Client or Server MUST support the use of one or more underlying transport protocols that provide an ordered, lossless, stream of bytes from the Client to Server and Server to Client [MQTT-4.2-1].
Non-normative comment TCP/IP as defined in [RFC0793] can be used for MQTT v5.0.
The following transport protocols are also suitable: â¢ TLS [RFC5246] â¢ WebSocket [RFC6455] Non-normative comment TCP ports 8883 and 1883 are registered with IANA for MQTT TLS and non-TLS communication respectively.
Non-normative comment Connectionless network transports such as User Datagram Protocol (UDP) are not suitable on their own because they might lose or reorder data.
4.3 Quality of Service levels and protocol flows MQTT delivers Application Messages according to the Quality of Service (QoS) levels defined in the following sections.
The delivery protocol is symmetric, in the description below the Client and Server can each take the role of either sender or receiver.
The delivery protocol is concerned solely with the delivery of an application message from a single sender to a single receiver.
When the Server is delivering an Application Message to more than one Client, each Client is treated independently.
The QoS level used to deliver an Application Message outbound to the Client could differ from that of the inbound Application Message.
4.3.1 QoS 0: At most once delivery The message is delivered according to the capabilities of the underlying network.
No response is sent by the receiver and no retry is performed by the sender.
The message arrives at the receiver either once or not at all.
In the QoS 0 delivery protocol, the sender â¢ MUST send a PUBLISH packet with QoS 0 and DUP flag set to 0 [MQTT-4.3.1-1].
In the QoS 0 delivery protocol, the receiver â¢ Accepts ownership of the message when it receives the PUBLISH packet.
A QoS 1 PUBLISH packet has a Packet Identifier in its Variable Header and is acknowledged by a PUBACK packet.
Section 2.2.1 provides more information about Packet Identifiers.
In the QoS 1 delivery protocol, the sender â¢ MUST assign an unused Packet Identifier each time it has a new Application Message to publish [MQTT-4.3.2-1].
â¢ MUST send a PUBLISH packet containing this Packet Identifier with QoS 1 and DUP flag set to 0 [MQTT-4.3.2-2].
â¢ MUST treat the PUBLISH packet as âunacknowledgedâ until it has received the corresponding PUBACK packet from the receiver.
Refer to section 4.4 for a discussion of unacknowledged messages [MQTT-4.3.2-3].
The Packet Identifier becomes available for reuse once the sender has received the PUBACK packet.
Note that a sender is permitted to send further PUBLISH packets with different Packet Identifiers while it is waiting to receive acknowledgements.
In the QoS 1 delivery protocol, the receiver â¢ MUST respond with a PUBACK packet containing the Packet Identifier from the incoming PUBLISH packet, having accepted ownership of the Application Message [MQTT-4.3.2-4].
â¢ After it has sent a PUBACK packet the receiver MUST treat any incoming PUBLISH packet that contains the same Packet Identifier as being a new Application Message, irrespective of the setting of its DUP flag [MQTT-4.3.2-5].
When its original sender receives the PUBACK packet, ownership of the Application Message is transferred to the receiver.
4.3.3 QoS 2: Exactly once delivery This is the highest Quality of Service level, for use when neither loss nor duplication of messages are acceptable.
There is an increased overhead associated with QoS 2.
A QoS 2 message has a Packet Identifier in its Variable Header.
Section 2.2.1 provides more information about Packet Identifiers.
The receiver of a QoS 2 PUBLISH packet acknowledges receipt with a two-step acknowledgement process.
In the QoS 2 delivery protocol, the sender: â¢ MUST assign an unused Packet Identifier when it has a new Application Message to publish [MQTT-4.3.3-1].
â¢ MUST send a PUBLISH packet containing this Packet Identifier with QoS 2 and DUP flag set to 0 [MQTT-4.3.3-2].
â¢ MUST treat the PUBLISH packet as âunacknowledgedâ until it has received the corresponding PUBREC packet from the receiver [MQTT-4.3.3-3].
Refer to section 4.4 for a discussion of unacknowledged messages.
â¢ MUST send a PUBREL packet when it receives a PUBREC packet from the receiver with a Reason Code value less than 0x80.
This PUBREL packet MUST contain the same Packet Identifier as the original PUBLISH packet [MQTT-4.3.3-4].
â¢ MUST treat the PUBREL packet as âunacknowledgedâ until it has received the corresponding PUBCOMP packet from the receiver [MQTT-4.3.3-5].
â¢ MUST NOT re-send the PUBLISH once it has sent the corresponding PUBREL packet [MQTT- â¢ MUST NOT apply Message expiry if a PUBLISH packet has been sent [MQTT-4.3.3-7].
The Packet Identifier becomes available for reuse once the sender has received the PUBCOMP packet or a PUBREC with a Reason Code of 0x80 or greater.
Note that a sender is permitted to send further PUBLISH packets with different Packet Identifiers while it is waiting to receive acknowledgements, subject to flow control as described in section 4.9.
In the QoS 2 delivery protocol, the receiver: â¢ MUST respond with a PUBREC containing the Packet Identifier from the incoming PUBLISH packet, having accepted ownership of the Application Message [MQTT-4.3.3-8].
â¢ If it has sent a PUBREC with a Reason Code of 0x80 or greater, the receiver MUST treat any subsequent PUBLISH packet that contains that Packet Identifier as being a new Application Message [MQTT-4.3.3-9].
â¢ Until it has received the corresponding PUBREL packet, the receiver MUST acknowledge any subsequent PUBLISH packet with the same Packet Identifier by sending a PUBREC.
It MUST NOT cause duplicate messages to be delivered to any onward recipients in this case [MQTT- â¢ MUST respond to a PUBREL packet by sending a PUBCOMP packet containing the same Packet Identifier as the PUBREL [MQTT-4.3.3-11].
â¢ After it has sent a PUBCOMP, the receiver MUST treat any subsequent PUBLISH packet that contains that Packet Identifier as being a new Application Message [MQTT-4.3.3-12].
â¢ MUST continue the QoS 2 acknowledgement sequence even if it has applied message expiry [MQTT-4.3.3-13].
4.4 Message delivery retry When a Client reconnects with Clean Start set to 0 and a session is present, both the Client and Server MUST resend any unacknowledged PUBLISH packets (where QoS > 0) and PUBREL packets using their original Packet Identifiers.
This is the only circumstance where a Client or Server is REQUIRED to resend messages.
Clients and Servers MUST NOT resend messages at any other time [MQTT-4.4.0-1].
If PUBACK or PUBREC is received containing a Reason Code of 0x80 or greater the corresponding PUBLISH packet is treated as acknowledged, and MUST NOT be retransmitted [MQTT-4.4.0-2].
When its original sender receives the PUBREC packet, ownership of the Application Message is transferred to the receiver.
However, the receiver needs to perform all checks for conditions which might result in a forwarding failure (e.g.
quota exceeded, authorization, etc.)
before accepting ownership.
The receiver indicates success or failure using the appropriate Reason Code in the PUBREC.
4.5 Message receipt When a Server takes ownership of an incoming Application Message it MUST add it to the Session State for those Clients that have matching Subscriptions [MQTT-4.5.0-1].
Matching rules are defined in section Under normal circumstances Clients receive messages in response to Subscriptions they have created.
A Client could also receive messages that do not match any of its explicit Subscriptions.
This can happen if the Server automatically assigned a subscription to the Client.
A Client could also receive messages while an UNSUBSCRIBE operation is in progress.
The Client MUST acknowledge any Publish packet it receives according to the applicable QoS rules regardless of whether it elects to process the Application Message that it contains [MQTT-4.5.0-2].
4.6 Message ordering The following these rules apply to the Client when implementing the protocol flows defined in section 4.3.
â¢ When the Client re-sends any PUBLISH packets, it MUST re-send them in the order in which the original PUBLISH packets were sent (this applies to QoS 1 and QoS 2 messages) [MQTT-4.6.0- â¢ The Client MUST send PUBACK packets in the order in which the corresponding PUBLISH packets were received (QoS 1 messages) [MQTT-4.6.0-2] â¢ The Client MUST send PUBREC packets in the order in which the corresponding PUBLISH packets were received (QoS 2 messages) [MQTT-4.6.0-3] â¢ The Client MUST send PUBREL packets in the order in which the corresponding PUBREC packets were received (QoS 2 messages) [MQTT-4.6.0-4] An Ordered Topic is a Topic where the Client can be certain that the Application Messages in that Topic from the same Client and at the same QoS are received are in the order they were published.
When a Server processes a message that has been published to an Ordered Topic, it MUST send PUBLISH packets to consumers (for the same Topic and QoS) in the order that they were received from any given Client [MQTT-4.6.0-5].
This is addition to the rules listed above.
By default, a Server MUST treat every Topic as an Ordered Topic when it is forwarding messages on Non-shared Subscriptions.
[MQTT-4.6.0-6].
A Server MAY provide an administrative or other mechanism to allow one or more Topics to not be treated as an Ordered Topic.
Non-normative comment The rules listed above ensure that when a stream of messages is published and subscribed to an Ordered Topic with QoS 1, the final copy of each message received by the subscribers will be in the order that they were published.
If the message is re-sent the duplicate message can be received after one of the earlier messages is received.
For example, a publisher might send messages in the order 1,2,3,4 but the subscriber might receive them in the order 1,2,3,2,3,4 if there is a network disconnection after message 3 has been sent.
If both Client and Server set Receive Maximum to 1, they make sure that no more than one message is âin-flightâ at any one time.
In this case no QoS 1 message will be received after any later one even on re-connection.
For example a subscriber might receive them in the order 1,2,3,3,4 but not 1,2,3,2,3,4.
Refer to section 4.9 Flow Control for details of how the Receive Maximum is used.
4.7 Topic Names and Topic Filters 4.7.1 Topic wildcards The topic level separator is used to introduce structure into the Topic Name.
If present, it divides the Topic Name into multiple âtopic levelsâ.
A subscriptionâs Topic Filter can contain special wildcard characters, which allow a Client to subscribe to multiple topics at once.
The wildcard characters can be used in Topic Filters, but MUST NOT be used within a Topic Name [MQTT-4.7.0-1].
4.7.1.1 Topic level separator The forward slash (â/â U+002F) is used to separate each level within a topic tree and provide a hierarchical structure to the Topic Names.
The use of the topic level separator is significant when either of the two wildcard characters is encountered in Topic Filters specified by subscribing Clients.
Topic level separators can appear anywhere in a Topic Filter or Topic Name.
Adjacent Topic level separators indicate a zero- length topic level.
4.7.1.2 Multi-level wildcard The number sign (â#â U+0023) is a wildcard character that matches any number of levels within a topic.
The multi-level wildcard represents the parent and any number of child levels.
The multi-level wildcard character MUST be specified either on its own or following a topic level separator.
In either case it MUST be the last character specified in the Topic Filter [MQTT-4.7.1-1].
Non-normative comment For example, if a Client subscribes to âsport/tennis/player1/#â, it would receive messages published using these Topic Names: â¢ âsport/tennis/player1â â¢ âsport/tennis/player1/ranking â¢ âsport/tennis/player1/score/wimbledonâ Non-normative comment â¢ âsport/#â also matches the singular âsportâ, since # includes the parent level.
â¢ â#â is valid and will receive every Application Message â¢ âsport/tennis/#â is valid â¢ âsport/tennis#â is not valid â¢ âsport/tennis/#/rankingâ is not valid 4.7.1.3 Single-level wildcard The plus sign (â+â U+002B) is a wildcard character that matches only one topic level.
The single-level wildcard can be used at any level in the Topic Filter, including first and last levels.
Where it is used, it MUST occupy an entire level of the filter [MQTT-4.7.1-2].
It can be used at more than one level in the Topic Filter and can be used in conjunction with the multi-level wildcard.
Non-normative comment For example, âsport/tennis/+â matches âsport/tennis/player1â and âsport/tennis/player2â, but not âsport/tennis/player1/rankingâ.
Also, because the single-level wildcard matches only a single level, âsport/+â does not match âsportâ but it does match âsport/â.
â¢ â+â is valid â¢ â+/tennis/#â is valid â¢ âsport+â is not valid â¢ âsport/+/player1â is valid â¢ â/financeâ matches â+/+â and â/+â, but not â+â 4.7.2 Topics beginning with $ The Server MUST NOT match Topic Filters starting with a wildcard character (# or +) with Topic Names beginning with a $ character [MQTT-4.7.2-1].
The Server SHOULD prevent Clients from using such Topic Names to exchange messages with other Clients.
Server implementations MAY use Topic Names that start with a leading $ character for other purposes.
Non-normative comment â¢ $SYS/ has been widely adopted as a prefix to topics that contain Server-specific information or control APIs â¢ Applications cannot use a topic with a leading $ character for their own purposes Non-normative comment â¢ A subscription to â#â will not receive any messages published to a topic beginning with a $ â¢ A subscription to â+/monitor/Clientsâ will not receive any messages published to â$SYS/monitor/Clientsâ â¢ A subscription to â$SYS/#â will receive messages published to topics beginning with â$SYS/â â¢ A subscription to â$SYS/monitor/+â will receive messages published to â$SYS/monitor/Clientsâ â¢ For a Client to receive messages from topics that begin with $SYS/ and from topics that donât begin with a $, it has to subscribe to both â#â and â$SYS/#â 4.7.3 Topic semantic and usage The following rules apply to Topic Names and Topic Filters: â¢ All Topic Names and Topic Filters MUST be at least one character long [MQTT-4.7.3-1] â¢ Topic Names and Topic Filters are case sensitive â¢ Topic Names and Topic Filters can include the space character â¢ A leading or trailing â/â creates a distinct Topic Name or Topic Filter â¢ A Topic Name or Topic Filter consisting only of the â/â character is valid â¢ Topic Names and Topic Filters MUST NOT include the null character (Unicode U+0000) [Unicode] [MQTT-4.7.3-2] â¢ Topic Names and Topic Filters are UTF-8 Encoded Strings; they MUST NOT encode to more than 65,535 bytes [MQTT-4.7.3-3].
Refer to section 1.5.4.
There is no limit to the number of levels in a Topic Name or Topic Filter, other than that imposed by the overall length of a UTF-8 Encoded String.
When it performs subscription matching the Server MUST NOT perform any normalization of Topic Names or Topic Filters, or any modification or substitution of unrecognized characters [MQTT-4.7.3-4].
Each non-wildcarded level in the Topic Filter has to match the corresponding level in the Topic Name character for character for the match to succeed.
Non-normative comment The UTF-8 encoding rules mean that the comparison of Topic Filter and Topic Name could be performed either by comparing the encoded UTF-8 bytes, or by comparing decoded Unicode characters Non-normative comment â¢ âACCOUNTSâ and âAccountsâ are two different Topic Names â¢ âAccounts payableâ is a valid Topic Name â¢ â/financeâ is different from âfinanceâ An Application Message is sent to each Client Subscription whose Topic Filter matches the Topic Name attached to an Application Message.
The topic resource MAY be either predefined in the Server by an administrator or it MAY be dynamically created by the Server when it receives the first subscription or an Application Message with that Topic Name.
The Server MAY also use a security component to authorize particular actions on the topic resource for a given Client.
4.8 Subscriptions MQTT provides two kinds of Subscription, Shared and Non-shared.
Non-normative comment In earlier versions of MQTT all Subscriptions are Non-shared.
4.8.1 Non-shared Subscriptions A Non-shared Subscription is associated only with the MQTT Session that created it.
Each Subscription includes a Topic Filter, indicating the topic(s) for which messages are to be delivered on that Session, and Subscription Options.
The Server is responsible for collecting messages that match the filter and transmitting them on the Session's MQTT connection if and when that connection is active.
A Session cannot have more than one Non-shared Subscription with the same Topic Filter, so the Topic Filter can be used as a key to identify the subscription within that Session.
If there are multiple Clients, each with its own Non-shared Subscription to the same Topic, each Client gets its own copy of the Application Messages that are published on that Topic.
This means that the Non-shared Subscriptions cannot be used to load-balance Application Messages across multiple consuming Clients as in such cases every message is delivered to every subscribing Client.
4.8.2 Shared Subscriptions A Shared Subscription can be associated with multiple subscribing MQTT Sessions.
Like a Non-shared Subscription, it has a Topic Filter and Subscription Options; however, a publication that matches its Topic Filter is only sent to one of its subscribing Sessions.
Shared Subscriptions are useful where several consuming Clients share the processing of the publications in parallel.
A Shared Subscription is identified using a special style of Topic Filter.
The format of this filter is: $share/{ShareName}/{filter} â¢ $share is a literal string that marks the Topic Filter as being a Shared Subscription Topic Filter.
â¢ {ShareName} is a character string that does not include "/", "+" or "#" â¢ {filter} The remainder of the string has the same syntax and semantics as a Topic Filter in a non- shared subscription.
Refer to section 4.7.
A Shared Subscription's Topic Filter MUST start with $share/ and MUST contain a ShareName that is at least one character long [MQTT-4.8.2-1].
The ShareName MUST NOT contain the characters "/", "+" or "#", but MUST be followed by a "/" character.
This "/" character MUST be followed by a Topic Filter [MQTT-4.8.2-2] as described in section 4.7.
Non-normative comment Shared Subscriptions are defined at the scope of the MQTT Server, rather than of a Session.
A ShareName is included in the Shared Subscription's Topic Filter so that there can be more than one Shared Subscription on a Server that has the same {filter} component.
Typically, applications use the ShareName to represent the group of subscribing Sessions that are sharing the subscription.
Examples: â¢ Shared subscriptions "$share/consumer1/sport/tennis/+" and "$share/consumer2/sport/tennis/+" are distinct shared subscriptions and so can be associated with different groups of Sessions.
Both of them match the same topics as a non- shared subscription to sport/tennis/+ .
If a message were to be published that matches sport/tennis/+ then a copy would be sent to exactly one of the Sessions subscribed to $share/consumer1/sport/tennis/+ , a separate copy of the message would be sent to exactly one of the Sessions subscribed to $share/consumer2/sport/tennis/+ and further copies would be sent to any Clients with non- shared subscriptions to sport/tennis/+ â¢ Shared subscription "$share/consumer1//finance" matches the same topics as a non-shared subscription to /finance.
Note that "$share/consumer1//finance" and "$share/consumer1/sport/tennis/+" are distinct shared subscriptions, even though they have the same ShareName.
While they might be related in some way, no specific relationship between them is implied by them having the same ShareName.
A Shared Subscription is created by using a Shared Subscription Topic Filter in a SUBSCRIBE request.
So long as only one Session subscribes to a particular Shared Subscription, the shared subscription behaves like a non-shared subscription, except that: â¢ The $share and {ShareName} portions of the Topic Filter are not taken into account when matching against publications.
â¢ No Retained Messages are sent to the Session when it first subscribes.
It will be sent other matching messages as they are published.
Once a Shared Subscription exists, it is possible for other Sessions to subscribe with the same Shared Subscription Topic Filter.
The new Session is associated with the Shared Subscription as an additional subscriber.
Retained messages are not sent to this new subscriber.
Each subsequent Application Message that matches the Shared Subscription is now sent to one and only one of the Sessions that are subscribed to the Shared Subscription.
A Session can explicitly detach itself from a Shared Subscription by sending an UNSUBSCRIBE Packet that contains the full Shared Subscription Topic Filter.
Sessions are also detached from the Shared Subscription when they terminate.
A Shared Subscription lasts for as long as it is associated with at least one Session (i.e.
a Session that has issued a successful SUBSCRIBE request to its Topic Filter and that has not completed a corresponding UNSUBSCRIBE).
A Shared Subscription survives when the Session that originally created it unsubscribes, unless there are no other Sessions left when this happens.
A Shared Subscription ends, and any undelivered messages associated with it are deleted, when there are no longer any Sessions subscribed to it.
Notes on Shared Subscriptions â¢ If there's more than one Session subscribed to the Shared Subscription, the Server implementation is free to choose, on a message by message basis, which Session to use and what criteria it uses to make this selection.
â¢ Different subscribing Clients are permitted to ask for different Requested QoS levels in their SUBSCRIBE packets.
The Server decides which Maximum QoS to grant to each Client, and it is permitted to grant different Maximum QoS levels to different subscribers.
When sending an Application Message to a Client, the Server MUST respect the granted QoS for the Client's subscription [MQTT-4.8.2-3], in the same that it does when sending a message to a -Subscriber.
â¢ If the Server is in the process of sending a QoS 2 message to its chosen subscribing Client and the connection to the Client breaks before delivery is complete, the Server MUST complete the delivery of the message to that Client when it reconnects [MQTT-4.8.2-4] as described in section 4.3.3.
If the Client's Session terminates before the Client reconnects, the Server MUST NOT send the Application Message to any other subscribed Client [MQTT-4.8.2-5].
â¢ If the Server is in the process of sending a QoS 1 message to its chosen subscribing Client and the connection to that Client breaks before the Server has received an acknowledgement from the Client, the Server MAY wait for the Client to reconnect and retransmit the message to that Client.
If the Client'sSession terminates before the Client reconnects, the Server SHOULD send the Application Message to another Client that is subscribed to the same Shared Subscription.
It MAY attempt to send the message to another Client as soon as it loses its connection to the first Client.
â¢ If a Client responds with a PUBACK or PUBREC containing a Reason Code of 0x80 or greater to a PUBLISH packet from the Server, the Server MUST discard the Application Message and not attempt to send it to any other Subscriber [MQTT-4.8.2-6].
â¢ A Client is permitted to submit a second SUBSCRIBE request to a Shared Subscription on a Session that's already subscribed to that Shared Subscription.
For example, it might do this to change the Requested QoS for its subscription or because it was uncertain that the previous subscribe completed before the previous connection was closed.
This does not increase the number of times that the Session is associated with the Shared Subscription, so the Session will leave the Shared Subscription on its first UNSUBSCRIBE.
â¢ Each Shared Subscription is independent from any other.
It is possible to have two Shared Subscriptions with overlapping filters.
In such cases a message that matches both Shared Subscriptions will be processed separately by both of them.
If a Client has a Shared Subscription and a Non-shared Subscription and a message matches both of them, the Client will receive a copy of the message by virtue of it having the Non-shared Subscription.
A second copy of the message will be delivered to one of the subscribers to the Shared Subscription, and this could result in a second copy being sent to this Client.
4.9 Flow Control Clients and Servers control the number of unacknowledged PUBLISH packets they receive by using a Receive Maximum value as described in section 3.1.2.11.4 and section 3.2.2.3.2.
The Receive Maximum establishes a send quota which is used to limit the number of PUBLISH QOS > 0 packets which can be sent without receiving an PUBACK (for QoS 1) or PUBCOMP (for QoS 2).
The PUBACK and PUBCOMP replenish the quota in the manner described below.
The Client or Server MUST set its initial send quota to a non-zero value not exceeding the Receive Maximum [MQTT-4.9.0-1].
Each time the Client or Server sends a PUBLISH packet at QoS > 0, it decrements the send quota.
If the send quota reaches zero, the Client or Server MUST NOT send any more PUBLISH packets with QoS > 0 [MQTT-4.9.0-2].
It MAY continue to send PUBLISH packets with QoS 0, or it MAY choose to suspend sending these as well.
The Client and Server MUST continue to process and respond to all other MQTT Control Packets even if the quota is zero [MQTT-4.9.0-3].
The send quota is incremented by 1: â¢ Each time a PUBACK or PUBCOMP packet is received, regardless of whether the PUBACK or PUBCOMP carried an error code.
â¢ Each time a PUBREC packet is received with a Return Code of 0x80 or greater.
The send quota is not incremented if it is already equal to the initial send quota.
The attempt to increment above the initial send quota might be caused by the re-transmission of a PUBREL packet after a new Network Connection is established.
Refer to section 3.3.4 for a description of how Clients and Servers react if they are sent more PUBLISH packets than the Receive Maximum allows.
The send quota and Receive Maximum value are not preserved across Network Connections, and are re- initialized with each new Network Connection as described above.
They are not part of the session state.
4.10 Request / Response Some applications or standards might wish to run a Request/Response interaction over MQTT.
This version of MQTT includes three properties that can be used for this purpose: â¢ Response Topic, described in section 3.3.2.3.5 â¢ Correlation Data, described in section 3.3.2.3.6 â¢ Request Response Information, described in section 3.1.2.11.7 â¢ Response Information, described in section 3.2.2.3.14 The following non-normative sections describe how these properties can be used.
A Client sends a Request Message by publishing an Application Message which has a Response Topic set as described in section 3.3.2.3.5.
The Request can include a Correlation Data property as described in section 3.3.2.3.6.
4.10.1 Basic Request Response (non-normative) Request/Response interaction proceeds as follows: 1.
An MQTT Client (the Requester) publishes a Request Message to a topic.
A Request Message is an Application Message with a Response Topic.
Another MQTT Client (the Responder) has subscribed to a Topic Filter which matches the Topic Name used when the Request Message was published.
As a result, it receives the Request Message.
There could be multiple Responders subscribed to this Topic Name or there could be none.
The Responder takes the appropriate action based on the Request Message, and then publishes a Response Message to the Topic Name in the Response Topic property that was carried in the Request Message.
In typical usage the Requester has subscribed to the Response Topic and thereby receives the Response Message.
However, some other Client might be subscribed to the Response Topic in which case the Response Message will also be received and processed by that Client.
As with the Request Message, the topic on which the Response Message is sent could be subscribed to by multiple Clients, or by none.
If the Request Message contains a Correlation Data property, the Responder copies this property into the Response Message and this is used by the receiver of the Response Message to associate the Response Message with the original request.
The Response Message does not include a Response Topic property.
The MQTT Server forwards the Response Topic and Correlation Data Property in the Request Message and the Correlation Data in the Response Message.
The Server treats the Request Message and the Response Message like any other Application Message.
The Requester normally subscribes to the Response Topic before publishing a Request Message.
If there are no subscribers to the Response Topic when the Response Message is sent, the Response Message will not be delivered to any Client.
The Request Message and Response Message can be of any QoS, and the Responder can be using a Session with a non-zero Session Expiry Interval.
It is common to send Request Messages at QoS 0 and only when the Responder is expected to be connected.
However, this is not necessary.
The Responder can use a Shared Subscription to allow for a pool of responding Clients.
Note however that when using Shared Subscriptions that the order of message delivery is not guaranteed between multiple Clients.
It is the responsibility of the Requester to make sure it has the necessary authority to publish to the request topic, and to subscribe to the Topic Name that it sets in the Response Topic property.
It is the responsibility of the Responder to make sure it has the authority to subscribe to the request topic and publish to the Response Topic.
While topic authorization is outside of this specification, it is recommended that Servers implement such authorization.
4.10.2 Determining a Response Topic value (non-normative) Requesters can determine a Topic Name to use as their Response Topic in any manner they choose including via local configuration.
To avoid clashes between different Requesters, it is desirable that the Response Topic used by a Requester Client be unique to that Client.
As the Requester and Responder commonly need to be authorized to these topics, it can be an authorization challenge to use a random Topic Name.
To help with this problem, this specification defines a property in the CONNACK packet called Response Information.
The Server can use this property to guide the Client in its choice for the Response Topic to use.
This mechanism is optional for both the Client and the Server.
At connect time, the Client requests that the Server send a Response Information by setting the Request Response Information property in the CONNECT packet.
This causes the Server to insert a Response Information property (a UTF-8 Encoded String) sent in the CONNACK packet.
This specification does not define the contents of the Response Information but it could be used to pass a globally unique portion of the topic tree which is reserved for that Client for at least the lifetime of its Session.
Using this mechanism allows this configuration to be done once in the Server rather than in each Client.
Refer to section 3.1.2.11.7 for the definition of the Response Information.
4.11 Server redirection A Server can request that the Client uses another Server by sending CONNACK or DISCONNECT with Reason Codes 0x9C (Use another server), or 0x9D (Server moved) as described in section 4.13.
When sending one of these Reason Codes, the Server MAY also include a Server Reference property to indicate the location of the Server or Servers the Client SHOULD use.
The Reason Code 0x9C (Use another server) specifies that the Client SHOULD temporarily switch to using another Server.
The other Server is either already known to the Client, or is specified using a Server Reference.
The Reason Code 0x9D (Server moved) specifies that the Client SHOULD permanently switch to using another Server.
The other Server is either already known to the Client, or is specified using a Server Reference.
The Server Reference is a UTF-8 Encoded String.
The value of this string is a space separated list of references.
The format of references is not specified here.
Non-normative comment It is recommended that each reference consists of a name optionally followed by a colon and a port number.
If the name contains a colon the name string can be enclosed within square brackets (â[â and â]â).
A name enclosed by square brackets cannot contain the right square bracket (â]â) character.
This is used to represent an IPv6 literal address which uses colon separators.
This is a simplified version of an URI authority as described in [RFC3986].
Non-normative comment The name within a Server Reference commonly represents a host name, DNS name [RFC1035], SRV name [RFC2782] , or literal IP address.
The value following the colon separator is commonly a port number in decimal.
This is not needed where the port information comes from the name resolution (such as with SRV) or is defaulted.
Non-normative comment If multiple references are given, the expectation is that that Client will choose one of them.
Non-normative comment Examples of the Server Reference are: myserver.xyz.org myserver.xyz.org:8883 10.10.151.22:8883 [fe80::9610:3eff:fe1c]:1883 The Server is allowed to not ever send a Server Reference, and the Client is allowed to ignore a Server Reference.
This feature can be used to allow for load balancing, Server relocation, and Client provisioning to a Server.
4.12 Enhanced authentication The MQTT CONNECT packet supports basic authentication of a Network Connection using the User Name and Password fields.
While these fields are named for a simple password authentication, they can be used to carry other forms of authentication such as passing a token as the Password.
Enhanced authentication extends this basic authentication to include challenge / response style authentication.
It might involve the exchange of AUTH packets between the Client and the Server after the CONNECT and before the CONNACK packets.
To begin an enhanced authentication, the Client includes an Authentication Method in the CONNECT packet.
This specifies the authentication method to use.
If the Server does not support the Authentication Method supplied by the Client, it MAY send a CONNACK with a Reason Code of 0x8C (Bad authentication method) or 0x87 (Not Authorized) as described in section 4.13 and MUST close the Network Connection [MQTT-4.12.0-1].
The Authentication Method is an agreement between the Client and Server about the meaning of the data sent in the Authentication Data and any of the other fields in CONNECT, and the exchanges and processing needed by the Client and Server to complete the authentication.
Non-normative comment The Authentication Method is commonly a SASL mechanism, and using such a registered name aids interchange.
However, the Authentication Method is not constrained to using registered SASL mechanisms.
If the Authentication Method selected by the Client specifies that the Client sends data first, the Client SHOULD include an Authentication Data property in the CONNECT packet.
This property can be used to provide data as specified by the Authentication Method.
The contents of the Authentication Data are defined by the authentication method.
If the Server requires additional information to complete the authentication, it can send an AUTH packet to the Client.
This packet MUST contain a Reason Code of 0x18 (Continue authentication) [MQTT-4.12.0- 2].
If the authentication method requires the Server to send authentication data to the Client, it is sent in the Authentication Data.
The Client responds to an AUTH packet from the Server by sending a further AUTH packet.
This packet MUST contain a Reason Code of 0x18 (Continue authentication) [MQTT-4.12.0-3].
If the authentication method requires the Client to send authentication data for the Server, it is sent in the Authentication Data.
The Client and Server exchange AUTH packets as needed until the Server accepts the authentication by sending a CONNACK with a Reason Code of 0.
If the acceptance of the authentication requires data to be sent to the Client, it is sent in the Authentication Data.
The Client can close the connection at any point in this process.
It MAY send a DISCONNECT packet before doing so.
The Server can reject the authentication at any point in this process.
It MAY send a CONNACK with a Reason Code of 0x80 or above as described in section 4.13, and MUST close the Network Connection [MQTT-4.12.0-4].
If the initial CONNECT packet included an Authentication Method property then all AUTH packets, and any successful CONNACK packet MUST include an Authentication Method Property with the same value as in the CONNECT packet [MQTT-4.12.0-5].
The implementation of enhanced authentication is OPTIONAL for both Clients and Servers.
If the Client does not include an Authentication Method in the CONNECT, the Server MUST NOT send an AUTH packet, and it MUST NOT send an Authentication Method in the CONNACK packet [MQTT-4.12.0-6].
If the Client does not include an Authentication Method in the CONNECT, the Client MUST NOT send an AUTH packet to the Server [MQTT-4.12.0-7].
If the Client does not include an Authentication Method in the CONNECT packet, the Server SHOULD authenticate using some or all of the information in the CONNECT packet, TLS session, and Network Connection.
Non-normative example showing a SCRAM challenge â¢ Client to Server: CONNECT Authentication Method="SCRAM-SHA-1" Authentication Data=client-first-data â¢ Server to Client: AUTH rc=0x18 Authentication Method="SCRAM-SHA-1" Authentication Data=server-first-data â¢ Client to Server AUTH rc=0x18 Authentication Method="SCRAM-SHA-1" Authentication Data=client-final-data â¢ Server to Client CONNACK rc=0 Authentication Method="SCRAM-SHA-1" Authentication Data=server-final-data Non-normative example showing a Kerberos challenge â¢ Client to Server CONNECT Authentication Method="GS2-KRB5" â¢ Server to Client AUTH rc=0x18 Authentication Method="GS2-KRB5" â¢ Client to Server AUTH rc=0x18 Authentication Method="GS2-KRB5" Authentication Data=initial context token â¢ Server to Client AUTH rc=0x18 Authentication Method="GS2-KRB5" Authentication Data=reply context token â¢ Client to Server AUTH rc=0x18 Authentication Method="GS2-KRB5" â¢ Server to Client CONNACK rc=0 Authentication Method="GS2-KRB5" Authentication Data=outcome of authentication 4.12.1 Re-authentication If the Client supplied an Authentication Method in the CONNECT packet it can initiate a re-authentication at any time after receiving a CONNACK.
It does this by sending an AUTH packet with a Reason Code of 0x19 (Re-authentication).
The Client MUST set the Authentication Method to the same value as the Authentication Method originally used to authenticate the Network Connection [MQTT-4.12.1-1].
If the authentication method requires Client data first, this AUTH packet contains the first piece of authentication data as the Authentication Data.
The Server responds to this re-authentication request by sending an AUTH packet to the Client with a Reason Code of 0x00 (Success) to indicate that the re-authentication is complete, or a Reason Code of 0x18 (Continue authentication) to indicate that more authentication data is needed.
The Client can respond with additional authentication data by sending an AUTH packet with a Reason Code of 0x18 (Continue authentication).
This flow continues as with the original authentication until the re- authentication is complete or the re-authentication fails.
If the re-authentication fails, the Client or Server SHOULD send DISCONNECT with an appropriate Reason Code as described in section 4.13, and MUST close the Network Connection [MQTT-4.12.1-2].
During this re-authentication sequence, the flow of other packets between the Client and Server can continue using the previous authentication.
Non-normative comment The Server might limit the scope of the changes the Client can attempt in a re-authentication by rejecting the re-authentication.
For instance, if the Server does not allow the User Name to be changed it can fail any re-authentication attempt which changes the User Name.
4.13 Handling errors 4.13.1 Malformed Packet and Protocol Errors Definitions of Malformed Packet and Protocol Errors are contained in section 1.2 Terminology, some but not all, of these error cases are noted throughout the specification.
The rigor with which a Client or Server checks an MQTT Control Packet it has received will be a compromise between: â¢ The size of the Client or Server implementation.
â¢ The capabilities that the implementation supports.
â¢ The degree to which the receiver trusts the sender to send correct MQTT Control Packets.
â¢ The degree to which the receiver trusts the network to deliver MQTT Control Packets correctly.
â¢ The consequences of continuing to process a packet that is incorrect.
If the sender is compliant with this specification it will not send Malformed Packets or cause Protocol Errors.
However, if a Client sends MQTT Control Packets before it receives CONNACK, it might cause a Protocol Error because it made an incorrect assumption about the Server capabilities.
Refer to section 3.1.4 CONNECT Actions.
The Reason Codes used for Malformed Packet and Protocol Errors are: â¢ 0x81 Malformed Packet â¢ 0x82 Protocol Error â¢ 0x93 Receive Maximum exceeded â¢ 0x95 Packet too large â¢ 0x9A Retain not supported â¢ 0x9B QoS not supported â¢ 0x9E Shared Subscriptions not supported â¢ 0xA1 Subscription Identifiers not supported â¢ 0xA2 Wildcard Subscriptions not supported When a Client detects a Malformed Packet or Protocol Error, and a Reason Code is given in the specification, it SHOULD close the Network Connection.
In the case of an error in a AUTH packet it MAY send a DISCONNECT packet containing the reason code, before closing the Network Connection.
In the case of an error in any other packet it SHOULD send a DISCONNECT packet containing the reason code before closing the Network Connection.
Use Reason Code 0x81 (Malformed Packet) or 0x82 (Protocol Error) unless a more specific Reason Code has been defined in section 3.14.2.1 Disconnect Reason Code.
When a Server detects a Malformed Packet or Protocol Error, and a Reason Code is given in the specification, it MUST close the Network Connection [MQTT-4.13.1-1].
In the case of an error in a CONNECT packet it MAY send a CONNACK packet containing the Reason Code, before closing the Network Connection.
In the case of an error in any other packet it SHOULD send a DISCONNECT packet containing the Reason Code before closing the Network Connection.
Use Reason Code 0x81 (Malformed Packet) or 0x82 (Protocol Error) unless a more specific Reason Code has been defined in section 3.2.2.2 - Connect Reason Code or in section 3.14.2.1 â Disconnect Reason Code.
There are no consequences for other Sessions.
If either the Server or Client omits to check some feature of an MQTT Control Packet, it might fail to detect an error, consequently it might allow data to be damaged.
4.13.2 Other errors Errors other than Malformed Packet and Protocol Errors cannot be anticipated by the sender because the receiver might have constraints which it has not communicated to the sender.
A receiving Client or Server might encounter a transient error, such as a shortage of memory, that prevents successful processing of an individual MQTT Control Packet.
Acknowledgment packets PUBACK, PUBREC, PUBREL, PUBCOMP, SUBACK, UNSUBACK with a Reason Code of 0x80 or greater indicate that the received packet, identified by a Packet Identifier, was in error.
There are no consequences for other Sessions or other Packets flowing on the same Session.
The CONNACK and DISCONNECT packets allow a Reason Code of 0x80 or greater to indicate that the Network Connection will be closed.
If a Reason Code of 0x80 or greater is specified, then the Network Connection MUST be closed whether or not the CONNACK or DISCONNECT is sent [MQTT-4.13.2-1].
Sending of one of these Reason Codes does not have consequence for any other Session.
If the Control Packet contains multiple errors the receiver of the Packet can validate the Packet in any order and take the appropriate action for any of the errors found.
Refer to section 5.4.9 for information about handling Disallowed Unicode code points.
Security (non-normative) 5.1 Introduction MQTT is a transport protocol specification for message transmission, allowing implementers a choice of network, privacy, authentication and authorization technologies.
Since the exact security technologies chosen will be context specific, it is the implementer's responsibility to include the appropriate features as part of their design.
MQTT Implementations will likely need to keep pace with an evolving security landscape.
This Chapter provides general implementation guidance so as not to restrict choices available and is therefore non-normative.
This should not detract from its importance.
It is strongly recommended that Server implementations that offer TLS [RFC5246] should use TCP port 8883 (IANA service name: secure-mqtt).
There are a number of threats that solution providers should consider.
For example: â¢ Devices could be compromised â¢ Data at rest in Clients and Servers might be accessible â¢ Protocol behaviors could have side effects (e.g.
âtiming attacksâ) â¢ Denial of Service (DoS) attacks â¢ Communications could be intercepted, altered, re-routed or disclosed â¢ Injection of spoofed MQTT Control Packets MQTT solutions are often deployed in hostile communication environments.
In such cases, implementations will often need to provide mechanisms for: â¢ Authentication of users and devices â¢ Authorization of access to Server resources â¢ Integrity of MQTT Control Packets and application data contained therein â¢ Privacy of MQTT Control Packets and application data contained therein In addition to technical security issues there could also be geographic (e.g.
U.S.-EU Privacy Shield Framework [USEUPRIVSH]), industry specific (e.g.
PCI DSS [PCIDSS]) and regulatory considerations (e.g.
Sarbanes-Oxley [SARBANES]).
5.2 MQTT solutions: security and certification An implementation might want to provide conformance with specific industry security standards such as NIST Cyber Security Framework [NISTCSF], PCI-DSS [PCIDSS]), FIPS-140-2 [FIPS1402] and NSA Suite B [NSAB].
Guidance on using MQTT within the NIST Cyber Security Framework [NISTCSF] can be found in the MQTT supplemental publication, MQTT and the NIST Framework for Improving Critical Infrastructure Cybersecurity [MQTTNIST].
The use of industry proven, independently verified and certified technologies will help meet compliance requirements.
5.3 Lightweight crytography and constrained devices Advanced Encryption Standard [AES] is the most widely adopted encryption algorithm.
There is hardware support for AES in many processors, but not commonly for embedded processors.
The encryption algorithm ChaCha20 [CHACHA20] encrypts and decrypts much faster in software, but is not as widely available as AES.
ISO 29192 [ISO29192] makes recommendations for cryptographic primitives specifically tuned to perform on constrained âlow endâ devices.
5.4 Implementation notes There are many security concerns to consider when implementing or using MQTT.
The following section should not be considered a âcheck listâ.
An implementation might want to achieve some, or all, of the following: 5.4.1 Authentication of Clients by the Server The CONNECT packet contains User Name and Password fields.
Implementations can choose how to make use of the content of these fields.
They may provide their own authentication mechanism, use an external authentication system such as LDAP [RFC4511] or OAuth [RFC6749] tokens, or leverage operating system authentication mechanisms.
MQTT v5.0 provides an enhanced authentication mechanism as described in section 4.12.
Using this requires support for it in both the Client and Server.
Implementations passing authentication data in clear text, obfuscating such data elements or requiring no authentication data should be aware this can give rise to Man-in-the-Middle and replay attacks.
Section 5.4.5 introduces approaches to ensure data privacy.
A Virtual Private Network (VPN) between the Clients and Servers can provide confidence that data is only being received from authorized Clients.
Where TLS [RFC5246] is used, TLS Certificates sent from the Client can be used by the Server to authenticate the Client.
An implementation might allow for authentication where the credentials are sent in an Application Message from the Client to the Server.
5.4.2 Authorization of Clients by the Server If a Client has been successfully authenticated, a Server implementation should check that it is authorized before accepting its connection.
Authorization may be based on information provided by the Client such as User Name, the hostname/IP address of the Client, or the outcome of authentication mechanisms.
In particular, the implementation should check that the Client is authorized to use the Client Identifier as this gives access to the MQTT Session State (described in section 4.1).
This authorization check is to protect against the case where one Client, accidentally or maliciously, provides a Client Identifier that is already being used by some other Client.
An implementation should provide access controls that take place after CONNECT to restrict the Clients ability to publish to particular Topics or to subscribe using particular Topic Filters.
An implementation should consider limiting access to Topic Filters that have broad scope, such as the # Topic Filter.
5.4.3 Authentication of the Server by the Client The MQTT protocol is not trust symmetrical.
When using basic authentication, there is no mechanism for the Client to authenticate the Server.
Some forms of extended authentication do allow for mutual authentication.
Where TLS [RFC5246] is used, TLS Certificates sent from the Server can be used by the Client to authenticate the Server.
Implementations providing MQTT service for multiple hostnames from a single IP address should be aware of the Server Name Indication extension to TLS defined in section 3 of [RFC6066].This allows a Client to tell the Server the hostname of the Server it is trying to connect to.
An implementation might allow for authentication where the credentials are sent in an Application Message from the Server to the Client.
MQTT v5.0 provides an enhanced authentication mechanism as described in section 4.12., which can be used to Authenticate the Server to the Client.
Using this requires support for it in both the Client and Server.
A VPN between Clients and Servers can provide confidence that Clients are connecting to the intended Server.
5.4.4 Integrity of Application Messages and MQTT Control Packets Applications can independently include hash values in their Application Messages.
This can provide integrity of the contents of Publish packets across the network and at rest.
TLS [RFC5246] provides hash algorithms to verify the integrity of data sent over the network.
The use of VPNs to connect Clients and Servers can provide integrity of data across the section of the network covered by a VPN.
5.4.5 Privacy of Application Messages and MQTT Control Packets TLS [RFC5246] can provide encryption of data sent over the network.
There are valid TLS cipher suites that include a NULL encryption algorithm that does not encrypt data.
To ensure privacy Clients and Servers should avoid these cipher suites.
An application might independently encrypt the contents of its Application Messages.
This could provide privacy of the Application Message both over the network and at rest.
This would not provide privacy for other Properties of the Application Message such as Topic Name.
Client and Server implementations can provide encrypted storage for data at rest such as Application Messages stored as part of a Session.
The use of VPNs to connect Clients and Servers can provide privacy of data across the section of the network covered by a VPN.
5.4.6 Non-repudiation of message transmission Application designers might need to consider appropriate strategies to achieve end to end non- repudiation.
5.4.7 Detecting compromise of Clients and Servers Client and Server implementations using TLS [RFC5246] should provide capabilities to ensure that any TLS certificates provided when initiating a TLS connection are associated with the hostname of the Client connecting or Server being connected to.
Client and Server implementations using TLS can choose to provide capabilities to check Certificate Revocation Lists (CRLs [RFC5280]) and Online Certificate Status Protocol (OSCP) [RFC6960] to prevent revoked certificates from being used.
Physical deployments might combine tamper-proof hardware with the transmission of specific data in Application Messages.
For example, a meter might have an embedded GPS to ensure it is not used in an unauthorized location.
[IEEE8021AR] is a standard for implementing mechanisms to authenticate a deviceâs identity using a cryptographically bound identifier.
5.4.8 Detecting abnormal behaviors Server implementations might monitor Client behavior to detect potential security incidents.
For example: â¢ Repeated connection attempts â¢ Repeated authentication attempts â¢ Abnormal termination of connections â¢ Topic scanning (attempts to send or subscribe to many topics) â¢ Sending undeliverable messages (no subscribers to the topics) â¢ Clients that connect but do not send data Server implementations might close the Network Connection of Clients that breach its security rules.
Server implementations detecting unwelcome behavior might implement a dynamic block list based on identifiers such as IP address or Client Identifier.
Deployments might use network-level controls (where available) to implement rate limiting or blocking based on IP address or other information.
5.4.9 Handling of Disallowed Unicode code points Section 1.5.4 describes the Disallowed Unicode code points, which should not be included in a UTF-8 Encoded String.
A Client or Server implementation can choose whether to validate that these code points are not used in UTF-8 Encoded Strings such as the Topic Name or Properties.
If the Server does not validate the code points in a UTF-8 Encoded String but a subscribing Client does, then a second Client might be able to cause the subscribing Client to close the Network Connection by publishing on a Topic Name or using Properties that contain a Disallowed Unicode code point.
This section recommends some steps that can be taken to prevent this problem.
A similar problem can occur when the Client validates that the payload matches the Payload Format Indicator and the Server does not.
The considerations and remedies for this are similar to those for handling Disallowed Unicode code points.
5.4.9.1 Considerations for the use of Disallowed Unicode code points An implementation would normally choose to validate UTF-8 Encoded strings, checking that the Disallowed Unicode code points are not used.
This avoids implementation difficulties such as the use of libraries that are sensitive to these code points, it also protects applications from having to process them.
Validating that these code points are not used removes some security exposures.
There are possible security exploits which use control characters in log files to mask entries in the logs or confuse the tools which process log files.
The Unicode Noncharacters are commonly used as special markers and allowing them into UTF-8 Encoded Strings could permit such exploits.
5.4.9.2 Interactions between Publishers and Subscribers The publisher of an Application Message normally expects that the Servers will forward the message to subscribers, and that these subscribers are capable of processing the messages.
These are some conditions under which a publishing Client can cause the subscribing Client to close the Network Connection.
Consider a situation where: â¢ A Client publishes an Application Message using a Topic Name containing one of the Disallowed Unicode code points.
â¢ The publishing Client library allows the Disallowed Unicode code point to be used in a Topic Name rather than rejecting it.
â¢ The publishing Client is authorized to send the publication.
â¢ A subscribing Client is authorized to use a Topic Filter which matches the Topic Name.
Note that the Disallowed Unicode code point might occur in a part of the Topic Name matching a wildcard character in the Topic Filter.
â¢ The Server forwards the message to the matching subscriber rather than disconnecting the publisher.
â¢ In this case the subscribing Client might: o Close the Network Connection because it does not allow the use of Disallowed Unicode code points, possibly sending a DISCONNECT before doing so.
For QoS 1 and QoS 2 messages this might cause the Server to send the message again, causing the Client to close the Network Connection again.
o Reject the Application Message by sending a Reason Code greater than or equal to 0x80 in a PUBACK (QoS 1) or PUBREC (QoS 2).
o Accept the Application Message but fail to process it because it contains one of the Disallowed Unicode code points.
o Successfully process the Application Message.
The potential for the Client to close the Network Connection might go unnoticed until a publisher uses one of the Disallowed Unicode code points.
5.4.9.3 Remedies If there is a possibility that a Disallowed Unicode code point could be included in a Topic Name or other Properties delivered to a Client, the solution owner can adopt one of the following suggestions: 1) Change the Server implementation to one that rejects UTF-8 Encoded Strings containing a Disallowed Unicode code point either by sending a Reason Code greater than or equal to 0x80 or closing the Network Connection.
2) Change the Client library used by the subscribers to one that tolerates the use of Disallowed Code points.
The client can either process or discard messages with UTF-8 Encoded Strings that contain Disallowed Unicode code points so long as it continues the protocol.
5.4.10 Other security considerations If Client or Server TLS certificates are lost or it is considered that they might be compromised they should be revoked (utilizing CRLs [RFC5280] and/or OSCP [RFC6960]).
Client or Server authentication credentials, such as User Name and Password, that are lost or considered compromised should be revoked and/or reissued.
In the case of long lasting connections: â¢ Client and Server implementations using TLS [RFC5246] should allow for session renegotiation to establish new cryptographic parameters (replace session keys, change cipher suites, change authentication credentials).
â¢ Servers may close the Network Connection of Clients and require them to re-authenticate with new credentials.
â¢ Servers may require their Client to reauthenticate periodically using the mechanism described in section 4.12.1.
Constrained devices and Clients on constrained networks can make use of TLS [RFC5246] session resumption, in order to reduce the costs of reconnecting TLS [RFC5246] sessions.
Clients connected to a Server have a transitive trust relationship with other Clients connected to the same Server and who have authority to publish data on the same topics.
5.4.11 Use of SOCKS Implementations of Clients should be aware that some environments will require the use of SOCKSv5 [RFC1928] proxies to make outbound Network Connections.
Some MQTT implementations could make use of alternative secured tunnels (e.g.
SSH) through the use of SOCKS.
Where implementations choose to use SOCKS, they should support both anonymous and User Name, Password authenticating SOCKS proxies.
In the latter case, implementations should be aware that SOCKS authentication might occur in plain-text and so should avoid using the same credentials for connection to a MQTT Server.
5.4.12 Security profiles Implementers and solution designers might wish to consider security as a set of profiles which can be applied to the MQTT protocol.
An example of a layered security hierarchy is presented below.
5.4.12.1 Clear communication profile When using the clear communication profile, the MQTT protocol runs over an open network with no additional secure communication mechanisms in place.
5.4.12.2 Secured network communication profile When using the secured network communication profile, the MQTT protocol runs over a physical or virtual network which has security controls e.g., VPNs or physically secure network.
5.4.12.3 Secured transport profile When using the secured transport profile, the MQTT protocol runs over a physical or virtual network and using TLS [RFC5246] which provides authentication, integrity and privacy.
TLS [RFC5246] Client authentication can be used in addition to â or in place of â MQTT Client authentication as provided by the User Name and Password fields.
5.4.12.4 Industry specific security profiles It is anticipated that the MQTT protocol will be designed into industry specific application profiles, each defining a threat model and the specific security mechanisms to be used to address these threats.
Recommendations for specific security mechanisms will often be taken from existing works including: [NISTCSF] NIST Cyber Security Framework [NIST7628] NISTIR 7628 Guidelines for Smart Grid Cyber Security [FIPS1402] Security Requirements for Cryptographic Modules (FIPS PUB 140-2) [PCIDSS] PCI-DSS Payment Card Industry Data Security Standard [NSAB] NSA Suite B Cryptography Using WebSocket as a network transport If MQTT is transported over a WebSocket [RFC6455] connection, the following conditions apply: â¢ MQTT Control Packets MUST be sent in WebSocket binary data frames.
If any other type of data frame is received the recipient MUST close the Network Connection [MQTT-6.0.0-1].
â¢ A single WebSocket data frame can contain multiple or partial MQTT Control Packets.
The receiver MUST NOT assume that MQTT Control Packets are aligned on WebSocket frame boundaries [MQTT-6.0.0-2].
â¢ The Client MUST include âmqttâ in the list of WebSocket Sub Protocols it offers [MQTT-6.0.0-3].
â¢ The WebSocket Subprotocol name selected and returned by the Server MUST be âmqttâ [MQTT- â¢ The WebSocket URI used to connect the Client and Server has no impact on the MQTT protocol.
